// Code generated by ent, DO NOT EDIT.

package ent

import (
	"context"
	"errors"
	"fmt"
	"log"
	"reflect"

	"github.com/SeyramWood/ent/migrate"

	"entgo.io/ent"
	"entgo.io/ent/dialect"
	"entgo.io/ent/dialect/sql"
	"entgo.io/ent/dialect/sql/sqlgraph"
	"github.com/SeyramWood/ent/bookibususer"
	"github.com/SeyramWood/ent/booking"
	"github.com/SeyramWood/ent/company"
	"github.com/SeyramWood/ent/companyuser"
	"github.com/SeyramWood/ent/customer"
	"github.com/SeyramWood/ent/customercontact"
	"github.com/SeyramWood/ent/customerluggage"
	"github.com/SeyramWood/ent/incident"
	"github.com/SeyramWood/ent/incidentimage"
	"github.com/SeyramWood/ent/notification"
	"github.com/SeyramWood/ent/parcel"
	"github.com/SeyramWood/ent/parcelimage"
	"github.com/SeyramWood/ent/passenger"
	"github.com/SeyramWood/ent/route"
	"github.com/SeyramWood/ent/routestop"
	"github.com/SeyramWood/ent/trip"
	"github.com/SeyramWood/ent/user"
	"github.com/SeyramWood/ent/vehicle"
	"github.com/SeyramWood/ent/vehicleimage"
)

// Client is the client that holds all ent builders.
type Client struct {
	config
	// Schema is the client for creating, migrating and dropping schema.
	Schema *migrate.Schema
	// BookibusUser is the client for interacting with the BookibusUser builders.
	BookibusUser *BookibusUserClient
	// Booking is the client for interacting with the Booking builders.
	Booking *BookingClient
	// Company is the client for interacting with the Company builders.
	Company *CompanyClient
	// CompanyUser is the client for interacting with the CompanyUser builders.
	CompanyUser *CompanyUserClient
	// Customer is the client for interacting with the Customer builders.
	Customer *CustomerClient
	// CustomerContact is the client for interacting with the CustomerContact builders.
	CustomerContact *CustomerContactClient
	// CustomerLuggage is the client for interacting with the CustomerLuggage builders.
	CustomerLuggage *CustomerLuggageClient
	// Incident is the client for interacting with the Incident builders.
	Incident *IncidentClient
	// IncidentImage is the client for interacting with the IncidentImage builders.
	IncidentImage *IncidentImageClient
	// Notification is the client for interacting with the Notification builders.
	Notification *NotificationClient
	// Parcel is the client for interacting with the Parcel builders.
	Parcel *ParcelClient
	// ParcelImage is the client for interacting with the ParcelImage builders.
	ParcelImage *ParcelImageClient
	// Passenger is the client for interacting with the Passenger builders.
	Passenger *PassengerClient
	// Route is the client for interacting with the Route builders.
	Route *RouteClient
	// RouteStop is the client for interacting with the RouteStop builders.
	RouteStop *RouteStopClient
	// Trip is the client for interacting with the Trip builders.
	Trip *TripClient
	// User is the client for interacting with the User builders.
	User *UserClient
	// Vehicle is the client for interacting with the Vehicle builders.
	Vehicle *VehicleClient
	// VehicleImage is the client for interacting with the VehicleImage builders.
	VehicleImage *VehicleImageClient
}

// NewClient creates a new client configured with the given options.
func NewClient(opts ...Option) *Client {
	cfg := config{log: log.Println, hooks: &hooks{}, inters: &inters{}}
	cfg.options(opts...)
	client := &Client{config: cfg}
	client.init()
	return client
}

func (c *Client) init() {
	c.Schema = migrate.NewSchema(c.driver)
	c.BookibusUser = NewBookibusUserClient(c.config)
	c.Booking = NewBookingClient(c.config)
	c.Company = NewCompanyClient(c.config)
	c.CompanyUser = NewCompanyUserClient(c.config)
	c.Customer = NewCustomerClient(c.config)
	c.CustomerContact = NewCustomerContactClient(c.config)
	c.CustomerLuggage = NewCustomerLuggageClient(c.config)
	c.Incident = NewIncidentClient(c.config)
	c.IncidentImage = NewIncidentImageClient(c.config)
	c.Notification = NewNotificationClient(c.config)
	c.Parcel = NewParcelClient(c.config)
	c.ParcelImage = NewParcelImageClient(c.config)
	c.Passenger = NewPassengerClient(c.config)
	c.Route = NewRouteClient(c.config)
	c.RouteStop = NewRouteStopClient(c.config)
	c.Trip = NewTripClient(c.config)
	c.User = NewUserClient(c.config)
	c.Vehicle = NewVehicleClient(c.config)
	c.VehicleImage = NewVehicleImageClient(c.config)
}

type (
	// config is the configuration for the client and its builder.
	config struct {
		// driver used for executing database requests.
		driver dialect.Driver
		// debug enable a debug logging.
		debug bool
		// log used for logging on debug mode.
		log func(...any)
		// hooks to execute on mutations.
		hooks *hooks
		// interceptors to execute on queries.
		inters *inters
	}
	// Option function to configure the client.
	Option func(*config)
)

// options applies the options on the config object.
func (c *config) options(opts ...Option) {
	for _, opt := range opts {
		opt(c)
	}
	if c.debug {
		c.driver = dialect.Debug(c.driver, c.log)
	}
}

// Debug enables debug logging on the ent.Driver.
func Debug() Option {
	return func(c *config) {
		c.debug = true
	}
}

// Log sets the logging function for debug mode.
func Log(fn func(...any)) Option {
	return func(c *config) {
		c.log = fn
	}
}

// Driver configures the client driver.
func Driver(driver dialect.Driver) Option {
	return func(c *config) {
		c.driver = driver
	}
}

// Open opens a database/sql.DB specified by the driver name and
// the data source name, and returns a new client attached to it.
// Optional parameters can be added for configuring the client.
func Open(driverName, dataSourceName string, options ...Option) (*Client, error) {
	switch driverName {
	case dialect.MySQL, dialect.Postgres, dialect.SQLite:
		drv, err := sql.Open(driverName, dataSourceName)
		if err != nil {
			return nil, err
		}
		return NewClient(append(options, Driver(drv))...), nil
	default:
		return nil, fmt.Errorf("unsupported driver: %q", driverName)
	}
}

// ErrTxStarted is returned when trying to start a new transaction from a transactional client.
var ErrTxStarted = errors.New("ent: cannot start a transaction within a transaction")

// Tx returns a new transactional client. The provided context
// is used until the transaction is committed or rolled back.
func (c *Client) Tx(ctx context.Context) (*Tx, error) {
	if _, ok := c.driver.(*txDriver); ok {
		return nil, ErrTxStarted
	}
	tx, err := newTx(ctx, c.driver)
	if err != nil {
		return nil, fmt.Errorf("ent: starting a transaction: %w", err)
	}
	cfg := c.config
	cfg.driver = tx
	return &Tx{
		ctx:             ctx,
		config:          cfg,
		BookibusUser:    NewBookibusUserClient(cfg),
		Booking:         NewBookingClient(cfg),
		Company:         NewCompanyClient(cfg),
		CompanyUser:     NewCompanyUserClient(cfg),
		Customer:        NewCustomerClient(cfg),
		CustomerContact: NewCustomerContactClient(cfg),
		CustomerLuggage: NewCustomerLuggageClient(cfg),
		Incident:        NewIncidentClient(cfg),
		IncidentImage:   NewIncidentImageClient(cfg),
		Notification:    NewNotificationClient(cfg),
		Parcel:          NewParcelClient(cfg),
		ParcelImage:     NewParcelImageClient(cfg),
		Passenger:       NewPassengerClient(cfg),
		Route:           NewRouteClient(cfg),
		RouteStop:       NewRouteStopClient(cfg),
		Trip:            NewTripClient(cfg),
		User:            NewUserClient(cfg),
		Vehicle:         NewVehicleClient(cfg),
		VehicleImage:    NewVehicleImageClient(cfg),
	}, nil
}

// BeginTx returns a transactional client with specified options.
func (c *Client) BeginTx(ctx context.Context, opts *sql.TxOptions) (*Tx, error) {
	if _, ok := c.driver.(*txDriver); ok {
		return nil, errors.New("ent: cannot start a transaction within a transaction")
	}
	tx, err := c.driver.(interface {
		BeginTx(context.Context, *sql.TxOptions) (dialect.Tx, error)
	}).BeginTx(ctx, opts)
	if err != nil {
		return nil, fmt.Errorf("ent: starting a transaction: %w", err)
	}
	cfg := c.config
	cfg.driver = &txDriver{tx: tx, drv: c.driver}
	return &Tx{
		ctx:             ctx,
		config:          cfg,
		BookibusUser:    NewBookibusUserClient(cfg),
		Booking:         NewBookingClient(cfg),
		Company:         NewCompanyClient(cfg),
		CompanyUser:     NewCompanyUserClient(cfg),
		Customer:        NewCustomerClient(cfg),
		CustomerContact: NewCustomerContactClient(cfg),
		CustomerLuggage: NewCustomerLuggageClient(cfg),
		Incident:        NewIncidentClient(cfg),
		IncidentImage:   NewIncidentImageClient(cfg),
		Notification:    NewNotificationClient(cfg),
		Parcel:          NewParcelClient(cfg),
		ParcelImage:     NewParcelImageClient(cfg),
		Passenger:       NewPassengerClient(cfg),
		Route:           NewRouteClient(cfg),
		RouteStop:       NewRouteStopClient(cfg),
		Trip:            NewTripClient(cfg),
		User:            NewUserClient(cfg),
		Vehicle:         NewVehicleClient(cfg),
		VehicleImage:    NewVehicleImageClient(cfg),
	}, nil
}

// Debug returns a new debug-client. It's used to get verbose logging on specific operations.
//
//	client.Debug().
//		BookibusUser.
//		Query().
//		Count(ctx)
func (c *Client) Debug() *Client {
	if c.debug {
		return c
	}
	cfg := c.config
	cfg.driver = dialect.Debug(c.driver, c.log)
	client := &Client{config: cfg}
	client.init()
	return client
}

// Close closes the database connection and prevents new queries from starting.
func (c *Client) Close() error {
	return c.driver.Close()
}

// Use adds the mutation hooks to all the entity clients.
// In order to add hooks to a specific client, call: `client.Node.Use(...)`.
func (c *Client) Use(hooks ...Hook) {
	for _, n := range []interface{ Use(...Hook) }{
		c.BookibusUser, c.Booking, c.Company, c.CompanyUser, c.Customer,
		c.CustomerContact, c.CustomerLuggage, c.Incident, c.IncidentImage,
		c.Notification, c.Parcel, c.ParcelImage, c.Passenger, c.Route, c.RouteStop,
		c.Trip, c.User, c.Vehicle, c.VehicleImage,
	} {
		n.Use(hooks...)
	}
}

// Intercept adds the query interceptors to all the entity clients.
// In order to add interceptors to a specific client, call: `client.Node.Intercept(...)`.
func (c *Client) Intercept(interceptors ...Interceptor) {
	for _, n := range []interface{ Intercept(...Interceptor) }{
		c.BookibusUser, c.Booking, c.Company, c.CompanyUser, c.Customer,
		c.CustomerContact, c.CustomerLuggage, c.Incident, c.IncidentImage,
		c.Notification, c.Parcel, c.ParcelImage, c.Passenger, c.Route, c.RouteStop,
		c.Trip, c.User, c.Vehicle, c.VehicleImage,
	} {
		n.Intercept(interceptors...)
	}
}

// Mutate implements the ent.Mutator interface.
func (c *Client) Mutate(ctx context.Context, m Mutation) (Value, error) {
	switch m := m.(type) {
	case *BookibusUserMutation:
		return c.BookibusUser.mutate(ctx, m)
	case *BookingMutation:
		return c.Booking.mutate(ctx, m)
	case *CompanyMutation:
		return c.Company.mutate(ctx, m)
	case *CompanyUserMutation:
		return c.CompanyUser.mutate(ctx, m)
	case *CustomerMutation:
		return c.Customer.mutate(ctx, m)
	case *CustomerContactMutation:
		return c.CustomerContact.mutate(ctx, m)
	case *CustomerLuggageMutation:
		return c.CustomerLuggage.mutate(ctx, m)
	case *IncidentMutation:
		return c.Incident.mutate(ctx, m)
	case *IncidentImageMutation:
		return c.IncidentImage.mutate(ctx, m)
	case *NotificationMutation:
		return c.Notification.mutate(ctx, m)
	case *ParcelMutation:
		return c.Parcel.mutate(ctx, m)
	case *ParcelImageMutation:
		return c.ParcelImage.mutate(ctx, m)
	case *PassengerMutation:
		return c.Passenger.mutate(ctx, m)
	case *RouteMutation:
		return c.Route.mutate(ctx, m)
	case *RouteStopMutation:
		return c.RouteStop.mutate(ctx, m)
	case *TripMutation:
		return c.Trip.mutate(ctx, m)
	case *UserMutation:
		return c.User.mutate(ctx, m)
	case *VehicleMutation:
		return c.Vehicle.mutate(ctx, m)
	case *VehicleImageMutation:
		return c.VehicleImage.mutate(ctx, m)
	default:
		return nil, fmt.Errorf("ent: unknown mutation type %T", m)
	}
}

// BookibusUserClient is a client for the BookibusUser schema.
type BookibusUserClient struct {
	config
}

// NewBookibusUserClient returns a client for the BookibusUser from the given config.
func NewBookibusUserClient(c config) *BookibusUserClient {
	return &BookibusUserClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `bookibususer.Hooks(f(g(h())))`.
func (c *BookibusUserClient) Use(hooks ...Hook) {
	c.hooks.BookibusUser = append(c.hooks.BookibusUser, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `bookibususer.Intercept(f(g(h())))`.
func (c *BookibusUserClient) Intercept(interceptors ...Interceptor) {
	c.inters.BookibusUser = append(c.inters.BookibusUser, interceptors...)
}

// Create returns a builder for creating a BookibusUser entity.
func (c *BookibusUserClient) Create() *BookibusUserCreate {
	mutation := newBookibusUserMutation(c.config, OpCreate)
	return &BookibusUserCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of BookibusUser entities.
func (c *BookibusUserClient) CreateBulk(builders ...*BookibusUserCreate) *BookibusUserCreateBulk {
	return &BookibusUserCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *BookibusUserClient) MapCreateBulk(slice any, setFunc func(*BookibusUserCreate, int)) *BookibusUserCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &BookibusUserCreateBulk{err: fmt.Errorf("calling to BookibusUserClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*BookibusUserCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &BookibusUserCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for BookibusUser.
func (c *BookibusUserClient) Update() *BookibusUserUpdate {
	mutation := newBookibusUserMutation(c.config, OpUpdate)
	return &BookibusUserUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *BookibusUserClient) UpdateOne(bu *BookibusUser) *BookibusUserUpdateOne {
	mutation := newBookibusUserMutation(c.config, OpUpdateOne, withBookibusUser(bu))
	return &BookibusUserUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *BookibusUserClient) UpdateOneID(id int) *BookibusUserUpdateOne {
	mutation := newBookibusUserMutation(c.config, OpUpdateOne, withBookibusUserID(id))
	return &BookibusUserUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for BookibusUser.
func (c *BookibusUserClient) Delete() *BookibusUserDelete {
	mutation := newBookibusUserMutation(c.config, OpDelete)
	return &BookibusUserDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *BookibusUserClient) DeleteOne(bu *BookibusUser) *BookibusUserDeleteOne {
	return c.DeleteOneID(bu.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *BookibusUserClient) DeleteOneID(id int) *BookibusUserDeleteOne {
	builder := c.Delete().Where(bookibususer.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &BookibusUserDeleteOne{builder}
}

// Query returns a query builder for BookibusUser.
func (c *BookibusUserClient) Query() *BookibusUserQuery {
	return &BookibusUserQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeBookibusUser},
		inters: c.Interceptors(),
	}
}

// Get returns a BookibusUser entity by its id.
func (c *BookibusUserClient) Get(ctx context.Context, id int) (*BookibusUser, error) {
	return c.Query().Where(bookibususer.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *BookibusUserClient) GetX(ctx context.Context, id int) *BookibusUser {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryProfile queries the profile edge of a BookibusUser.
func (c *BookibusUserClient) QueryProfile(bu *BookibusUser) *UserQuery {
	query := (&UserClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := bu.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(bookibususer.Table, bookibususer.FieldID, id),
			sqlgraph.To(user.Table, user.FieldID),
			sqlgraph.Edge(sqlgraph.O2O, false, bookibususer.ProfileTable, bookibususer.ProfileColumn),
		)
		fromV = sqlgraph.Neighbors(bu.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryNotifications queries the notifications edge of a BookibusUser.
func (c *BookibusUserClient) QueryNotifications(bu *BookibusUser) *NotificationQuery {
	query := (&NotificationClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := bu.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(bookibususer.Table, bookibususer.FieldID, id),
			sqlgraph.To(notification.Table, notification.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, false, bookibususer.NotificationsTable, bookibususer.NotificationsPrimaryKey...),
		)
		fromV = sqlgraph.Neighbors(bu.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *BookibusUserClient) Hooks() []Hook {
	return c.hooks.BookibusUser
}

// Interceptors returns the client interceptors.
func (c *BookibusUserClient) Interceptors() []Interceptor {
	return c.inters.BookibusUser
}

func (c *BookibusUserClient) mutate(ctx context.Context, m *BookibusUserMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&BookibusUserCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&BookibusUserUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&BookibusUserUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&BookibusUserDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown BookibusUser mutation op: %q", m.Op())
	}
}

// BookingClient is a client for the Booking schema.
type BookingClient struct {
	config
}

// NewBookingClient returns a client for the Booking from the given config.
func NewBookingClient(c config) *BookingClient {
	return &BookingClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `booking.Hooks(f(g(h())))`.
func (c *BookingClient) Use(hooks ...Hook) {
	c.hooks.Booking = append(c.hooks.Booking, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `booking.Intercept(f(g(h())))`.
func (c *BookingClient) Intercept(interceptors ...Interceptor) {
	c.inters.Booking = append(c.inters.Booking, interceptors...)
}

// Create returns a builder for creating a Booking entity.
func (c *BookingClient) Create() *BookingCreate {
	mutation := newBookingMutation(c.config, OpCreate)
	return &BookingCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Booking entities.
func (c *BookingClient) CreateBulk(builders ...*BookingCreate) *BookingCreateBulk {
	return &BookingCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *BookingClient) MapCreateBulk(slice any, setFunc func(*BookingCreate, int)) *BookingCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &BookingCreateBulk{err: fmt.Errorf("calling to BookingClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*BookingCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &BookingCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Booking.
func (c *BookingClient) Update() *BookingUpdate {
	mutation := newBookingMutation(c.config, OpUpdate)
	return &BookingUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *BookingClient) UpdateOne(b *Booking) *BookingUpdateOne {
	mutation := newBookingMutation(c.config, OpUpdateOne, withBooking(b))
	return &BookingUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *BookingClient) UpdateOneID(id int) *BookingUpdateOne {
	mutation := newBookingMutation(c.config, OpUpdateOne, withBookingID(id))
	return &BookingUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Booking.
func (c *BookingClient) Delete() *BookingDelete {
	mutation := newBookingMutation(c.config, OpDelete)
	return &BookingDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *BookingClient) DeleteOne(b *Booking) *BookingDeleteOne {
	return c.DeleteOneID(b.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *BookingClient) DeleteOneID(id int) *BookingDeleteOne {
	builder := c.Delete().Where(booking.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &BookingDeleteOne{builder}
}

// Query returns a query builder for Booking.
func (c *BookingClient) Query() *BookingQuery {
	return &BookingQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeBooking},
		inters: c.Interceptors(),
	}
}

// Get returns a Booking entity by its id.
func (c *BookingClient) Get(ctx context.Context, id int) (*Booking, error) {
	return c.Query().Where(booking.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *BookingClient) GetX(ctx context.Context, id int) *Booking {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryPassengers queries the passengers edge of a Booking.
func (c *BookingClient) QueryPassengers(b *Booking) *PassengerQuery {
	query := (&PassengerClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := b.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(booking.Table, booking.FieldID, id),
			sqlgraph.To(passenger.Table, passenger.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, booking.PassengersTable, booking.PassengersColumn),
		)
		fromV = sqlgraph.Neighbors(b.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryLuggages queries the luggages edge of a Booking.
func (c *BookingClient) QueryLuggages(b *Booking) *CustomerLuggageQuery {
	query := (&CustomerLuggageClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := b.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(booking.Table, booking.FieldID, id),
			sqlgraph.To(customerluggage.Table, customerluggage.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, booking.LuggagesTable, booking.LuggagesColumn),
		)
		fromV = sqlgraph.Neighbors(b.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryContact queries the contact edge of a Booking.
func (c *BookingClient) QueryContact(b *Booking) *CustomerContactQuery {
	query := (&CustomerContactClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := b.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(booking.Table, booking.FieldID, id),
			sqlgraph.To(customercontact.Table, customercontact.FieldID),
			sqlgraph.Edge(sqlgraph.O2O, false, booking.ContactTable, booking.ContactColumn),
		)
		fromV = sqlgraph.Neighbors(b.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryTrip queries the trip edge of a Booking.
func (c *BookingClient) QueryTrip(b *Booking) *TripQuery {
	query := (&TripClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := b.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(booking.Table, booking.FieldID, id),
			sqlgraph.To(trip.Table, trip.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, booking.TripTable, booking.TripColumn),
		)
		fromV = sqlgraph.Neighbors(b.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryCompany queries the company edge of a Booking.
func (c *BookingClient) QueryCompany(b *Booking) *CompanyQuery {
	query := (&CompanyClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := b.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(booking.Table, booking.FieldID, id),
			sqlgraph.To(company.Table, company.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, booking.CompanyTable, booking.CompanyColumn),
		)
		fromV = sqlgraph.Neighbors(b.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryCustomer queries the customer edge of a Booking.
func (c *BookingClient) QueryCustomer(b *Booking) *CustomerQuery {
	query := (&CustomerClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := b.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(booking.Table, booking.FieldID, id),
			sqlgraph.To(customer.Table, customer.FieldID),
			sqlgraph.Edge(sqlgraph.O2O, true, booking.CustomerTable, booking.CustomerColumn),
		)
		fromV = sqlgraph.Neighbors(b.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *BookingClient) Hooks() []Hook {
	return c.hooks.Booking
}

// Interceptors returns the client interceptors.
func (c *BookingClient) Interceptors() []Interceptor {
	return c.inters.Booking
}

func (c *BookingClient) mutate(ctx context.Context, m *BookingMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&BookingCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&BookingUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&BookingUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&BookingDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown Booking mutation op: %q", m.Op())
	}
}

// CompanyClient is a client for the Company schema.
type CompanyClient struct {
	config
}

// NewCompanyClient returns a client for the Company from the given config.
func NewCompanyClient(c config) *CompanyClient {
	return &CompanyClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `company.Hooks(f(g(h())))`.
func (c *CompanyClient) Use(hooks ...Hook) {
	c.hooks.Company = append(c.hooks.Company, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `company.Intercept(f(g(h())))`.
func (c *CompanyClient) Intercept(interceptors ...Interceptor) {
	c.inters.Company = append(c.inters.Company, interceptors...)
}

// Create returns a builder for creating a Company entity.
func (c *CompanyClient) Create() *CompanyCreate {
	mutation := newCompanyMutation(c.config, OpCreate)
	return &CompanyCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Company entities.
func (c *CompanyClient) CreateBulk(builders ...*CompanyCreate) *CompanyCreateBulk {
	return &CompanyCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *CompanyClient) MapCreateBulk(slice any, setFunc func(*CompanyCreate, int)) *CompanyCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &CompanyCreateBulk{err: fmt.Errorf("calling to CompanyClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*CompanyCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &CompanyCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Company.
func (c *CompanyClient) Update() *CompanyUpdate {
	mutation := newCompanyMutation(c.config, OpUpdate)
	return &CompanyUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *CompanyClient) UpdateOne(co *Company) *CompanyUpdateOne {
	mutation := newCompanyMutation(c.config, OpUpdateOne, withCompany(co))
	return &CompanyUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *CompanyClient) UpdateOneID(id int) *CompanyUpdateOne {
	mutation := newCompanyMutation(c.config, OpUpdateOne, withCompanyID(id))
	return &CompanyUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Company.
func (c *CompanyClient) Delete() *CompanyDelete {
	mutation := newCompanyMutation(c.config, OpDelete)
	return &CompanyDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *CompanyClient) DeleteOne(co *Company) *CompanyDeleteOne {
	return c.DeleteOneID(co.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *CompanyClient) DeleteOneID(id int) *CompanyDeleteOne {
	builder := c.Delete().Where(company.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &CompanyDeleteOne{builder}
}

// Query returns a query builder for Company.
func (c *CompanyClient) Query() *CompanyQuery {
	return &CompanyQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeCompany},
		inters: c.Interceptors(),
	}
}

// Get returns a Company entity by its id.
func (c *CompanyClient) Get(ctx context.Context, id int) (*Company, error) {
	return c.Query().Where(company.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *CompanyClient) GetX(ctx context.Context, id int) *Company {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryProfile queries the profile edge of a Company.
func (c *CompanyClient) QueryProfile(co *Company) *CompanyUserQuery {
	query := (&CompanyUserClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := co.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(company.Table, company.FieldID, id),
			sqlgraph.To(companyuser.Table, companyuser.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, company.ProfileTable, company.ProfileColumn),
		)
		fromV = sqlgraph.Neighbors(co.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryVehicles queries the vehicles edge of a Company.
func (c *CompanyClient) QueryVehicles(co *Company) *VehicleQuery {
	query := (&VehicleClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := co.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(company.Table, company.FieldID, id),
			sqlgraph.To(vehicle.Table, vehicle.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, company.VehiclesTable, company.VehiclesColumn),
		)
		fromV = sqlgraph.Neighbors(co.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryRoutes queries the routes edge of a Company.
func (c *CompanyClient) QueryRoutes(co *Company) *RouteQuery {
	query := (&RouteClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := co.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(company.Table, company.FieldID, id),
			sqlgraph.To(route.Table, route.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, company.RoutesTable, company.RoutesColumn),
		)
		fromV = sqlgraph.Neighbors(co.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryTrips queries the trips edge of a Company.
func (c *CompanyClient) QueryTrips(co *Company) *TripQuery {
	query := (&TripClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := co.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(company.Table, company.FieldID, id),
			sqlgraph.To(trip.Table, trip.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, company.TripsTable, company.TripsColumn),
		)
		fromV = sqlgraph.Neighbors(co.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryBookings queries the bookings edge of a Company.
func (c *CompanyClient) QueryBookings(co *Company) *BookingQuery {
	query := (&BookingClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := co.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(company.Table, company.FieldID, id),
			sqlgraph.To(booking.Table, booking.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, company.BookingsTable, company.BookingsColumn),
		)
		fromV = sqlgraph.Neighbors(co.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryIncidents queries the incidents edge of a Company.
func (c *CompanyClient) QueryIncidents(co *Company) *IncidentQuery {
	query := (&IncidentClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := co.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(company.Table, company.FieldID, id),
			sqlgraph.To(incident.Table, incident.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, company.IncidentsTable, company.IncidentsColumn),
		)
		fromV = sqlgraph.Neighbors(co.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryParcels queries the parcels edge of a Company.
func (c *CompanyClient) QueryParcels(co *Company) *ParcelQuery {
	query := (&ParcelClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := co.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(company.Table, company.FieldID, id),
			sqlgraph.To(parcel.Table, parcel.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, company.ParcelsTable, company.ParcelsColumn),
		)
		fromV = sqlgraph.Neighbors(co.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryNotifications queries the notifications edge of a Company.
func (c *CompanyClient) QueryNotifications(co *Company) *NotificationQuery {
	query := (&NotificationClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := co.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(company.Table, company.FieldID, id),
			sqlgraph.To(notification.Table, notification.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, company.NotificationsTable, company.NotificationsColumn),
		)
		fromV = sqlgraph.Neighbors(co.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *CompanyClient) Hooks() []Hook {
	return c.hooks.Company
}

// Interceptors returns the client interceptors.
func (c *CompanyClient) Interceptors() []Interceptor {
	return c.inters.Company
}

func (c *CompanyClient) mutate(ctx context.Context, m *CompanyMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&CompanyCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&CompanyUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&CompanyUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&CompanyDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown Company mutation op: %q", m.Op())
	}
}

// CompanyUserClient is a client for the CompanyUser schema.
type CompanyUserClient struct {
	config
}

// NewCompanyUserClient returns a client for the CompanyUser from the given config.
func NewCompanyUserClient(c config) *CompanyUserClient {
	return &CompanyUserClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `companyuser.Hooks(f(g(h())))`.
func (c *CompanyUserClient) Use(hooks ...Hook) {
	c.hooks.CompanyUser = append(c.hooks.CompanyUser, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `companyuser.Intercept(f(g(h())))`.
func (c *CompanyUserClient) Intercept(interceptors ...Interceptor) {
	c.inters.CompanyUser = append(c.inters.CompanyUser, interceptors...)
}

// Create returns a builder for creating a CompanyUser entity.
func (c *CompanyUserClient) Create() *CompanyUserCreate {
	mutation := newCompanyUserMutation(c.config, OpCreate)
	return &CompanyUserCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of CompanyUser entities.
func (c *CompanyUserClient) CreateBulk(builders ...*CompanyUserCreate) *CompanyUserCreateBulk {
	return &CompanyUserCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *CompanyUserClient) MapCreateBulk(slice any, setFunc func(*CompanyUserCreate, int)) *CompanyUserCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &CompanyUserCreateBulk{err: fmt.Errorf("calling to CompanyUserClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*CompanyUserCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &CompanyUserCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for CompanyUser.
func (c *CompanyUserClient) Update() *CompanyUserUpdate {
	mutation := newCompanyUserMutation(c.config, OpUpdate)
	return &CompanyUserUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *CompanyUserClient) UpdateOne(cu *CompanyUser) *CompanyUserUpdateOne {
	mutation := newCompanyUserMutation(c.config, OpUpdateOne, withCompanyUser(cu))
	return &CompanyUserUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *CompanyUserClient) UpdateOneID(id int) *CompanyUserUpdateOne {
	mutation := newCompanyUserMutation(c.config, OpUpdateOne, withCompanyUserID(id))
	return &CompanyUserUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for CompanyUser.
func (c *CompanyUserClient) Delete() *CompanyUserDelete {
	mutation := newCompanyUserMutation(c.config, OpDelete)
	return &CompanyUserDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *CompanyUserClient) DeleteOne(cu *CompanyUser) *CompanyUserDeleteOne {
	return c.DeleteOneID(cu.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *CompanyUserClient) DeleteOneID(id int) *CompanyUserDeleteOne {
	builder := c.Delete().Where(companyuser.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &CompanyUserDeleteOne{builder}
}

// Query returns a query builder for CompanyUser.
func (c *CompanyUserClient) Query() *CompanyUserQuery {
	return &CompanyUserQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeCompanyUser},
		inters: c.Interceptors(),
	}
}

// Get returns a CompanyUser entity by its id.
func (c *CompanyUserClient) Get(ctx context.Context, id int) (*CompanyUser, error) {
	return c.Query().Where(companyuser.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *CompanyUserClient) GetX(ctx context.Context, id int) *CompanyUser {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryProfile queries the profile edge of a CompanyUser.
func (c *CompanyUserClient) QueryProfile(cu *CompanyUser) *UserQuery {
	query := (&UserClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := cu.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(companyuser.Table, companyuser.FieldID, id),
			sqlgraph.To(user.Table, user.FieldID),
			sqlgraph.Edge(sqlgraph.O2O, false, companyuser.ProfileTable, companyuser.ProfileColumn),
		)
		fromV = sqlgraph.Neighbors(cu.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryTrips queries the trips edge of a CompanyUser.
func (c *CompanyUserClient) QueryTrips(cu *CompanyUser) *TripQuery {
	query := (&TripClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := cu.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(companyuser.Table, companyuser.FieldID, id),
			sqlgraph.To(trip.Table, trip.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, companyuser.TripsTable, companyuser.TripsColumn),
		)
		fromV = sqlgraph.Neighbors(cu.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryIncidents queries the incidents edge of a CompanyUser.
func (c *CompanyUserClient) QueryIncidents(cu *CompanyUser) *IncidentQuery {
	query := (&IncidentClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := cu.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(companyuser.Table, companyuser.FieldID, id),
			sqlgraph.To(incident.Table, incident.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, companyuser.IncidentsTable, companyuser.IncidentsColumn),
		)
		fromV = sqlgraph.Neighbors(cu.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryParcels queries the parcels edge of a CompanyUser.
func (c *CompanyUserClient) QueryParcels(cu *CompanyUser) *ParcelQuery {
	query := (&ParcelClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := cu.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(companyuser.Table, companyuser.FieldID, id),
			sqlgraph.To(parcel.Table, parcel.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, companyuser.ParcelsTable, companyuser.ParcelsColumn),
		)
		fromV = sqlgraph.Neighbors(cu.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryNotifications queries the notifications edge of a CompanyUser.
func (c *CompanyUserClient) QueryNotifications(cu *CompanyUser) *NotificationQuery {
	query := (&NotificationClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := cu.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(companyuser.Table, companyuser.FieldID, id),
			sqlgraph.To(notification.Table, notification.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, false, companyuser.NotificationsTable, companyuser.NotificationsPrimaryKey...),
		)
		fromV = sqlgraph.Neighbors(cu.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryCompany queries the company edge of a CompanyUser.
func (c *CompanyUserClient) QueryCompany(cu *CompanyUser) *CompanyQuery {
	query := (&CompanyClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := cu.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(companyuser.Table, companyuser.FieldID, id),
			sqlgraph.To(company.Table, company.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, companyuser.CompanyTable, companyuser.CompanyColumn),
		)
		fromV = sqlgraph.Neighbors(cu.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *CompanyUserClient) Hooks() []Hook {
	return c.hooks.CompanyUser
}

// Interceptors returns the client interceptors.
func (c *CompanyUserClient) Interceptors() []Interceptor {
	return c.inters.CompanyUser
}

func (c *CompanyUserClient) mutate(ctx context.Context, m *CompanyUserMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&CompanyUserCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&CompanyUserUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&CompanyUserUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&CompanyUserDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown CompanyUser mutation op: %q", m.Op())
	}
}

// CustomerClient is a client for the Customer schema.
type CustomerClient struct {
	config
}

// NewCustomerClient returns a client for the Customer from the given config.
func NewCustomerClient(c config) *CustomerClient {
	return &CustomerClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `customer.Hooks(f(g(h())))`.
func (c *CustomerClient) Use(hooks ...Hook) {
	c.hooks.Customer = append(c.hooks.Customer, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `customer.Intercept(f(g(h())))`.
func (c *CustomerClient) Intercept(interceptors ...Interceptor) {
	c.inters.Customer = append(c.inters.Customer, interceptors...)
}

// Create returns a builder for creating a Customer entity.
func (c *CustomerClient) Create() *CustomerCreate {
	mutation := newCustomerMutation(c.config, OpCreate)
	return &CustomerCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Customer entities.
func (c *CustomerClient) CreateBulk(builders ...*CustomerCreate) *CustomerCreateBulk {
	return &CustomerCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *CustomerClient) MapCreateBulk(slice any, setFunc func(*CustomerCreate, int)) *CustomerCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &CustomerCreateBulk{err: fmt.Errorf("calling to CustomerClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*CustomerCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &CustomerCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Customer.
func (c *CustomerClient) Update() *CustomerUpdate {
	mutation := newCustomerMutation(c.config, OpUpdate)
	return &CustomerUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *CustomerClient) UpdateOne(cu *Customer) *CustomerUpdateOne {
	mutation := newCustomerMutation(c.config, OpUpdateOne, withCustomer(cu))
	return &CustomerUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *CustomerClient) UpdateOneID(id int) *CustomerUpdateOne {
	mutation := newCustomerMutation(c.config, OpUpdateOne, withCustomerID(id))
	return &CustomerUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Customer.
func (c *CustomerClient) Delete() *CustomerDelete {
	mutation := newCustomerMutation(c.config, OpDelete)
	return &CustomerDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *CustomerClient) DeleteOne(cu *Customer) *CustomerDeleteOne {
	return c.DeleteOneID(cu.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *CustomerClient) DeleteOneID(id int) *CustomerDeleteOne {
	builder := c.Delete().Where(customer.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &CustomerDeleteOne{builder}
}

// Query returns a query builder for Customer.
func (c *CustomerClient) Query() *CustomerQuery {
	return &CustomerQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeCustomer},
		inters: c.Interceptors(),
	}
}

// Get returns a Customer entity by its id.
func (c *CustomerClient) Get(ctx context.Context, id int) (*Customer, error) {
	return c.Query().Where(customer.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *CustomerClient) GetX(ctx context.Context, id int) *Customer {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryProfile queries the profile edge of a Customer.
func (c *CustomerClient) QueryProfile(cu *Customer) *UserQuery {
	query := (&UserClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := cu.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(customer.Table, customer.FieldID, id),
			sqlgraph.To(user.Table, user.FieldID),
			sqlgraph.Edge(sqlgraph.O2O, false, customer.ProfileTable, customer.ProfileColumn),
		)
		fromV = sqlgraph.Neighbors(cu.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryBookings queries the bookings edge of a Customer.
func (c *CustomerClient) QueryBookings(cu *Customer) *BookingQuery {
	query := (&BookingClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := cu.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(customer.Table, customer.FieldID, id),
			sqlgraph.To(booking.Table, booking.FieldID),
			sqlgraph.Edge(sqlgraph.O2O, false, customer.BookingsTable, customer.BookingsColumn),
		)
		fromV = sqlgraph.Neighbors(cu.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryNotifications queries the notifications edge of a Customer.
func (c *CustomerClient) QueryNotifications(cu *Customer) *NotificationQuery {
	query := (&NotificationClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := cu.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(customer.Table, customer.FieldID, id),
			sqlgraph.To(notification.Table, notification.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, false, customer.NotificationsTable, customer.NotificationsPrimaryKey...),
		)
		fromV = sqlgraph.Neighbors(cu.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *CustomerClient) Hooks() []Hook {
	return c.hooks.Customer
}

// Interceptors returns the client interceptors.
func (c *CustomerClient) Interceptors() []Interceptor {
	return c.inters.Customer
}

func (c *CustomerClient) mutate(ctx context.Context, m *CustomerMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&CustomerCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&CustomerUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&CustomerUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&CustomerDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown Customer mutation op: %q", m.Op())
	}
}

// CustomerContactClient is a client for the CustomerContact schema.
type CustomerContactClient struct {
	config
}

// NewCustomerContactClient returns a client for the CustomerContact from the given config.
func NewCustomerContactClient(c config) *CustomerContactClient {
	return &CustomerContactClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `customercontact.Hooks(f(g(h())))`.
func (c *CustomerContactClient) Use(hooks ...Hook) {
	c.hooks.CustomerContact = append(c.hooks.CustomerContact, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `customercontact.Intercept(f(g(h())))`.
func (c *CustomerContactClient) Intercept(interceptors ...Interceptor) {
	c.inters.CustomerContact = append(c.inters.CustomerContact, interceptors...)
}

// Create returns a builder for creating a CustomerContact entity.
func (c *CustomerContactClient) Create() *CustomerContactCreate {
	mutation := newCustomerContactMutation(c.config, OpCreate)
	return &CustomerContactCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of CustomerContact entities.
func (c *CustomerContactClient) CreateBulk(builders ...*CustomerContactCreate) *CustomerContactCreateBulk {
	return &CustomerContactCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *CustomerContactClient) MapCreateBulk(slice any, setFunc func(*CustomerContactCreate, int)) *CustomerContactCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &CustomerContactCreateBulk{err: fmt.Errorf("calling to CustomerContactClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*CustomerContactCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &CustomerContactCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for CustomerContact.
func (c *CustomerContactClient) Update() *CustomerContactUpdate {
	mutation := newCustomerContactMutation(c.config, OpUpdate)
	return &CustomerContactUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *CustomerContactClient) UpdateOne(cc *CustomerContact) *CustomerContactUpdateOne {
	mutation := newCustomerContactMutation(c.config, OpUpdateOne, withCustomerContact(cc))
	return &CustomerContactUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *CustomerContactClient) UpdateOneID(id int) *CustomerContactUpdateOne {
	mutation := newCustomerContactMutation(c.config, OpUpdateOne, withCustomerContactID(id))
	return &CustomerContactUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for CustomerContact.
func (c *CustomerContactClient) Delete() *CustomerContactDelete {
	mutation := newCustomerContactMutation(c.config, OpDelete)
	return &CustomerContactDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *CustomerContactClient) DeleteOne(cc *CustomerContact) *CustomerContactDeleteOne {
	return c.DeleteOneID(cc.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *CustomerContactClient) DeleteOneID(id int) *CustomerContactDeleteOne {
	builder := c.Delete().Where(customercontact.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &CustomerContactDeleteOne{builder}
}

// Query returns a query builder for CustomerContact.
func (c *CustomerContactClient) Query() *CustomerContactQuery {
	return &CustomerContactQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeCustomerContact},
		inters: c.Interceptors(),
	}
}

// Get returns a CustomerContact entity by its id.
func (c *CustomerContactClient) Get(ctx context.Context, id int) (*CustomerContact, error) {
	return c.Query().Where(customercontact.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *CustomerContactClient) GetX(ctx context.Context, id int) *CustomerContact {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryBooking queries the booking edge of a CustomerContact.
func (c *CustomerContactClient) QueryBooking(cc *CustomerContact) *BookingQuery {
	query := (&BookingClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := cc.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(customercontact.Table, customercontact.FieldID, id),
			sqlgraph.To(booking.Table, booking.FieldID),
			sqlgraph.Edge(sqlgraph.O2O, true, customercontact.BookingTable, customercontact.BookingColumn),
		)
		fromV = sqlgraph.Neighbors(cc.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *CustomerContactClient) Hooks() []Hook {
	return c.hooks.CustomerContact
}

// Interceptors returns the client interceptors.
func (c *CustomerContactClient) Interceptors() []Interceptor {
	return c.inters.CustomerContact
}

func (c *CustomerContactClient) mutate(ctx context.Context, m *CustomerContactMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&CustomerContactCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&CustomerContactUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&CustomerContactUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&CustomerContactDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown CustomerContact mutation op: %q", m.Op())
	}
}

// CustomerLuggageClient is a client for the CustomerLuggage schema.
type CustomerLuggageClient struct {
	config
}

// NewCustomerLuggageClient returns a client for the CustomerLuggage from the given config.
func NewCustomerLuggageClient(c config) *CustomerLuggageClient {
	return &CustomerLuggageClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `customerluggage.Hooks(f(g(h())))`.
func (c *CustomerLuggageClient) Use(hooks ...Hook) {
	c.hooks.CustomerLuggage = append(c.hooks.CustomerLuggage, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `customerluggage.Intercept(f(g(h())))`.
func (c *CustomerLuggageClient) Intercept(interceptors ...Interceptor) {
	c.inters.CustomerLuggage = append(c.inters.CustomerLuggage, interceptors...)
}

// Create returns a builder for creating a CustomerLuggage entity.
func (c *CustomerLuggageClient) Create() *CustomerLuggageCreate {
	mutation := newCustomerLuggageMutation(c.config, OpCreate)
	return &CustomerLuggageCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of CustomerLuggage entities.
func (c *CustomerLuggageClient) CreateBulk(builders ...*CustomerLuggageCreate) *CustomerLuggageCreateBulk {
	return &CustomerLuggageCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *CustomerLuggageClient) MapCreateBulk(slice any, setFunc func(*CustomerLuggageCreate, int)) *CustomerLuggageCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &CustomerLuggageCreateBulk{err: fmt.Errorf("calling to CustomerLuggageClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*CustomerLuggageCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &CustomerLuggageCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for CustomerLuggage.
func (c *CustomerLuggageClient) Update() *CustomerLuggageUpdate {
	mutation := newCustomerLuggageMutation(c.config, OpUpdate)
	return &CustomerLuggageUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *CustomerLuggageClient) UpdateOne(cl *CustomerLuggage) *CustomerLuggageUpdateOne {
	mutation := newCustomerLuggageMutation(c.config, OpUpdateOne, withCustomerLuggage(cl))
	return &CustomerLuggageUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *CustomerLuggageClient) UpdateOneID(id int) *CustomerLuggageUpdateOne {
	mutation := newCustomerLuggageMutation(c.config, OpUpdateOne, withCustomerLuggageID(id))
	return &CustomerLuggageUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for CustomerLuggage.
func (c *CustomerLuggageClient) Delete() *CustomerLuggageDelete {
	mutation := newCustomerLuggageMutation(c.config, OpDelete)
	return &CustomerLuggageDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *CustomerLuggageClient) DeleteOne(cl *CustomerLuggage) *CustomerLuggageDeleteOne {
	return c.DeleteOneID(cl.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *CustomerLuggageClient) DeleteOneID(id int) *CustomerLuggageDeleteOne {
	builder := c.Delete().Where(customerluggage.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &CustomerLuggageDeleteOne{builder}
}

// Query returns a query builder for CustomerLuggage.
func (c *CustomerLuggageClient) Query() *CustomerLuggageQuery {
	return &CustomerLuggageQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeCustomerLuggage},
		inters: c.Interceptors(),
	}
}

// Get returns a CustomerLuggage entity by its id.
func (c *CustomerLuggageClient) Get(ctx context.Context, id int) (*CustomerLuggage, error) {
	return c.Query().Where(customerluggage.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *CustomerLuggageClient) GetX(ctx context.Context, id int) *CustomerLuggage {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryBooking queries the booking edge of a CustomerLuggage.
func (c *CustomerLuggageClient) QueryBooking(cl *CustomerLuggage) *BookingQuery {
	query := (&BookingClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := cl.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(customerluggage.Table, customerluggage.FieldID, id),
			sqlgraph.To(booking.Table, booking.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, customerluggage.BookingTable, customerluggage.BookingColumn),
		)
		fromV = sqlgraph.Neighbors(cl.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *CustomerLuggageClient) Hooks() []Hook {
	return c.hooks.CustomerLuggage
}

// Interceptors returns the client interceptors.
func (c *CustomerLuggageClient) Interceptors() []Interceptor {
	return c.inters.CustomerLuggage
}

func (c *CustomerLuggageClient) mutate(ctx context.Context, m *CustomerLuggageMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&CustomerLuggageCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&CustomerLuggageUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&CustomerLuggageUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&CustomerLuggageDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown CustomerLuggage mutation op: %q", m.Op())
	}
}

// IncidentClient is a client for the Incident schema.
type IncidentClient struct {
	config
}

// NewIncidentClient returns a client for the Incident from the given config.
func NewIncidentClient(c config) *IncidentClient {
	return &IncidentClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `incident.Hooks(f(g(h())))`.
func (c *IncidentClient) Use(hooks ...Hook) {
	c.hooks.Incident = append(c.hooks.Incident, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `incident.Intercept(f(g(h())))`.
func (c *IncidentClient) Intercept(interceptors ...Interceptor) {
	c.inters.Incident = append(c.inters.Incident, interceptors...)
}

// Create returns a builder for creating a Incident entity.
func (c *IncidentClient) Create() *IncidentCreate {
	mutation := newIncidentMutation(c.config, OpCreate)
	return &IncidentCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Incident entities.
func (c *IncidentClient) CreateBulk(builders ...*IncidentCreate) *IncidentCreateBulk {
	return &IncidentCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *IncidentClient) MapCreateBulk(slice any, setFunc func(*IncidentCreate, int)) *IncidentCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &IncidentCreateBulk{err: fmt.Errorf("calling to IncidentClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*IncidentCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &IncidentCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Incident.
func (c *IncidentClient) Update() *IncidentUpdate {
	mutation := newIncidentMutation(c.config, OpUpdate)
	return &IncidentUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *IncidentClient) UpdateOne(i *Incident) *IncidentUpdateOne {
	mutation := newIncidentMutation(c.config, OpUpdateOne, withIncident(i))
	return &IncidentUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *IncidentClient) UpdateOneID(id int) *IncidentUpdateOne {
	mutation := newIncidentMutation(c.config, OpUpdateOne, withIncidentID(id))
	return &IncidentUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Incident.
func (c *IncidentClient) Delete() *IncidentDelete {
	mutation := newIncidentMutation(c.config, OpDelete)
	return &IncidentDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *IncidentClient) DeleteOne(i *Incident) *IncidentDeleteOne {
	return c.DeleteOneID(i.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *IncidentClient) DeleteOneID(id int) *IncidentDeleteOne {
	builder := c.Delete().Where(incident.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &IncidentDeleteOne{builder}
}

// Query returns a query builder for Incident.
func (c *IncidentClient) Query() *IncidentQuery {
	return &IncidentQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeIncident},
		inters: c.Interceptors(),
	}
}

// Get returns a Incident entity by its id.
func (c *IncidentClient) Get(ctx context.Context, id int) (*Incident, error) {
	return c.Query().Where(incident.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *IncidentClient) GetX(ctx context.Context, id int) *Incident {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryImages queries the images edge of a Incident.
func (c *IncidentClient) QueryImages(i *Incident) *IncidentImageQuery {
	query := (&IncidentImageClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := i.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(incident.Table, incident.FieldID, id),
			sqlgraph.To(incidentimage.Table, incidentimage.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, incident.ImagesTable, incident.ImagesColumn),
		)
		fromV = sqlgraph.Neighbors(i.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryTrip queries the trip edge of a Incident.
func (c *IncidentClient) QueryTrip(i *Incident) *TripQuery {
	query := (&TripClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := i.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(incident.Table, incident.FieldID, id),
			sqlgraph.To(trip.Table, trip.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, incident.TripTable, incident.TripColumn),
		)
		fromV = sqlgraph.Neighbors(i.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryCompany queries the company edge of a Incident.
func (c *IncidentClient) QueryCompany(i *Incident) *CompanyQuery {
	query := (&CompanyClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := i.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(incident.Table, incident.FieldID, id),
			sqlgraph.To(company.Table, company.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, incident.CompanyTable, incident.CompanyColumn),
		)
		fromV = sqlgraph.Neighbors(i.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryDriver queries the driver edge of a Incident.
func (c *IncidentClient) QueryDriver(i *Incident) *CompanyUserQuery {
	query := (&CompanyUserClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := i.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(incident.Table, incident.FieldID, id),
			sqlgraph.To(companyuser.Table, companyuser.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, incident.DriverTable, incident.DriverColumn),
		)
		fromV = sqlgraph.Neighbors(i.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *IncidentClient) Hooks() []Hook {
	return c.hooks.Incident
}

// Interceptors returns the client interceptors.
func (c *IncidentClient) Interceptors() []Interceptor {
	return c.inters.Incident
}

func (c *IncidentClient) mutate(ctx context.Context, m *IncidentMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&IncidentCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&IncidentUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&IncidentUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&IncidentDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown Incident mutation op: %q", m.Op())
	}
}

// IncidentImageClient is a client for the IncidentImage schema.
type IncidentImageClient struct {
	config
}

// NewIncidentImageClient returns a client for the IncidentImage from the given config.
func NewIncidentImageClient(c config) *IncidentImageClient {
	return &IncidentImageClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `incidentimage.Hooks(f(g(h())))`.
func (c *IncidentImageClient) Use(hooks ...Hook) {
	c.hooks.IncidentImage = append(c.hooks.IncidentImage, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `incidentimage.Intercept(f(g(h())))`.
func (c *IncidentImageClient) Intercept(interceptors ...Interceptor) {
	c.inters.IncidentImage = append(c.inters.IncidentImage, interceptors...)
}

// Create returns a builder for creating a IncidentImage entity.
func (c *IncidentImageClient) Create() *IncidentImageCreate {
	mutation := newIncidentImageMutation(c.config, OpCreate)
	return &IncidentImageCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of IncidentImage entities.
func (c *IncidentImageClient) CreateBulk(builders ...*IncidentImageCreate) *IncidentImageCreateBulk {
	return &IncidentImageCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *IncidentImageClient) MapCreateBulk(slice any, setFunc func(*IncidentImageCreate, int)) *IncidentImageCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &IncidentImageCreateBulk{err: fmt.Errorf("calling to IncidentImageClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*IncidentImageCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &IncidentImageCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for IncidentImage.
func (c *IncidentImageClient) Update() *IncidentImageUpdate {
	mutation := newIncidentImageMutation(c.config, OpUpdate)
	return &IncidentImageUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *IncidentImageClient) UpdateOne(ii *IncidentImage) *IncidentImageUpdateOne {
	mutation := newIncidentImageMutation(c.config, OpUpdateOne, withIncidentImage(ii))
	return &IncidentImageUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *IncidentImageClient) UpdateOneID(id int) *IncidentImageUpdateOne {
	mutation := newIncidentImageMutation(c.config, OpUpdateOne, withIncidentImageID(id))
	return &IncidentImageUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for IncidentImage.
func (c *IncidentImageClient) Delete() *IncidentImageDelete {
	mutation := newIncidentImageMutation(c.config, OpDelete)
	return &IncidentImageDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *IncidentImageClient) DeleteOne(ii *IncidentImage) *IncidentImageDeleteOne {
	return c.DeleteOneID(ii.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *IncidentImageClient) DeleteOneID(id int) *IncidentImageDeleteOne {
	builder := c.Delete().Where(incidentimage.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &IncidentImageDeleteOne{builder}
}

// Query returns a query builder for IncidentImage.
func (c *IncidentImageClient) Query() *IncidentImageQuery {
	return &IncidentImageQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeIncidentImage},
		inters: c.Interceptors(),
	}
}

// Get returns a IncidentImage entity by its id.
func (c *IncidentImageClient) Get(ctx context.Context, id int) (*IncidentImage, error) {
	return c.Query().Where(incidentimage.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *IncidentImageClient) GetX(ctx context.Context, id int) *IncidentImage {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryIncident queries the incident edge of a IncidentImage.
func (c *IncidentImageClient) QueryIncident(ii *IncidentImage) *IncidentQuery {
	query := (&IncidentClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := ii.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(incidentimage.Table, incidentimage.FieldID, id),
			sqlgraph.To(incident.Table, incident.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, incidentimage.IncidentTable, incidentimage.IncidentColumn),
		)
		fromV = sqlgraph.Neighbors(ii.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *IncidentImageClient) Hooks() []Hook {
	return c.hooks.IncidentImage
}

// Interceptors returns the client interceptors.
func (c *IncidentImageClient) Interceptors() []Interceptor {
	return c.inters.IncidentImage
}

func (c *IncidentImageClient) mutate(ctx context.Context, m *IncidentImageMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&IncidentImageCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&IncidentImageUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&IncidentImageUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&IncidentImageDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown IncidentImage mutation op: %q", m.Op())
	}
}

// NotificationClient is a client for the Notification schema.
type NotificationClient struct {
	config
}

// NewNotificationClient returns a client for the Notification from the given config.
func NewNotificationClient(c config) *NotificationClient {
	return &NotificationClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `notification.Hooks(f(g(h())))`.
func (c *NotificationClient) Use(hooks ...Hook) {
	c.hooks.Notification = append(c.hooks.Notification, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `notification.Intercept(f(g(h())))`.
func (c *NotificationClient) Intercept(interceptors ...Interceptor) {
	c.inters.Notification = append(c.inters.Notification, interceptors...)
}

// Create returns a builder for creating a Notification entity.
func (c *NotificationClient) Create() *NotificationCreate {
	mutation := newNotificationMutation(c.config, OpCreate)
	return &NotificationCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Notification entities.
func (c *NotificationClient) CreateBulk(builders ...*NotificationCreate) *NotificationCreateBulk {
	return &NotificationCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *NotificationClient) MapCreateBulk(slice any, setFunc func(*NotificationCreate, int)) *NotificationCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &NotificationCreateBulk{err: fmt.Errorf("calling to NotificationClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*NotificationCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &NotificationCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Notification.
func (c *NotificationClient) Update() *NotificationUpdate {
	mutation := newNotificationMutation(c.config, OpUpdate)
	return &NotificationUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *NotificationClient) UpdateOne(n *Notification) *NotificationUpdateOne {
	mutation := newNotificationMutation(c.config, OpUpdateOne, withNotification(n))
	return &NotificationUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *NotificationClient) UpdateOneID(id int) *NotificationUpdateOne {
	mutation := newNotificationMutation(c.config, OpUpdateOne, withNotificationID(id))
	return &NotificationUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Notification.
func (c *NotificationClient) Delete() *NotificationDelete {
	mutation := newNotificationMutation(c.config, OpDelete)
	return &NotificationDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *NotificationClient) DeleteOne(n *Notification) *NotificationDeleteOne {
	return c.DeleteOneID(n.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *NotificationClient) DeleteOneID(id int) *NotificationDeleteOne {
	builder := c.Delete().Where(notification.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &NotificationDeleteOne{builder}
}

// Query returns a query builder for Notification.
func (c *NotificationClient) Query() *NotificationQuery {
	return &NotificationQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeNotification},
		inters: c.Interceptors(),
	}
}

// Get returns a Notification entity by its id.
func (c *NotificationClient) Get(ctx context.Context, id int) (*Notification, error) {
	return c.Query().Where(notification.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *NotificationClient) GetX(ctx context.Context, id int) *Notification {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryBookibusUser queries the bookibus_user edge of a Notification.
func (c *NotificationClient) QueryBookibusUser(n *Notification) *BookibusUserQuery {
	query := (&BookibusUserClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := n.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(notification.Table, notification.FieldID, id),
			sqlgraph.To(bookibususer.Table, bookibususer.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, true, notification.BookibusUserTable, notification.BookibusUserPrimaryKey...),
		)
		fromV = sqlgraph.Neighbors(n.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryCompanyUser queries the company_user edge of a Notification.
func (c *NotificationClient) QueryCompanyUser(n *Notification) *CompanyUserQuery {
	query := (&CompanyUserClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := n.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(notification.Table, notification.FieldID, id),
			sqlgraph.To(companyuser.Table, companyuser.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, true, notification.CompanyUserTable, notification.CompanyUserPrimaryKey...),
		)
		fromV = sqlgraph.Neighbors(n.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryCustomer queries the customer edge of a Notification.
func (c *NotificationClient) QueryCustomer(n *Notification) *CustomerQuery {
	query := (&CustomerClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := n.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(notification.Table, notification.FieldID, id),
			sqlgraph.To(customer.Table, customer.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, true, notification.CustomerTable, notification.CustomerPrimaryKey...),
		)
		fromV = sqlgraph.Neighbors(n.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryCompany queries the company edge of a Notification.
func (c *NotificationClient) QueryCompany(n *Notification) *CompanyQuery {
	query := (&CompanyClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := n.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(notification.Table, notification.FieldID, id),
			sqlgraph.To(company.Table, company.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, notification.CompanyTable, notification.CompanyColumn),
		)
		fromV = sqlgraph.Neighbors(n.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *NotificationClient) Hooks() []Hook {
	return c.hooks.Notification
}

// Interceptors returns the client interceptors.
func (c *NotificationClient) Interceptors() []Interceptor {
	return c.inters.Notification
}

func (c *NotificationClient) mutate(ctx context.Context, m *NotificationMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&NotificationCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&NotificationUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&NotificationUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&NotificationDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown Notification mutation op: %q", m.Op())
	}
}

// ParcelClient is a client for the Parcel schema.
type ParcelClient struct {
	config
}

// NewParcelClient returns a client for the Parcel from the given config.
func NewParcelClient(c config) *ParcelClient {
	return &ParcelClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `parcel.Hooks(f(g(h())))`.
func (c *ParcelClient) Use(hooks ...Hook) {
	c.hooks.Parcel = append(c.hooks.Parcel, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `parcel.Intercept(f(g(h())))`.
func (c *ParcelClient) Intercept(interceptors ...Interceptor) {
	c.inters.Parcel = append(c.inters.Parcel, interceptors...)
}

// Create returns a builder for creating a Parcel entity.
func (c *ParcelClient) Create() *ParcelCreate {
	mutation := newParcelMutation(c.config, OpCreate)
	return &ParcelCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Parcel entities.
func (c *ParcelClient) CreateBulk(builders ...*ParcelCreate) *ParcelCreateBulk {
	return &ParcelCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *ParcelClient) MapCreateBulk(slice any, setFunc func(*ParcelCreate, int)) *ParcelCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &ParcelCreateBulk{err: fmt.Errorf("calling to ParcelClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*ParcelCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &ParcelCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Parcel.
func (c *ParcelClient) Update() *ParcelUpdate {
	mutation := newParcelMutation(c.config, OpUpdate)
	return &ParcelUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *ParcelClient) UpdateOne(pa *Parcel) *ParcelUpdateOne {
	mutation := newParcelMutation(c.config, OpUpdateOne, withParcel(pa))
	return &ParcelUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *ParcelClient) UpdateOneID(id int) *ParcelUpdateOne {
	mutation := newParcelMutation(c.config, OpUpdateOne, withParcelID(id))
	return &ParcelUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Parcel.
func (c *ParcelClient) Delete() *ParcelDelete {
	mutation := newParcelMutation(c.config, OpDelete)
	return &ParcelDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *ParcelClient) DeleteOne(pa *Parcel) *ParcelDeleteOne {
	return c.DeleteOneID(pa.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *ParcelClient) DeleteOneID(id int) *ParcelDeleteOne {
	builder := c.Delete().Where(parcel.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &ParcelDeleteOne{builder}
}

// Query returns a query builder for Parcel.
func (c *ParcelClient) Query() *ParcelQuery {
	return &ParcelQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeParcel},
		inters: c.Interceptors(),
	}
}

// Get returns a Parcel entity by its id.
func (c *ParcelClient) Get(ctx context.Context, id int) (*Parcel, error) {
	return c.Query().Where(parcel.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *ParcelClient) GetX(ctx context.Context, id int) *Parcel {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryImages queries the images edge of a Parcel.
func (c *ParcelClient) QueryImages(pa *Parcel) *ParcelImageQuery {
	query := (&ParcelImageClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := pa.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(parcel.Table, parcel.FieldID, id),
			sqlgraph.To(parcelimage.Table, parcelimage.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, parcel.ImagesTable, parcel.ImagesColumn),
		)
		fromV = sqlgraph.Neighbors(pa.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryTrip queries the trip edge of a Parcel.
func (c *ParcelClient) QueryTrip(pa *Parcel) *TripQuery {
	query := (&TripClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := pa.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(parcel.Table, parcel.FieldID, id),
			sqlgraph.To(trip.Table, trip.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, parcel.TripTable, parcel.TripColumn),
		)
		fromV = sqlgraph.Neighbors(pa.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryCompany queries the company edge of a Parcel.
func (c *ParcelClient) QueryCompany(pa *Parcel) *CompanyQuery {
	query := (&CompanyClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := pa.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(parcel.Table, parcel.FieldID, id),
			sqlgraph.To(company.Table, company.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, parcel.CompanyTable, parcel.CompanyColumn),
		)
		fromV = sqlgraph.Neighbors(pa.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryDriver queries the driver edge of a Parcel.
func (c *ParcelClient) QueryDriver(pa *Parcel) *CompanyUserQuery {
	query := (&CompanyUserClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := pa.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(parcel.Table, parcel.FieldID, id),
			sqlgraph.To(companyuser.Table, companyuser.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, parcel.DriverTable, parcel.DriverColumn),
		)
		fromV = sqlgraph.Neighbors(pa.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *ParcelClient) Hooks() []Hook {
	return c.hooks.Parcel
}

// Interceptors returns the client interceptors.
func (c *ParcelClient) Interceptors() []Interceptor {
	return c.inters.Parcel
}

func (c *ParcelClient) mutate(ctx context.Context, m *ParcelMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&ParcelCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&ParcelUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&ParcelUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&ParcelDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown Parcel mutation op: %q", m.Op())
	}
}

// ParcelImageClient is a client for the ParcelImage schema.
type ParcelImageClient struct {
	config
}

// NewParcelImageClient returns a client for the ParcelImage from the given config.
func NewParcelImageClient(c config) *ParcelImageClient {
	return &ParcelImageClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `parcelimage.Hooks(f(g(h())))`.
func (c *ParcelImageClient) Use(hooks ...Hook) {
	c.hooks.ParcelImage = append(c.hooks.ParcelImage, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `parcelimage.Intercept(f(g(h())))`.
func (c *ParcelImageClient) Intercept(interceptors ...Interceptor) {
	c.inters.ParcelImage = append(c.inters.ParcelImage, interceptors...)
}

// Create returns a builder for creating a ParcelImage entity.
func (c *ParcelImageClient) Create() *ParcelImageCreate {
	mutation := newParcelImageMutation(c.config, OpCreate)
	return &ParcelImageCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of ParcelImage entities.
func (c *ParcelImageClient) CreateBulk(builders ...*ParcelImageCreate) *ParcelImageCreateBulk {
	return &ParcelImageCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *ParcelImageClient) MapCreateBulk(slice any, setFunc func(*ParcelImageCreate, int)) *ParcelImageCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &ParcelImageCreateBulk{err: fmt.Errorf("calling to ParcelImageClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*ParcelImageCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &ParcelImageCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for ParcelImage.
func (c *ParcelImageClient) Update() *ParcelImageUpdate {
	mutation := newParcelImageMutation(c.config, OpUpdate)
	return &ParcelImageUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *ParcelImageClient) UpdateOne(pi *ParcelImage) *ParcelImageUpdateOne {
	mutation := newParcelImageMutation(c.config, OpUpdateOne, withParcelImage(pi))
	return &ParcelImageUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *ParcelImageClient) UpdateOneID(id int) *ParcelImageUpdateOne {
	mutation := newParcelImageMutation(c.config, OpUpdateOne, withParcelImageID(id))
	return &ParcelImageUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for ParcelImage.
func (c *ParcelImageClient) Delete() *ParcelImageDelete {
	mutation := newParcelImageMutation(c.config, OpDelete)
	return &ParcelImageDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *ParcelImageClient) DeleteOne(pi *ParcelImage) *ParcelImageDeleteOne {
	return c.DeleteOneID(pi.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *ParcelImageClient) DeleteOneID(id int) *ParcelImageDeleteOne {
	builder := c.Delete().Where(parcelimage.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &ParcelImageDeleteOne{builder}
}

// Query returns a query builder for ParcelImage.
func (c *ParcelImageClient) Query() *ParcelImageQuery {
	return &ParcelImageQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeParcelImage},
		inters: c.Interceptors(),
	}
}

// Get returns a ParcelImage entity by its id.
func (c *ParcelImageClient) Get(ctx context.Context, id int) (*ParcelImage, error) {
	return c.Query().Where(parcelimage.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *ParcelImageClient) GetX(ctx context.Context, id int) *ParcelImage {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryParcel queries the parcel edge of a ParcelImage.
func (c *ParcelImageClient) QueryParcel(pi *ParcelImage) *ParcelQuery {
	query := (&ParcelClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := pi.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(parcelimage.Table, parcelimage.FieldID, id),
			sqlgraph.To(parcel.Table, parcel.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, parcelimage.ParcelTable, parcelimage.ParcelColumn),
		)
		fromV = sqlgraph.Neighbors(pi.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *ParcelImageClient) Hooks() []Hook {
	return c.hooks.ParcelImage
}

// Interceptors returns the client interceptors.
func (c *ParcelImageClient) Interceptors() []Interceptor {
	return c.inters.ParcelImage
}

func (c *ParcelImageClient) mutate(ctx context.Context, m *ParcelImageMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&ParcelImageCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&ParcelImageUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&ParcelImageUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&ParcelImageDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown ParcelImage mutation op: %q", m.Op())
	}
}

// PassengerClient is a client for the Passenger schema.
type PassengerClient struct {
	config
}

// NewPassengerClient returns a client for the Passenger from the given config.
func NewPassengerClient(c config) *PassengerClient {
	return &PassengerClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `passenger.Hooks(f(g(h())))`.
func (c *PassengerClient) Use(hooks ...Hook) {
	c.hooks.Passenger = append(c.hooks.Passenger, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `passenger.Intercept(f(g(h())))`.
func (c *PassengerClient) Intercept(interceptors ...Interceptor) {
	c.inters.Passenger = append(c.inters.Passenger, interceptors...)
}

// Create returns a builder for creating a Passenger entity.
func (c *PassengerClient) Create() *PassengerCreate {
	mutation := newPassengerMutation(c.config, OpCreate)
	return &PassengerCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Passenger entities.
func (c *PassengerClient) CreateBulk(builders ...*PassengerCreate) *PassengerCreateBulk {
	return &PassengerCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *PassengerClient) MapCreateBulk(slice any, setFunc func(*PassengerCreate, int)) *PassengerCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &PassengerCreateBulk{err: fmt.Errorf("calling to PassengerClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*PassengerCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &PassengerCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Passenger.
func (c *PassengerClient) Update() *PassengerUpdate {
	mutation := newPassengerMutation(c.config, OpUpdate)
	return &PassengerUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *PassengerClient) UpdateOne(pa *Passenger) *PassengerUpdateOne {
	mutation := newPassengerMutation(c.config, OpUpdateOne, withPassenger(pa))
	return &PassengerUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *PassengerClient) UpdateOneID(id int) *PassengerUpdateOne {
	mutation := newPassengerMutation(c.config, OpUpdateOne, withPassengerID(id))
	return &PassengerUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Passenger.
func (c *PassengerClient) Delete() *PassengerDelete {
	mutation := newPassengerMutation(c.config, OpDelete)
	return &PassengerDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *PassengerClient) DeleteOne(pa *Passenger) *PassengerDeleteOne {
	return c.DeleteOneID(pa.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *PassengerClient) DeleteOneID(id int) *PassengerDeleteOne {
	builder := c.Delete().Where(passenger.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &PassengerDeleteOne{builder}
}

// Query returns a query builder for Passenger.
func (c *PassengerClient) Query() *PassengerQuery {
	return &PassengerQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypePassenger},
		inters: c.Interceptors(),
	}
}

// Get returns a Passenger entity by its id.
func (c *PassengerClient) Get(ctx context.Context, id int) (*Passenger, error) {
	return c.Query().Where(passenger.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *PassengerClient) GetX(ctx context.Context, id int) *Passenger {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryBooking queries the booking edge of a Passenger.
func (c *PassengerClient) QueryBooking(pa *Passenger) *BookingQuery {
	query := (&BookingClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := pa.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(passenger.Table, passenger.FieldID, id),
			sqlgraph.To(booking.Table, booking.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, passenger.BookingTable, passenger.BookingColumn),
		)
		fromV = sqlgraph.Neighbors(pa.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *PassengerClient) Hooks() []Hook {
	return c.hooks.Passenger
}

// Interceptors returns the client interceptors.
func (c *PassengerClient) Interceptors() []Interceptor {
	return c.inters.Passenger
}

func (c *PassengerClient) mutate(ctx context.Context, m *PassengerMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&PassengerCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&PassengerUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&PassengerUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&PassengerDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown Passenger mutation op: %q", m.Op())
	}
}

// RouteClient is a client for the Route schema.
type RouteClient struct {
	config
}

// NewRouteClient returns a client for the Route from the given config.
func NewRouteClient(c config) *RouteClient {
	return &RouteClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `route.Hooks(f(g(h())))`.
func (c *RouteClient) Use(hooks ...Hook) {
	c.hooks.Route = append(c.hooks.Route, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `route.Intercept(f(g(h())))`.
func (c *RouteClient) Intercept(interceptors ...Interceptor) {
	c.inters.Route = append(c.inters.Route, interceptors...)
}

// Create returns a builder for creating a Route entity.
func (c *RouteClient) Create() *RouteCreate {
	mutation := newRouteMutation(c.config, OpCreate)
	return &RouteCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Route entities.
func (c *RouteClient) CreateBulk(builders ...*RouteCreate) *RouteCreateBulk {
	return &RouteCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *RouteClient) MapCreateBulk(slice any, setFunc func(*RouteCreate, int)) *RouteCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &RouteCreateBulk{err: fmt.Errorf("calling to RouteClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*RouteCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &RouteCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Route.
func (c *RouteClient) Update() *RouteUpdate {
	mutation := newRouteMutation(c.config, OpUpdate)
	return &RouteUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *RouteClient) UpdateOne(r *Route) *RouteUpdateOne {
	mutation := newRouteMutation(c.config, OpUpdateOne, withRoute(r))
	return &RouteUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *RouteClient) UpdateOneID(id int) *RouteUpdateOne {
	mutation := newRouteMutation(c.config, OpUpdateOne, withRouteID(id))
	return &RouteUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Route.
func (c *RouteClient) Delete() *RouteDelete {
	mutation := newRouteMutation(c.config, OpDelete)
	return &RouteDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *RouteClient) DeleteOne(r *Route) *RouteDeleteOne {
	return c.DeleteOneID(r.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *RouteClient) DeleteOneID(id int) *RouteDeleteOne {
	builder := c.Delete().Where(route.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &RouteDeleteOne{builder}
}

// Query returns a query builder for Route.
func (c *RouteClient) Query() *RouteQuery {
	return &RouteQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeRoute},
		inters: c.Interceptors(),
	}
}

// Get returns a Route entity by its id.
func (c *RouteClient) Get(ctx context.Context, id int) (*Route, error) {
	return c.Query().Where(route.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *RouteClient) GetX(ctx context.Context, id int) *Route {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryCompany queries the company edge of a Route.
func (c *RouteClient) QueryCompany(r *Route) *CompanyQuery {
	query := (&CompanyClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := r.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(route.Table, route.FieldID, id),
			sqlgraph.To(company.Table, company.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, route.CompanyTable, route.CompanyColumn),
		)
		fromV = sqlgraph.Neighbors(r.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryStops queries the stops edge of a Route.
func (c *RouteClient) QueryStops(r *Route) *RouteStopQuery {
	query := (&RouteStopClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := r.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(route.Table, route.FieldID, id),
			sqlgraph.To(routestop.Table, routestop.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, route.StopsTable, route.StopsColumn),
		)
		fromV = sqlgraph.Neighbors(r.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryTrips queries the trips edge of a Route.
func (c *RouteClient) QueryTrips(r *Route) *TripQuery {
	query := (&TripClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := r.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(route.Table, route.FieldID, id),
			sqlgraph.To(trip.Table, trip.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, route.TripsTable, route.TripsColumn),
		)
		fromV = sqlgraph.Neighbors(r.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *RouteClient) Hooks() []Hook {
	return c.hooks.Route
}

// Interceptors returns the client interceptors.
func (c *RouteClient) Interceptors() []Interceptor {
	return c.inters.Route
}

func (c *RouteClient) mutate(ctx context.Context, m *RouteMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&RouteCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&RouteUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&RouteUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&RouteDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown Route mutation op: %q", m.Op())
	}
}

// RouteStopClient is a client for the RouteStop schema.
type RouteStopClient struct {
	config
}

// NewRouteStopClient returns a client for the RouteStop from the given config.
func NewRouteStopClient(c config) *RouteStopClient {
	return &RouteStopClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `routestop.Hooks(f(g(h())))`.
func (c *RouteStopClient) Use(hooks ...Hook) {
	c.hooks.RouteStop = append(c.hooks.RouteStop, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `routestop.Intercept(f(g(h())))`.
func (c *RouteStopClient) Intercept(interceptors ...Interceptor) {
	c.inters.RouteStop = append(c.inters.RouteStop, interceptors...)
}

// Create returns a builder for creating a RouteStop entity.
func (c *RouteStopClient) Create() *RouteStopCreate {
	mutation := newRouteStopMutation(c.config, OpCreate)
	return &RouteStopCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of RouteStop entities.
func (c *RouteStopClient) CreateBulk(builders ...*RouteStopCreate) *RouteStopCreateBulk {
	return &RouteStopCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *RouteStopClient) MapCreateBulk(slice any, setFunc func(*RouteStopCreate, int)) *RouteStopCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &RouteStopCreateBulk{err: fmt.Errorf("calling to RouteStopClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*RouteStopCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &RouteStopCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for RouteStop.
func (c *RouteStopClient) Update() *RouteStopUpdate {
	mutation := newRouteStopMutation(c.config, OpUpdate)
	return &RouteStopUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *RouteStopClient) UpdateOne(rs *RouteStop) *RouteStopUpdateOne {
	mutation := newRouteStopMutation(c.config, OpUpdateOne, withRouteStop(rs))
	return &RouteStopUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *RouteStopClient) UpdateOneID(id int) *RouteStopUpdateOne {
	mutation := newRouteStopMutation(c.config, OpUpdateOne, withRouteStopID(id))
	return &RouteStopUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for RouteStop.
func (c *RouteStopClient) Delete() *RouteStopDelete {
	mutation := newRouteStopMutation(c.config, OpDelete)
	return &RouteStopDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *RouteStopClient) DeleteOne(rs *RouteStop) *RouteStopDeleteOne {
	return c.DeleteOneID(rs.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *RouteStopClient) DeleteOneID(id int) *RouteStopDeleteOne {
	builder := c.Delete().Where(routestop.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &RouteStopDeleteOne{builder}
}

// Query returns a query builder for RouteStop.
func (c *RouteStopClient) Query() *RouteStopQuery {
	return &RouteStopQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeRouteStop},
		inters: c.Interceptors(),
	}
}

// Get returns a RouteStop entity by its id.
func (c *RouteStopClient) Get(ctx context.Context, id int) (*RouteStop, error) {
	return c.Query().Where(routestop.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *RouteStopClient) GetX(ctx context.Context, id int) *RouteStop {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryRoute queries the route edge of a RouteStop.
func (c *RouteStopClient) QueryRoute(rs *RouteStop) *RouteQuery {
	query := (&RouteClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := rs.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(routestop.Table, routestop.FieldID, id),
			sqlgraph.To(route.Table, route.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, routestop.RouteTable, routestop.RouteColumn),
		)
		fromV = sqlgraph.Neighbors(rs.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *RouteStopClient) Hooks() []Hook {
	return c.hooks.RouteStop
}

// Interceptors returns the client interceptors.
func (c *RouteStopClient) Interceptors() []Interceptor {
	return c.inters.RouteStop
}

func (c *RouteStopClient) mutate(ctx context.Context, m *RouteStopMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&RouteStopCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&RouteStopUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&RouteStopUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&RouteStopDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown RouteStop mutation op: %q", m.Op())
	}
}

// TripClient is a client for the Trip schema.
type TripClient struct {
	config
}

// NewTripClient returns a client for the Trip from the given config.
func NewTripClient(c config) *TripClient {
	return &TripClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `trip.Hooks(f(g(h())))`.
func (c *TripClient) Use(hooks ...Hook) {
	c.hooks.Trip = append(c.hooks.Trip, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `trip.Intercept(f(g(h())))`.
func (c *TripClient) Intercept(interceptors ...Interceptor) {
	c.inters.Trip = append(c.inters.Trip, interceptors...)
}

// Create returns a builder for creating a Trip entity.
func (c *TripClient) Create() *TripCreate {
	mutation := newTripMutation(c.config, OpCreate)
	return &TripCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Trip entities.
func (c *TripClient) CreateBulk(builders ...*TripCreate) *TripCreateBulk {
	return &TripCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *TripClient) MapCreateBulk(slice any, setFunc func(*TripCreate, int)) *TripCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &TripCreateBulk{err: fmt.Errorf("calling to TripClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*TripCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &TripCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Trip.
func (c *TripClient) Update() *TripUpdate {
	mutation := newTripMutation(c.config, OpUpdate)
	return &TripUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *TripClient) UpdateOne(t *Trip) *TripUpdateOne {
	mutation := newTripMutation(c.config, OpUpdateOne, withTrip(t))
	return &TripUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *TripClient) UpdateOneID(id int) *TripUpdateOne {
	mutation := newTripMutation(c.config, OpUpdateOne, withTripID(id))
	return &TripUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Trip.
func (c *TripClient) Delete() *TripDelete {
	mutation := newTripMutation(c.config, OpDelete)
	return &TripDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *TripClient) DeleteOne(t *Trip) *TripDeleteOne {
	return c.DeleteOneID(t.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *TripClient) DeleteOneID(id int) *TripDeleteOne {
	builder := c.Delete().Where(trip.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &TripDeleteOne{builder}
}

// Query returns a query builder for Trip.
func (c *TripClient) Query() *TripQuery {
	return &TripQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeTrip},
		inters: c.Interceptors(),
	}
}

// Get returns a Trip entity by its id.
func (c *TripClient) Get(ctx context.Context, id int) (*Trip, error) {
	return c.Query().Where(trip.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *TripClient) GetX(ctx context.Context, id int) *Trip {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryCompany queries the company edge of a Trip.
func (c *TripClient) QueryCompany(t *Trip) *CompanyQuery {
	query := (&CompanyClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := t.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(trip.Table, trip.FieldID, id),
			sqlgraph.To(company.Table, company.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, trip.CompanyTable, trip.CompanyColumn),
		)
		fromV = sqlgraph.Neighbors(t.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryDriver queries the driver edge of a Trip.
func (c *TripClient) QueryDriver(t *Trip) *CompanyUserQuery {
	query := (&CompanyUserClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := t.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(trip.Table, trip.FieldID, id),
			sqlgraph.To(companyuser.Table, companyuser.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, trip.DriverTable, trip.DriverColumn),
		)
		fromV = sqlgraph.Neighbors(t.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryVehicle queries the vehicle edge of a Trip.
func (c *TripClient) QueryVehicle(t *Trip) *VehicleQuery {
	query := (&VehicleClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := t.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(trip.Table, trip.FieldID, id),
			sqlgraph.To(vehicle.Table, vehicle.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, trip.VehicleTable, trip.VehicleColumn),
		)
		fromV = sqlgraph.Neighbors(t.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryRoute queries the route edge of a Trip.
func (c *TripClient) QueryRoute(t *Trip) *RouteQuery {
	query := (&RouteClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := t.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(trip.Table, trip.FieldID, id),
			sqlgraph.To(route.Table, route.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, trip.RouteTable, trip.RouteColumn),
		)
		fromV = sqlgraph.Neighbors(t.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryBookings queries the bookings edge of a Trip.
func (c *TripClient) QueryBookings(t *Trip) *BookingQuery {
	query := (&BookingClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := t.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(trip.Table, trip.FieldID, id),
			sqlgraph.To(booking.Table, booking.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, trip.BookingsTable, trip.BookingsColumn),
		)
		fromV = sqlgraph.Neighbors(t.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryIncidents queries the incidents edge of a Trip.
func (c *TripClient) QueryIncidents(t *Trip) *IncidentQuery {
	query := (&IncidentClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := t.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(trip.Table, trip.FieldID, id),
			sqlgraph.To(incident.Table, incident.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, trip.IncidentsTable, trip.IncidentsColumn),
		)
		fromV = sqlgraph.Neighbors(t.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryParcels queries the parcels edge of a Trip.
func (c *TripClient) QueryParcels(t *Trip) *ParcelQuery {
	query := (&ParcelClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := t.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(trip.Table, trip.FieldID, id),
			sqlgraph.To(parcel.Table, parcel.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, trip.ParcelsTable, trip.ParcelsColumn),
		)
		fromV = sqlgraph.Neighbors(t.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *TripClient) Hooks() []Hook {
	return c.hooks.Trip
}

// Interceptors returns the client interceptors.
func (c *TripClient) Interceptors() []Interceptor {
	return c.inters.Trip
}

func (c *TripClient) mutate(ctx context.Context, m *TripMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&TripCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&TripUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&TripUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&TripDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown Trip mutation op: %q", m.Op())
	}
}

// UserClient is a client for the User schema.
type UserClient struct {
	config
}

// NewUserClient returns a client for the User from the given config.
func NewUserClient(c config) *UserClient {
	return &UserClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `user.Hooks(f(g(h())))`.
func (c *UserClient) Use(hooks ...Hook) {
	c.hooks.User = append(c.hooks.User, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `user.Intercept(f(g(h())))`.
func (c *UserClient) Intercept(interceptors ...Interceptor) {
	c.inters.User = append(c.inters.User, interceptors...)
}

// Create returns a builder for creating a User entity.
func (c *UserClient) Create() *UserCreate {
	mutation := newUserMutation(c.config, OpCreate)
	return &UserCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of User entities.
func (c *UserClient) CreateBulk(builders ...*UserCreate) *UserCreateBulk {
	return &UserCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *UserClient) MapCreateBulk(slice any, setFunc func(*UserCreate, int)) *UserCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &UserCreateBulk{err: fmt.Errorf("calling to UserClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*UserCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &UserCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for User.
func (c *UserClient) Update() *UserUpdate {
	mutation := newUserMutation(c.config, OpUpdate)
	return &UserUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *UserClient) UpdateOne(u *User) *UserUpdateOne {
	mutation := newUserMutation(c.config, OpUpdateOne, withUser(u))
	return &UserUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *UserClient) UpdateOneID(id int) *UserUpdateOne {
	mutation := newUserMutation(c.config, OpUpdateOne, withUserID(id))
	return &UserUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for User.
func (c *UserClient) Delete() *UserDelete {
	mutation := newUserMutation(c.config, OpDelete)
	return &UserDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *UserClient) DeleteOne(u *User) *UserDeleteOne {
	return c.DeleteOneID(u.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *UserClient) DeleteOneID(id int) *UserDeleteOne {
	builder := c.Delete().Where(user.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &UserDeleteOne{builder}
}

// Query returns a query builder for User.
func (c *UserClient) Query() *UserQuery {
	return &UserQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeUser},
		inters: c.Interceptors(),
	}
}

// Get returns a User entity by its id.
func (c *UserClient) Get(ctx context.Context, id int) (*User, error) {
	return c.Query().Where(user.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *UserClient) GetX(ctx context.Context, id int) *User {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryBookibusUser queries the bookibus_user edge of a User.
func (c *UserClient) QueryBookibusUser(u *User) *BookibusUserQuery {
	query := (&BookibusUserClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := u.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(user.Table, user.FieldID, id),
			sqlgraph.To(bookibususer.Table, bookibususer.FieldID),
			sqlgraph.Edge(sqlgraph.O2O, true, user.BookibusUserTable, user.BookibusUserColumn),
		)
		fromV = sqlgraph.Neighbors(u.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryCompanyUser queries the company_user edge of a User.
func (c *UserClient) QueryCompanyUser(u *User) *CompanyUserQuery {
	query := (&CompanyUserClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := u.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(user.Table, user.FieldID, id),
			sqlgraph.To(companyuser.Table, companyuser.FieldID),
			sqlgraph.Edge(sqlgraph.O2O, true, user.CompanyUserTable, user.CompanyUserColumn),
		)
		fromV = sqlgraph.Neighbors(u.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryCustomer queries the customer edge of a User.
func (c *UserClient) QueryCustomer(u *User) *CustomerQuery {
	query := (&CustomerClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := u.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(user.Table, user.FieldID, id),
			sqlgraph.To(customer.Table, customer.FieldID),
			sqlgraph.Edge(sqlgraph.O2O, true, user.CustomerTable, user.CustomerColumn),
		)
		fromV = sqlgraph.Neighbors(u.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *UserClient) Hooks() []Hook {
	return c.hooks.User
}

// Interceptors returns the client interceptors.
func (c *UserClient) Interceptors() []Interceptor {
	return c.inters.User
}

func (c *UserClient) mutate(ctx context.Context, m *UserMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&UserCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&UserUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&UserUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&UserDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown User mutation op: %q", m.Op())
	}
}

// VehicleClient is a client for the Vehicle schema.
type VehicleClient struct {
	config
}

// NewVehicleClient returns a client for the Vehicle from the given config.
func NewVehicleClient(c config) *VehicleClient {
	return &VehicleClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `vehicle.Hooks(f(g(h())))`.
func (c *VehicleClient) Use(hooks ...Hook) {
	c.hooks.Vehicle = append(c.hooks.Vehicle, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `vehicle.Intercept(f(g(h())))`.
func (c *VehicleClient) Intercept(interceptors ...Interceptor) {
	c.inters.Vehicle = append(c.inters.Vehicle, interceptors...)
}

// Create returns a builder for creating a Vehicle entity.
func (c *VehicleClient) Create() *VehicleCreate {
	mutation := newVehicleMutation(c.config, OpCreate)
	return &VehicleCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Vehicle entities.
func (c *VehicleClient) CreateBulk(builders ...*VehicleCreate) *VehicleCreateBulk {
	return &VehicleCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *VehicleClient) MapCreateBulk(slice any, setFunc func(*VehicleCreate, int)) *VehicleCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &VehicleCreateBulk{err: fmt.Errorf("calling to VehicleClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*VehicleCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &VehicleCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Vehicle.
func (c *VehicleClient) Update() *VehicleUpdate {
	mutation := newVehicleMutation(c.config, OpUpdate)
	return &VehicleUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *VehicleClient) UpdateOne(v *Vehicle) *VehicleUpdateOne {
	mutation := newVehicleMutation(c.config, OpUpdateOne, withVehicle(v))
	return &VehicleUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *VehicleClient) UpdateOneID(id int) *VehicleUpdateOne {
	mutation := newVehicleMutation(c.config, OpUpdateOne, withVehicleID(id))
	return &VehicleUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Vehicle.
func (c *VehicleClient) Delete() *VehicleDelete {
	mutation := newVehicleMutation(c.config, OpDelete)
	return &VehicleDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *VehicleClient) DeleteOne(v *Vehicle) *VehicleDeleteOne {
	return c.DeleteOneID(v.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *VehicleClient) DeleteOneID(id int) *VehicleDeleteOne {
	builder := c.Delete().Where(vehicle.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &VehicleDeleteOne{builder}
}

// Query returns a query builder for Vehicle.
func (c *VehicleClient) Query() *VehicleQuery {
	return &VehicleQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeVehicle},
		inters: c.Interceptors(),
	}
}

// Get returns a Vehicle entity by its id.
func (c *VehicleClient) Get(ctx context.Context, id int) (*Vehicle, error) {
	return c.Query().Where(vehicle.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *VehicleClient) GetX(ctx context.Context, id int) *Vehicle {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryCompany queries the company edge of a Vehicle.
func (c *VehicleClient) QueryCompany(v *Vehicle) *CompanyQuery {
	query := (&CompanyClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := v.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(vehicle.Table, vehicle.FieldID, id),
			sqlgraph.To(company.Table, company.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, vehicle.CompanyTable, vehicle.CompanyColumn),
		)
		fromV = sqlgraph.Neighbors(v.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryImages queries the images edge of a Vehicle.
func (c *VehicleClient) QueryImages(v *Vehicle) *VehicleImageQuery {
	query := (&VehicleImageClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := v.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(vehicle.Table, vehicle.FieldID, id),
			sqlgraph.To(vehicleimage.Table, vehicleimage.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, vehicle.ImagesTable, vehicle.ImagesColumn),
		)
		fromV = sqlgraph.Neighbors(v.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryTrips queries the trips edge of a Vehicle.
func (c *VehicleClient) QueryTrips(v *Vehicle) *TripQuery {
	query := (&TripClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := v.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(vehicle.Table, vehicle.FieldID, id),
			sqlgraph.To(trip.Table, trip.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, vehicle.TripsTable, vehicle.TripsColumn),
		)
		fromV = sqlgraph.Neighbors(v.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *VehicleClient) Hooks() []Hook {
	return c.hooks.Vehicle
}

// Interceptors returns the client interceptors.
func (c *VehicleClient) Interceptors() []Interceptor {
	return c.inters.Vehicle
}

func (c *VehicleClient) mutate(ctx context.Context, m *VehicleMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&VehicleCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&VehicleUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&VehicleUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&VehicleDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown Vehicle mutation op: %q", m.Op())
	}
}

// VehicleImageClient is a client for the VehicleImage schema.
type VehicleImageClient struct {
	config
}

// NewVehicleImageClient returns a client for the VehicleImage from the given config.
func NewVehicleImageClient(c config) *VehicleImageClient {
	return &VehicleImageClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `vehicleimage.Hooks(f(g(h())))`.
func (c *VehicleImageClient) Use(hooks ...Hook) {
	c.hooks.VehicleImage = append(c.hooks.VehicleImage, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `vehicleimage.Intercept(f(g(h())))`.
func (c *VehicleImageClient) Intercept(interceptors ...Interceptor) {
	c.inters.VehicleImage = append(c.inters.VehicleImage, interceptors...)
}

// Create returns a builder for creating a VehicleImage entity.
func (c *VehicleImageClient) Create() *VehicleImageCreate {
	mutation := newVehicleImageMutation(c.config, OpCreate)
	return &VehicleImageCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of VehicleImage entities.
func (c *VehicleImageClient) CreateBulk(builders ...*VehicleImageCreate) *VehicleImageCreateBulk {
	return &VehicleImageCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *VehicleImageClient) MapCreateBulk(slice any, setFunc func(*VehicleImageCreate, int)) *VehicleImageCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &VehicleImageCreateBulk{err: fmt.Errorf("calling to VehicleImageClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*VehicleImageCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &VehicleImageCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for VehicleImage.
func (c *VehicleImageClient) Update() *VehicleImageUpdate {
	mutation := newVehicleImageMutation(c.config, OpUpdate)
	return &VehicleImageUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *VehicleImageClient) UpdateOne(vi *VehicleImage) *VehicleImageUpdateOne {
	mutation := newVehicleImageMutation(c.config, OpUpdateOne, withVehicleImage(vi))
	return &VehicleImageUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *VehicleImageClient) UpdateOneID(id int) *VehicleImageUpdateOne {
	mutation := newVehicleImageMutation(c.config, OpUpdateOne, withVehicleImageID(id))
	return &VehicleImageUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for VehicleImage.
func (c *VehicleImageClient) Delete() *VehicleImageDelete {
	mutation := newVehicleImageMutation(c.config, OpDelete)
	return &VehicleImageDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *VehicleImageClient) DeleteOne(vi *VehicleImage) *VehicleImageDeleteOne {
	return c.DeleteOneID(vi.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *VehicleImageClient) DeleteOneID(id int) *VehicleImageDeleteOne {
	builder := c.Delete().Where(vehicleimage.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &VehicleImageDeleteOne{builder}
}

// Query returns a query builder for VehicleImage.
func (c *VehicleImageClient) Query() *VehicleImageQuery {
	return &VehicleImageQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeVehicleImage},
		inters: c.Interceptors(),
	}
}

// Get returns a VehicleImage entity by its id.
func (c *VehicleImageClient) Get(ctx context.Context, id int) (*VehicleImage, error) {
	return c.Query().Where(vehicleimage.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *VehicleImageClient) GetX(ctx context.Context, id int) *VehicleImage {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryVehicle queries the vehicle edge of a VehicleImage.
func (c *VehicleImageClient) QueryVehicle(vi *VehicleImage) *VehicleQuery {
	query := (&VehicleClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := vi.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(vehicleimage.Table, vehicleimage.FieldID, id),
			sqlgraph.To(vehicle.Table, vehicle.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, vehicleimage.VehicleTable, vehicleimage.VehicleColumn),
		)
		fromV = sqlgraph.Neighbors(vi.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *VehicleImageClient) Hooks() []Hook {
	return c.hooks.VehicleImage
}

// Interceptors returns the client interceptors.
func (c *VehicleImageClient) Interceptors() []Interceptor {
	return c.inters.VehicleImage
}

func (c *VehicleImageClient) mutate(ctx context.Context, m *VehicleImageMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&VehicleImageCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&VehicleImageUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&VehicleImageUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&VehicleImageDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown VehicleImage mutation op: %q", m.Op())
	}
}

// hooks and interceptors per client, for fast access.
type (
	hooks struct {
		BookibusUser, Booking, Company, CompanyUser, Customer, CustomerContact,
		CustomerLuggage, Incident, IncidentImage, Notification, Parcel, ParcelImage,
		Passenger, Route, RouteStop, Trip, User, Vehicle, VehicleImage []ent.Hook
	}
	inters struct {
		BookibusUser, Booking, Company, CompanyUser, Customer, CustomerContact,
		CustomerLuggage, Incident, IncidentImage, Notification, Parcel, ParcelImage,
		Passenger, Route, RouteStop, Trip, User, Vehicle,
		VehicleImage []ent.Interceptor
	}
)
