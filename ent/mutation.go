// Code generated by ent, DO NOT EDIT.

package ent

import (
	"context"
	"errors"
	"fmt"
	"sync"
	"time"

	"entgo.io/ent"
	"entgo.io/ent/dialect/sql"
	"github.com/SeyramWood/bookibus/ent/bookibususer"
	"github.com/SeyramWood/bookibus/ent/booking"
	"github.com/SeyramWood/bookibus/ent/company"
	"github.com/SeyramWood/bookibus/ent/companyuser"
	"github.com/SeyramWood/bookibus/ent/customer"
	"github.com/SeyramWood/bookibus/ent/customercontact"
	"github.com/SeyramWood/bookibus/ent/customerluggage"
	"github.com/SeyramWood/bookibus/ent/incident"
	"github.com/SeyramWood/bookibus/ent/incidentimage"
	"github.com/SeyramWood/bookibus/ent/notification"
	"github.com/SeyramWood/bookibus/ent/parcel"
	"github.com/SeyramWood/bookibus/ent/parcelimage"
	"github.com/SeyramWood/bookibus/ent/passenger"
	"github.com/SeyramWood/bookibus/ent/predicate"
	"github.com/SeyramWood/bookibus/ent/route"
	"github.com/SeyramWood/bookibus/ent/routestop"
	"github.com/SeyramWood/bookibus/ent/schema"
	"github.com/SeyramWood/bookibus/ent/terminal"
	"github.com/SeyramWood/bookibus/ent/trip"
	"github.com/SeyramWood/bookibus/ent/user"
	"github.com/SeyramWood/bookibus/ent/vehicle"
	"github.com/SeyramWood/bookibus/ent/vehicleimage"
)

const (
	// Operation types.
	OpCreate    = ent.OpCreate
	OpDelete    = ent.OpDelete
	OpDeleteOne = ent.OpDeleteOne
	OpUpdate    = ent.OpUpdate
	OpUpdateOne = ent.OpUpdateOne

	// Node types.
	TypeBookibusUser    = "BookibusUser"
	TypeBooking         = "Booking"
	TypeCompany         = "Company"
	TypeCompanyUser     = "CompanyUser"
	TypeCustomer        = "Customer"
	TypeCustomerContact = "CustomerContact"
	TypeCustomerLuggage = "CustomerLuggage"
	TypeIncident        = "Incident"
	TypeIncidentImage   = "IncidentImage"
	TypeNotification    = "Notification"
	TypeParcel          = "Parcel"
	TypeParcelImage     = "ParcelImage"
	TypePassenger       = "Passenger"
	TypeRoute           = "Route"
	TypeRouteStop       = "RouteStop"
	TypeTerminal        = "Terminal"
	TypeTrip            = "Trip"
	TypeUser            = "User"
	TypeVehicle         = "Vehicle"
	TypeVehicleImage    = "VehicleImage"
)

// BookibusUserMutation represents an operation that mutates the BookibusUser nodes in the graph.
type BookibusUserMutation struct {
	config
	op                   Op
	typ                  string
	id                   *int
	created_at           *time.Time
	updated_at           *time.Time
	last_name            *string
	other_name           *string
	phone                *string
	other_phone          *string
	role                 *bookibususer.Role
	clearedFields        map[string]struct{}
	profile              *int
	clearedprofile       bool
	notifications        map[int]struct{}
	removednotifications map[int]struct{}
	clearednotifications bool
	done                 bool
	oldValue             func(context.Context) (*BookibusUser, error)
	predicates           []predicate.BookibusUser
}

var _ ent.Mutation = (*BookibusUserMutation)(nil)

// bookibususerOption allows management of the mutation configuration using functional options.
type bookibususerOption func(*BookibusUserMutation)

// newBookibusUserMutation creates new mutation for the BookibusUser entity.
func newBookibusUserMutation(c config, op Op, opts ...bookibususerOption) *BookibusUserMutation {
	m := &BookibusUserMutation{
		config:        c,
		op:            op,
		typ:           TypeBookibusUser,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withBookibusUserID sets the ID field of the mutation.
func withBookibusUserID(id int) bookibususerOption {
	return func(m *BookibusUserMutation) {
		var (
			err   error
			once  sync.Once
			value *BookibusUser
		)
		m.oldValue = func(ctx context.Context) (*BookibusUser, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().BookibusUser.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withBookibusUser sets the old BookibusUser of the mutation.
func withBookibusUser(node *BookibusUser) bookibususerOption {
	return func(m *BookibusUserMutation) {
		m.oldValue = func(context.Context) (*BookibusUser, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m BookibusUserMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m BookibusUserMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *BookibusUserMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *BookibusUserMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().BookibusUser.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *BookibusUserMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *BookibusUserMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the BookibusUser entity.
// If the BookibusUser object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BookibusUserMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *BookibusUserMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *BookibusUserMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *BookibusUserMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the BookibusUser entity.
// If the BookibusUser object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BookibusUserMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *BookibusUserMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetLastName sets the "last_name" field.
func (m *BookibusUserMutation) SetLastName(s string) {
	m.last_name = &s
}

// LastName returns the value of the "last_name" field in the mutation.
func (m *BookibusUserMutation) LastName() (r string, exists bool) {
	v := m.last_name
	if v == nil {
		return
	}
	return *v, true
}

// OldLastName returns the old "last_name" field's value of the BookibusUser entity.
// If the BookibusUser object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BookibusUserMutation) OldLastName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLastName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLastName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLastName: %w", err)
	}
	return oldValue.LastName, nil
}

// ResetLastName resets all changes to the "last_name" field.
func (m *BookibusUserMutation) ResetLastName() {
	m.last_name = nil
}

// SetOtherName sets the "other_name" field.
func (m *BookibusUserMutation) SetOtherName(s string) {
	m.other_name = &s
}

// OtherName returns the value of the "other_name" field in the mutation.
func (m *BookibusUserMutation) OtherName() (r string, exists bool) {
	v := m.other_name
	if v == nil {
		return
	}
	return *v, true
}

// OldOtherName returns the old "other_name" field's value of the BookibusUser entity.
// If the BookibusUser object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BookibusUserMutation) OldOtherName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOtherName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOtherName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOtherName: %w", err)
	}
	return oldValue.OtherName, nil
}

// ResetOtherName resets all changes to the "other_name" field.
func (m *BookibusUserMutation) ResetOtherName() {
	m.other_name = nil
}

// SetPhone sets the "phone" field.
func (m *BookibusUserMutation) SetPhone(s string) {
	m.phone = &s
}

// Phone returns the value of the "phone" field in the mutation.
func (m *BookibusUserMutation) Phone() (r string, exists bool) {
	v := m.phone
	if v == nil {
		return
	}
	return *v, true
}

// OldPhone returns the old "phone" field's value of the BookibusUser entity.
// If the BookibusUser object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BookibusUserMutation) OldPhone(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPhone is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPhone requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPhone: %w", err)
	}
	return oldValue.Phone, nil
}

// ResetPhone resets all changes to the "phone" field.
func (m *BookibusUserMutation) ResetPhone() {
	m.phone = nil
}

// SetOtherPhone sets the "other_phone" field.
func (m *BookibusUserMutation) SetOtherPhone(s string) {
	m.other_phone = &s
}

// OtherPhone returns the value of the "other_phone" field in the mutation.
func (m *BookibusUserMutation) OtherPhone() (r string, exists bool) {
	v := m.other_phone
	if v == nil {
		return
	}
	return *v, true
}

// OldOtherPhone returns the old "other_phone" field's value of the BookibusUser entity.
// If the BookibusUser object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BookibusUserMutation) OldOtherPhone(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOtherPhone is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOtherPhone requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOtherPhone: %w", err)
	}
	return oldValue.OtherPhone, nil
}

// ClearOtherPhone clears the value of the "other_phone" field.
func (m *BookibusUserMutation) ClearOtherPhone() {
	m.other_phone = nil
	m.clearedFields[bookibususer.FieldOtherPhone] = struct{}{}
}

// OtherPhoneCleared returns if the "other_phone" field was cleared in this mutation.
func (m *BookibusUserMutation) OtherPhoneCleared() bool {
	_, ok := m.clearedFields[bookibususer.FieldOtherPhone]
	return ok
}

// ResetOtherPhone resets all changes to the "other_phone" field.
func (m *BookibusUserMutation) ResetOtherPhone() {
	m.other_phone = nil
	delete(m.clearedFields, bookibususer.FieldOtherPhone)
}

// SetRole sets the "role" field.
func (m *BookibusUserMutation) SetRole(b bookibususer.Role) {
	m.role = &b
}

// Role returns the value of the "role" field in the mutation.
func (m *BookibusUserMutation) Role() (r bookibususer.Role, exists bool) {
	v := m.role
	if v == nil {
		return
	}
	return *v, true
}

// OldRole returns the old "role" field's value of the BookibusUser entity.
// If the BookibusUser object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BookibusUserMutation) OldRole(ctx context.Context) (v bookibususer.Role, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRole is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRole requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRole: %w", err)
	}
	return oldValue.Role, nil
}

// ResetRole resets all changes to the "role" field.
func (m *BookibusUserMutation) ResetRole() {
	m.role = nil
}

// SetProfileID sets the "profile" edge to the User entity by id.
func (m *BookibusUserMutation) SetProfileID(id int) {
	m.profile = &id
}

// ClearProfile clears the "profile" edge to the User entity.
func (m *BookibusUserMutation) ClearProfile() {
	m.clearedprofile = true
}

// ProfileCleared reports if the "profile" edge to the User entity was cleared.
func (m *BookibusUserMutation) ProfileCleared() bool {
	return m.clearedprofile
}

// ProfileID returns the "profile" edge ID in the mutation.
func (m *BookibusUserMutation) ProfileID() (id int, exists bool) {
	if m.profile != nil {
		return *m.profile, true
	}
	return
}

// ProfileIDs returns the "profile" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ProfileID instead. It exists only for internal usage by the builders.
func (m *BookibusUserMutation) ProfileIDs() (ids []int) {
	if id := m.profile; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetProfile resets all changes to the "profile" edge.
func (m *BookibusUserMutation) ResetProfile() {
	m.profile = nil
	m.clearedprofile = false
}

// AddNotificationIDs adds the "notifications" edge to the Notification entity by ids.
func (m *BookibusUserMutation) AddNotificationIDs(ids ...int) {
	if m.notifications == nil {
		m.notifications = make(map[int]struct{})
	}
	for i := range ids {
		m.notifications[ids[i]] = struct{}{}
	}
}

// ClearNotifications clears the "notifications" edge to the Notification entity.
func (m *BookibusUserMutation) ClearNotifications() {
	m.clearednotifications = true
}

// NotificationsCleared reports if the "notifications" edge to the Notification entity was cleared.
func (m *BookibusUserMutation) NotificationsCleared() bool {
	return m.clearednotifications
}

// RemoveNotificationIDs removes the "notifications" edge to the Notification entity by IDs.
func (m *BookibusUserMutation) RemoveNotificationIDs(ids ...int) {
	if m.removednotifications == nil {
		m.removednotifications = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.notifications, ids[i])
		m.removednotifications[ids[i]] = struct{}{}
	}
}

// RemovedNotifications returns the removed IDs of the "notifications" edge to the Notification entity.
func (m *BookibusUserMutation) RemovedNotificationsIDs() (ids []int) {
	for id := range m.removednotifications {
		ids = append(ids, id)
	}
	return
}

// NotificationsIDs returns the "notifications" edge IDs in the mutation.
func (m *BookibusUserMutation) NotificationsIDs() (ids []int) {
	for id := range m.notifications {
		ids = append(ids, id)
	}
	return
}

// ResetNotifications resets all changes to the "notifications" edge.
func (m *BookibusUserMutation) ResetNotifications() {
	m.notifications = nil
	m.clearednotifications = false
	m.removednotifications = nil
}

// Where appends a list predicates to the BookibusUserMutation builder.
func (m *BookibusUserMutation) Where(ps ...predicate.BookibusUser) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the BookibusUserMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *BookibusUserMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.BookibusUser, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *BookibusUserMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *BookibusUserMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (BookibusUser).
func (m *BookibusUserMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *BookibusUserMutation) Fields() []string {
	fields := make([]string, 0, 7)
	if m.created_at != nil {
		fields = append(fields, bookibususer.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, bookibususer.FieldUpdatedAt)
	}
	if m.last_name != nil {
		fields = append(fields, bookibususer.FieldLastName)
	}
	if m.other_name != nil {
		fields = append(fields, bookibususer.FieldOtherName)
	}
	if m.phone != nil {
		fields = append(fields, bookibususer.FieldPhone)
	}
	if m.other_phone != nil {
		fields = append(fields, bookibususer.FieldOtherPhone)
	}
	if m.role != nil {
		fields = append(fields, bookibususer.FieldRole)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *BookibusUserMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case bookibususer.FieldCreatedAt:
		return m.CreatedAt()
	case bookibususer.FieldUpdatedAt:
		return m.UpdatedAt()
	case bookibususer.FieldLastName:
		return m.LastName()
	case bookibususer.FieldOtherName:
		return m.OtherName()
	case bookibususer.FieldPhone:
		return m.Phone()
	case bookibususer.FieldOtherPhone:
		return m.OtherPhone()
	case bookibususer.FieldRole:
		return m.Role()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *BookibusUserMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case bookibususer.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case bookibususer.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case bookibususer.FieldLastName:
		return m.OldLastName(ctx)
	case bookibususer.FieldOtherName:
		return m.OldOtherName(ctx)
	case bookibususer.FieldPhone:
		return m.OldPhone(ctx)
	case bookibususer.FieldOtherPhone:
		return m.OldOtherPhone(ctx)
	case bookibususer.FieldRole:
		return m.OldRole(ctx)
	}
	return nil, fmt.Errorf("unknown BookibusUser field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *BookibusUserMutation) SetField(name string, value ent.Value) error {
	switch name {
	case bookibususer.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case bookibususer.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case bookibususer.FieldLastName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLastName(v)
		return nil
	case bookibususer.FieldOtherName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOtherName(v)
		return nil
	case bookibususer.FieldPhone:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPhone(v)
		return nil
	case bookibususer.FieldOtherPhone:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOtherPhone(v)
		return nil
	case bookibususer.FieldRole:
		v, ok := value.(bookibususer.Role)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRole(v)
		return nil
	}
	return fmt.Errorf("unknown BookibusUser field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *BookibusUserMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *BookibusUserMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *BookibusUserMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown BookibusUser numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *BookibusUserMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(bookibususer.FieldOtherPhone) {
		fields = append(fields, bookibususer.FieldOtherPhone)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *BookibusUserMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *BookibusUserMutation) ClearField(name string) error {
	switch name {
	case bookibususer.FieldOtherPhone:
		m.ClearOtherPhone()
		return nil
	}
	return fmt.Errorf("unknown BookibusUser nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *BookibusUserMutation) ResetField(name string) error {
	switch name {
	case bookibususer.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case bookibususer.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case bookibususer.FieldLastName:
		m.ResetLastName()
		return nil
	case bookibususer.FieldOtherName:
		m.ResetOtherName()
		return nil
	case bookibususer.FieldPhone:
		m.ResetPhone()
		return nil
	case bookibususer.FieldOtherPhone:
		m.ResetOtherPhone()
		return nil
	case bookibususer.FieldRole:
		m.ResetRole()
		return nil
	}
	return fmt.Errorf("unknown BookibusUser field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *BookibusUserMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.profile != nil {
		edges = append(edges, bookibususer.EdgeProfile)
	}
	if m.notifications != nil {
		edges = append(edges, bookibususer.EdgeNotifications)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *BookibusUserMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case bookibususer.EdgeProfile:
		if id := m.profile; id != nil {
			return []ent.Value{*id}
		}
	case bookibususer.EdgeNotifications:
		ids := make([]ent.Value, 0, len(m.notifications))
		for id := range m.notifications {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *BookibusUserMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removednotifications != nil {
		edges = append(edges, bookibususer.EdgeNotifications)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *BookibusUserMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case bookibususer.EdgeNotifications:
		ids := make([]ent.Value, 0, len(m.removednotifications))
		for id := range m.removednotifications {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *BookibusUserMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedprofile {
		edges = append(edges, bookibususer.EdgeProfile)
	}
	if m.clearednotifications {
		edges = append(edges, bookibususer.EdgeNotifications)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *BookibusUserMutation) EdgeCleared(name string) bool {
	switch name {
	case bookibususer.EdgeProfile:
		return m.clearedprofile
	case bookibususer.EdgeNotifications:
		return m.clearednotifications
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *BookibusUserMutation) ClearEdge(name string) error {
	switch name {
	case bookibususer.EdgeProfile:
		m.ClearProfile()
		return nil
	}
	return fmt.Errorf("unknown BookibusUser unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *BookibusUserMutation) ResetEdge(name string) error {
	switch name {
	case bookibususer.EdgeProfile:
		m.ResetProfile()
		return nil
	case bookibususer.EdgeNotifications:
		m.ResetNotifications()
		return nil
	}
	return fmt.Errorf("unknown BookibusUser edge %s", name)
}

// BookingMutation represents an operation that mutates the Booking nodes in the graph.
type BookingMutation struct {
	config
	op                Op
	typ               string
	id                *int
	created_at        *time.Time
	updated_at        *time.Time
	reference         *string
	booking_number    *string
	vat               *float64
	addvat            *float64
	sms_fee           *float64
	addsms_fee        *float64
	amount            *float64
	addamount         *float64
	refund_amount     *float64
	addrefund_amount  *float64
	paid_at           *time.Time
	refund_at         *time.Time
	tans_type         *booking.TansType
	sms_notification  *bool
	status            *booking.Status
	clearedFields     map[string]struct{}
	passengers        map[int]struct{}
	removedpassengers map[int]struct{}
	clearedpassengers bool
	luggages          map[int]struct{}
	removedluggages   map[int]struct{}
	clearedluggages   bool
	contact           *int
	clearedcontact    bool
	trip              *int
	clearedtrip       bool
	company           *int
	clearedcompany    bool
	customer          *int
	clearedcustomer   bool
	done              bool
	oldValue          func(context.Context) (*Booking, error)
	predicates        []predicate.Booking
}

var _ ent.Mutation = (*BookingMutation)(nil)

// bookingOption allows management of the mutation configuration using functional options.
type bookingOption func(*BookingMutation)

// newBookingMutation creates new mutation for the Booking entity.
func newBookingMutation(c config, op Op, opts ...bookingOption) *BookingMutation {
	m := &BookingMutation{
		config:        c,
		op:            op,
		typ:           TypeBooking,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withBookingID sets the ID field of the mutation.
func withBookingID(id int) bookingOption {
	return func(m *BookingMutation) {
		var (
			err   error
			once  sync.Once
			value *Booking
		)
		m.oldValue = func(ctx context.Context) (*Booking, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Booking.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withBooking sets the old Booking of the mutation.
func withBooking(node *Booking) bookingOption {
	return func(m *BookingMutation) {
		m.oldValue = func(context.Context) (*Booking, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m BookingMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m BookingMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *BookingMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *BookingMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Booking.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *BookingMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *BookingMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Booking entity.
// If the Booking object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BookingMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *BookingMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *BookingMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *BookingMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Booking entity.
// If the Booking object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BookingMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *BookingMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetReference sets the "reference" field.
func (m *BookingMutation) SetReference(s string) {
	m.reference = &s
}

// Reference returns the value of the "reference" field in the mutation.
func (m *BookingMutation) Reference() (r string, exists bool) {
	v := m.reference
	if v == nil {
		return
	}
	return *v, true
}

// OldReference returns the old "reference" field's value of the Booking entity.
// If the Booking object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BookingMutation) OldReference(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldReference is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldReference requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldReference: %w", err)
	}
	return oldValue.Reference, nil
}

// ClearReference clears the value of the "reference" field.
func (m *BookingMutation) ClearReference() {
	m.reference = nil
	m.clearedFields[booking.FieldReference] = struct{}{}
}

// ReferenceCleared returns if the "reference" field was cleared in this mutation.
func (m *BookingMutation) ReferenceCleared() bool {
	_, ok := m.clearedFields[booking.FieldReference]
	return ok
}

// ResetReference resets all changes to the "reference" field.
func (m *BookingMutation) ResetReference() {
	m.reference = nil
	delete(m.clearedFields, booking.FieldReference)
}

// SetBookingNumber sets the "booking_number" field.
func (m *BookingMutation) SetBookingNumber(s string) {
	m.booking_number = &s
}

// BookingNumber returns the value of the "booking_number" field in the mutation.
func (m *BookingMutation) BookingNumber() (r string, exists bool) {
	v := m.booking_number
	if v == nil {
		return
	}
	return *v, true
}

// OldBookingNumber returns the old "booking_number" field's value of the Booking entity.
// If the Booking object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BookingMutation) OldBookingNumber(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBookingNumber is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBookingNumber requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBookingNumber: %w", err)
	}
	return oldValue.BookingNumber, nil
}

// ResetBookingNumber resets all changes to the "booking_number" field.
func (m *BookingMutation) ResetBookingNumber() {
	m.booking_number = nil
}

// SetVat sets the "vat" field.
func (m *BookingMutation) SetVat(f float64) {
	m.vat = &f
	m.addvat = nil
}

// Vat returns the value of the "vat" field in the mutation.
func (m *BookingMutation) Vat() (r float64, exists bool) {
	v := m.vat
	if v == nil {
		return
	}
	return *v, true
}

// OldVat returns the old "vat" field's value of the Booking entity.
// If the Booking object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BookingMutation) OldVat(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldVat is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldVat requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldVat: %w", err)
	}
	return oldValue.Vat, nil
}

// AddVat adds f to the "vat" field.
func (m *BookingMutation) AddVat(f float64) {
	if m.addvat != nil {
		*m.addvat += f
	} else {
		m.addvat = &f
	}
}

// AddedVat returns the value that was added to the "vat" field in this mutation.
func (m *BookingMutation) AddedVat() (r float64, exists bool) {
	v := m.addvat
	if v == nil {
		return
	}
	return *v, true
}

// ResetVat resets all changes to the "vat" field.
func (m *BookingMutation) ResetVat() {
	m.vat = nil
	m.addvat = nil
}

// SetSmsFee sets the "sms_fee" field.
func (m *BookingMutation) SetSmsFee(f float64) {
	m.sms_fee = &f
	m.addsms_fee = nil
}

// SmsFee returns the value of the "sms_fee" field in the mutation.
func (m *BookingMutation) SmsFee() (r float64, exists bool) {
	v := m.sms_fee
	if v == nil {
		return
	}
	return *v, true
}

// OldSmsFee returns the old "sms_fee" field's value of the Booking entity.
// If the Booking object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BookingMutation) OldSmsFee(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSmsFee is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSmsFee requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSmsFee: %w", err)
	}
	return oldValue.SmsFee, nil
}

// AddSmsFee adds f to the "sms_fee" field.
func (m *BookingMutation) AddSmsFee(f float64) {
	if m.addsms_fee != nil {
		*m.addsms_fee += f
	} else {
		m.addsms_fee = &f
	}
}

// AddedSmsFee returns the value that was added to the "sms_fee" field in this mutation.
func (m *BookingMutation) AddedSmsFee() (r float64, exists bool) {
	v := m.addsms_fee
	if v == nil {
		return
	}
	return *v, true
}

// ResetSmsFee resets all changes to the "sms_fee" field.
func (m *BookingMutation) ResetSmsFee() {
	m.sms_fee = nil
	m.addsms_fee = nil
}

// SetAmount sets the "amount" field.
func (m *BookingMutation) SetAmount(f float64) {
	m.amount = &f
	m.addamount = nil
}

// Amount returns the value of the "amount" field in the mutation.
func (m *BookingMutation) Amount() (r float64, exists bool) {
	v := m.amount
	if v == nil {
		return
	}
	return *v, true
}

// OldAmount returns the old "amount" field's value of the Booking entity.
// If the Booking object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BookingMutation) OldAmount(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAmount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAmount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAmount: %w", err)
	}
	return oldValue.Amount, nil
}

// AddAmount adds f to the "amount" field.
func (m *BookingMutation) AddAmount(f float64) {
	if m.addamount != nil {
		*m.addamount += f
	} else {
		m.addamount = &f
	}
}

// AddedAmount returns the value that was added to the "amount" field in this mutation.
func (m *BookingMutation) AddedAmount() (r float64, exists bool) {
	v := m.addamount
	if v == nil {
		return
	}
	return *v, true
}

// ResetAmount resets all changes to the "amount" field.
func (m *BookingMutation) ResetAmount() {
	m.amount = nil
	m.addamount = nil
}

// SetRefundAmount sets the "refund_amount" field.
func (m *BookingMutation) SetRefundAmount(f float64) {
	m.refund_amount = &f
	m.addrefund_amount = nil
}

// RefundAmount returns the value of the "refund_amount" field in the mutation.
func (m *BookingMutation) RefundAmount() (r float64, exists bool) {
	v := m.refund_amount
	if v == nil {
		return
	}
	return *v, true
}

// OldRefundAmount returns the old "refund_amount" field's value of the Booking entity.
// If the Booking object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BookingMutation) OldRefundAmount(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRefundAmount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRefundAmount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRefundAmount: %w", err)
	}
	return oldValue.RefundAmount, nil
}

// AddRefundAmount adds f to the "refund_amount" field.
func (m *BookingMutation) AddRefundAmount(f float64) {
	if m.addrefund_amount != nil {
		*m.addrefund_amount += f
	} else {
		m.addrefund_amount = &f
	}
}

// AddedRefundAmount returns the value that was added to the "refund_amount" field in this mutation.
func (m *BookingMutation) AddedRefundAmount() (r float64, exists bool) {
	v := m.addrefund_amount
	if v == nil {
		return
	}
	return *v, true
}

// ClearRefundAmount clears the value of the "refund_amount" field.
func (m *BookingMutation) ClearRefundAmount() {
	m.refund_amount = nil
	m.addrefund_amount = nil
	m.clearedFields[booking.FieldRefundAmount] = struct{}{}
}

// RefundAmountCleared returns if the "refund_amount" field was cleared in this mutation.
func (m *BookingMutation) RefundAmountCleared() bool {
	_, ok := m.clearedFields[booking.FieldRefundAmount]
	return ok
}

// ResetRefundAmount resets all changes to the "refund_amount" field.
func (m *BookingMutation) ResetRefundAmount() {
	m.refund_amount = nil
	m.addrefund_amount = nil
	delete(m.clearedFields, booking.FieldRefundAmount)
}

// SetPaidAt sets the "paid_at" field.
func (m *BookingMutation) SetPaidAt(t time.Time) {
	m.paid_at = &t
}

// PaidAt returns the value of the "paid_at" field in the mutation.
func (m *BookingMutation) PaidAt() (r time.Time, exists bool) {
	v := m.paid_at
	if v == nil {
		return
	}
	return *v, true
}

// OldPaidAt returns the old "paid_at" field's value of the Booking entity.
// If the Booking object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BookingMutation) OldPaidAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPaidAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPaidAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPaidAt: %w", err)
	}
	return oldValue.PaidAt, nil
}

// ClearPaidAt clears the value of the "paid_at" field.
func (m *BookingMutation) ClearPaidAt() {
	m.paid_at = nil
	m.clearedFields[booking.FieldPaidAt] = struct{}{}
}

// PaidAtCleared returns if the "paid_at" field was cleared in this mutation.
func (m *BookingMutation) PaidAtCleared() bool {
	_, ok := m.clearedFields[booking.FieldPaidAt]
	return ok
}

// ResetPaidAt resets all changes to the "paid_at" field.
func (m *BookingMutation) ResetPaidAt() {
	m.paid_at = nil
	delete(m.clearedFields, booking.FieldPaidAt)
}

// SetRefundAt sets the "refund_at" field.
func (m *BookingMutation) SetRefundAt(t time.Time) {
	m.refund_at = &t
}

// RefundAt returns the value of the "refund_at" field in the mutation.
func (m *BookingMutation) RefundAt() (r time.Time, exists bool) {
	v := m.refund_at
	if v == nil {
		return
	}
	return *v, true
}

// OldRefundAt returns the old "refund_at" field's value of the Booking entity.
// If the Booking object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BookingMutation) OldRefundAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRefundAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRefundAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRefundAt: %w", err)
	}
	return oldValue.RefundAt, nil
}

// ClearRefundAt clears the value of the "refund_at" field.
func (m *BookingMutation) ClearRefundAt() {
	m.refund_at = nil
	m.clearedFields[booking.FieldRefundAt] = struct{}{}
}

// RefundAtCleared returns if the "refund_at" field was cleared in this mutation.
func (m *BookingMutation) RefundAtCleared() bool {
	_, ok := m.clearedFields[booking.FieldRefundAt]
	return ok
}

// ResetRefundAt resets all changes to the "refund_at" field.
func (m *BookingMutation) ResetRefundAt() {
	m.refund_at = nil
	delete(m.clearedFields, booking.FieldRefundAt)
}

// SetTansType sets the "tans_type" field.
func (m *BookingMutation) SetTansType(bt booking.TansType) {
	m.tans_type = &bt
}

// TansType returns the value of the "tans_type" field in the mutation.
func (m *BookingMutation) TansType() (r booking.TansType, exists bool) {
	v := m.tans_type
	if v == nil {
		return
	}
	return *v, true
}

// OldTansType returns the old "tans_type" field's value of the Booking entity.
// If the Booking object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BookingMutation) OldTansType(ctx context.Context) (v booking.TansType, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTansType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTansType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTansType: %w", err)
	}
	return oldValue.TansType, nil
}

// ResetTansType resets all changes to the "tans_type" field.
func (m *BookingMutation) ResetTansType() {
	m.tans_type = nil
}

// SetSmsNotification sets the "sms_notification" field.
func (m *BookingMutation) SetSmsNotification(b bool) {
	m.sms_notification = &b
}

// SmsNotification returns the value of the "sms_notification" field in the mutation.
func (m *BookingMutation) SmsNotification() (r bool, exists bool) {
	v := m.sms_notification
	if v == nil {
		return
	}
	return *v, true
}

// OldSmsNotification returns the old "sms_notification" field's value of the Booking entity.
// If the Booking object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BookingMutation) OldSmsNotification(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSmsNotification is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSmsNotification requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSmsNotification: %w", err)
	}
	return oldValue.SmsNotification, nil
}

// ResetSmsNotification resets all changes to the "sms_notification" field.
func (m *BookingMutation) ResetSmsNotification() {
	m.sms_notification = nil
}

// SetStatus sets the "status" field.
func (m *BookingMutation) SetStatus(b booking.Status) {
	m.status = &b
}

// Status returns the value of the "status" field in the mutation.
func (m *BookingMutation) Status() (r booking.Status, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the Booking entity.
// If the Booking object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BookingMutation) OldStatus(ctx context.Context) (v booking.Status, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ResetStatus resets all changes to the "status" field.
func (m *BookingMutation) ResetStatus() {
	m.status = nil
}

// AddPassengerIDs adds the "passengers" edge to the Passenger entity by ids.
func (m *BookingMutation) AddPassengerIDs(ids ...int) {
	if m.passengers == nil {
		m.passengers = make(map[int]struct{})
	}
	for i := range ids {
		m.passengers[ids[i]] = struct{}{}
	}
}

// ClearPassengers clears the "passengers" edge to the Passenger entity.
func (m *BookingMutation) ClearPassengers() {
	m.clearedpassengers = true
}

// PassengersCleared reports if the "passengers" edge to the Passenger entity was cleared.
func (m *BookingMutation) PassengersCleared() bool {
	return m.clearedpassengers
}

// RemovePassengerIDs removes the "passengers" edge to the Passenger entity by IDs.
func (m *BookingMutation) RemovePassengerIDs(ids ...int) {
	if m.removedpassengers == nil {
		m.removedpassengers = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.passengers, ids[i])
		m.removedpassengers[ids[i]] = struct{}{}
	}
}

// RemovedPassengers returns the removed IDs of the "passengers" edge to the Passenger entity.
func (m *BookingMutation) RemovedPassengersIDs() (ids []int) {
	for id := range m.removedpassengers {
		ids = append(ids, id)
	}
	return
}

// PassengersIDs returns the "passengers" edge IDs in the mutation.
func (m *BookingMutation) PassengersIDs() (ids []int) {
	for id := range m.passengers {
		ids = append(ids, id)
	}
	return
}

// ResetPassengers resets all changes to the "passengers" edge.
func (m *BookingMutation) ResetPassengers() {
	m.passengers = nil
	m.clearedpassengers = false
	m.removedpassengers = nil
}

// AddLuggageIDs adds the "luggages" edge to the CustomerLuggage entity by ids.
func (m *BookingMutation) AddLuggageIDs(ids ...int) {
	if m.luggages == nil {
		m.luggages = make(map[int]struct{})
	}
	for i := range ids {
		m.luggages[ids[i]] = struct{}{}
	}
}

// ClearLuggages clears the "luggages" edge to the CustomerLuggage entity.
func (m *BookingMutation) ClearLuggages() {
	m.clearedluggages = true
}

// LuggagesCleared reports if the "luggages" edge to the CustomerLuggage entity was cleared.
func (m *BookingMutation) LuggagesCleared() bool {
	return m.clearedluggages
}

// RemoveLuggageIDs removes the "luggages" edge to the CustomerLuggage entity by IDs.
func (m *BookingMutation) RemoveLuggageIDs(ids ...int) {
	if m.removedluggages == nil {
		m.removedluggages = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.luggages, ids[i])
		m.removedluggages[ids[i]] = struct{}{}
	}
}

// RemovedLuggages returns the removed IDs of the "luggages" edge to the CustomerLuggage entity.
func (m *BookingMutation) RemovedLuggagesIDs() (ids []int) {
	for id := range m.removedluggages {
		ids = append(ids, id)
	}
	return
}

// LuggagesIDs returns the "luggages" edge IDs in the mutation.
func (m *BookingMutation) LuggagesIDs() (ids []int) {
	for id := range m.luggages {
		ids = append(ids, id)
	}
	return
}

// ResetLuggages resets all changes to the "luggages" edge.
func (m *BookingMutation) ResetLuggages() {
	m.luggages = nil
	m.clearedluggages = false
	m.removedluggages = nil
}

// SetContactID sets the "contact" edge to the CustomerContact entity by id.
func (m *BookingMutation) SetContactID(id int) {
	m.contact = &id
}

// ClearContact clears the "contact" edge to the CustomerContact entity.
func (m *BookingMutation) ClearContact() {
	m.clearedcontact = true
}

// ContactCleared reports if the "contact" edge to the CustomerContact entity was cleared.
func (m *BookingMutation) ContactCleared() bool {
	return m.clearedcontact
}

// ContactID returns the "contact" edge ID in the mutation.
func (m *BookingMutation) ContactID() (id int, exists bool) {
	if m.contact != nil {
		return *m.contact, true
	}
	return
}

// ContactIDs returns the "contact" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ContactID instead. It exists only for internal usage by the builders.
func (m *BookingMutation) ContactIDs() (ids []int) {
	if id := m.contact; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetContact resets all changes to the "contact" edge.
func (m *BookingMutation) ResetContact() {
	m.contact = nil
	m.clearedcontact = false
}

// SetTripID sets the "trip" edge to the Trip entity by id.
func (m *BookingMutation) SetTripID(id int) {
	m.trip = &id
}

// ClearTrip clears the "trip" edge to the Trip entity.
func (m *BookingMutation) ClearTrip() {
	m.clearedtrip = true
}

// TripCleared reports if the "trip" edge to the Trip entity was cleared.
func (m *BookingMutation) TripCleared() bool {
	return m.clearedtrip
}

// TripID returns the "trip" edge ID in the mutation.
func (m *BookingMutation) TripID() (id int, exists bool) {
	if m.trip != nil {
		return *m.trip, true
	}
	return
}

// TripIDs returns the "trip" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// TripID instead. It exists only for internal usage by the builders.
func (m *BookingMutation) TripIDs() (ids []int) {
	if id := m.trip; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetTrip resets all changes to the "trip" edge.
func (m *BookingMutation) ResetTrip() {
	m.trip = nil
	m.clearedtrip = false
}

// SetCompanyID sets the "company" edge to the Company entity by id.
func (m *BookingMutation) SetCompanyID(id int) {
	m.company = &id
}

// ClearCompany clears the "company" edge to the Company entity.
func (m *BookingMutation) ClearCompany() {
	m.clearedcompany = true
}

// CompanyCleared reports if the "company" edge to the Company entity was cleared.
func (m *BookingMutation) CompanyCleared() bool {
	return m.clearedcompany
}

// CompanyID returns the "company" edge ID in the mutation.
func (m *BookingMutation) CompanyID() (id int, exists bool) {
	if m.company != nil {
		return *m.company, true
	}
	return
}

// CompanyIDs returns the "company" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// CompanyID instead. It exists only for internal usage by the builders.
func (m *BookingMutation) CompanyIDs() (ids []int) {
	if id := m.company; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetCompany resets all changes to the "company" edge.
func (m *BookingMutation) ResetCompany() {
	m.company = nil
	m.clearedcompany = false
}

// SetCustomerID sets the "customer" edge to the Customer entity by id.
func (m *BookingMutation) SetCustomerID(id int) {
	m.customer = &id
}

// ClearCustomer clears the "customer" edge to the Customer entity.
func (m *BookingMutation) ClearCustomer() {
	m.clearedcustomer = true
}

// CustomerCleared reports if the "customer" edge to the Customer entity was cleared.
func (m *BookingMutation) CustomerCleared() bool {
	return m.clearedcustomer
}

// CustomerID returns the "customer" edge ID in the mutation.
func (m *BookingMutation) CustomerID() (id int, exists bool) {
	if m.customer != nil {
		return *m.customer, true
	}
	return
}

// CustomerIDs returns the "customer" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// CustomerID instead. It exists only for internal usage by the builders.
func (m *BookingMutation) CustomerIDs() (ids []int) {
	if id := m.customer; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetCustomer resets all changes to the "customer" edge.
func (m *BookingMutation) ResetCustomer() {
	m.customer = nil
	m.clearedcustomer = false
}

// Where appends a list predicates to the BookingMutation builder.
func (m *BookingMutation) Where(ps ...predicate.Booking) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the BookingMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *BookingMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Booking, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *BookingMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *BookingMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Booking).
func (m *BookingMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *BookingMutation) Fields() []string {
	fields := make([]string, 0, 13)
	if m.created_at != nil {
		fields = append(fields, booking.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, booking.FieldUpdatedAt)
	}
	if m.reference != nil {
		fields = append(fields, booking.FieldReference)
	}
	if m.booking_number != nil {
		fields = append(fields, booking.FieldBookingNumber)
	}
	if m.vat != nil {
		fields = append(fields, booking.FieldVat)
	}
	if m.sms_fee != nil {
		fields = append(fields, booking.FieldSmsFee)
	}
	if m.amount != nil {
		fields = append(fields, booking.FieldAmount)
	}
	if m.refund_amount != nil {
		fields = append(fields, booking.FieldRefundAmount)
	}
	if m.paid_at != nil {
		fields = append(fields, booking.FieldPaidAt)
	}
	if m.refund_at != nil {
		fields = append(fields, booking.FieldRefundAt)
	}
	if m.tans_type != nil {
		fields = append(fields, booking.FieldTansType)
	}
	if m.sms_notification != nil {
		fields = append(fields, booking.FieldSmsNotification)
	}
	if m.status != nil {
		fields = append(fields, booking.FieldStatus)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *BookingMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case booking.FieldCreatedAt:
		return m.CreatedAt()
	case booking.FieldUpdatedAt:
		return m.UpdatedAt()
	case booking.FieldReference:
		return m.Reference()
	case booking.FieldBookingNumber:
		return m.BookingNumber()
	case booking.FieldVat:
		return m.Vat()
	case booking.FieldSmsFee:
		return m.SmsFee()
	case booking.FieldAmount:
		return m.Amount()
	case booking.FieldRefundAmount:
		return m.RefundAmount()
	case booking.FieldPaidAt:
		return m.PaidAt()
	case booking.FieldRefundAt:
		return m.RefundAt()
	case booking.FieldTansType:
		return m.TansType()
	case booking.FieldSmsNotification:
		return m.SmsNotification()
	case booking.FieldStatus:
		return m.Status()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *BookingMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case booking.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case booking.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case booking.FieldReference:
		return m.OldReference(ctx)
	case booking.FieldBookingNumber:
		return m.OldBookingNumber(ctx)
	case booking.FieldVat:
		return m.OldVat(ctx)
	case booking.FieldSmsFee:
		return m.OldSmsFee(ctx)
	case booking.FieldAmount:
		return m.OldAmount(ctx)
	case booking.FieldRefundAmount:
		return m.OldRefundAmount(ctx)
	case booking.FieldPaidAt:
		return m.OldPaidAt(ctx)
	case booking.FieldRefundAt:
		return m.OldRefundAt(ctx)
	case booking.FieldTansType:
		return m.OldTansType(ctx)
	case booking.FieldSmsNotification:
		return m.OldSmsNotification(ctx)
	case booking.FieldStatus:
		return m.OldStatus(ctx)
	}
	return nil, fmt.Errorf("unknown Booking field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *BookingMutation) SetField(name string, value ent.Value) error {
	switch name {
	case booking.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case booking.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case booking.FieldReference:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetReference(v)
		return nil
	case booking.FieldBookingNumber:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBookingNumber(v)
		return nil
	case booking.FieldVat:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetVat(v)
		return nil
	case booking.FieldSmsFee:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSmsFee(v)
		return nil
	case booking.FieldAmount:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAmount(v)
		return nil
	case booking.FieldRefundAmount:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRefundAmount(v)
		return nil
	case booking.FieldPaidAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPaidAt(v)
		return nil
	case booking.FieldRefundAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRefundAt(v)
		return nil
	case booking.FieldTansType:
		v, ok := value.(booking.TansType)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTansType(v)
		return nil
	case booking.FieldSmsNotification:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSmsNotification(v)
		return nil
	case booking.FieldStatus:
		v, ok := value.(booking.Status)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	}
	return fmt.Errorf("unknown Booking field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *BookingMutation) AddedFields() []string {
	var fields []string
	if m.addvat != nil {
		fields = append(fields, booking.FieldVat)
	}
	if m.addsms_fee != nil {
		fields = append(fields, booking.FieldSmsFee)
	}
	if m.addamount != nil {
		fields = append(fields, booking.FieldAmount)
	}
	if m.addrefund_amount != nil {
		fields = append(fields, booking.FieldRefundAmount)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *BookingMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case booking.FieldVat:
		return m.AddedVat()
	case booking.FieldSmsFee:
		return m.AddedSmsFee()
	case booking.FieldAmount:
		return m.AddedAmount()
	case booking.FieldRefundAmount:
		return m.AddedRefundAmount()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *BookingMutation) AddField(name string, value ent.Value) error {
	switch name {
	case booking.FieldVat:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddVat(v)
		return nil
	case booking.FieldSmsFee:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddSmsFee(v)
		return nil
	case booking.FieldAmount:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddAmount(v)
		return nil
	case booking.FieldRefundAmount:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddRefundAmount(v)
		return nil
	}
	return fmt.Errorf("unknown Booking numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *BookingMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(booking.FieldReference) {
		fields = append(fields, booking.FieldReference)
	}
	if m.FieldCleared(booking.FieldRefundAmount) {
		fields = append(fields, booking.FieldRefundAmount)
	}
	if m.FieldCleared(booking.FieldPaidAt) {
		fields = append(fields, booking.FieldPaidAt)
	}
	if m.FieldCleared(booking.FieldRefundAt) {
		fields = append(fields, booking.FieldRefundAt)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *BookingMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *BookingMutation) ClearField(name string) error {
	switch name {
	case booking.FieldReference:
		m.ClearReference()
		return nil
	case booking.FieldRefundAmount:
		m.ClearRefundAmount()
		return nil
	case booking.FieldPaidAt:
		m.ClearPaidAt()
		return nil
	case booking.FieldRefundAt:
		m.ClearRefundAt()
		return nil
	}
	return fmt.Errorf("unknown Booking nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *BookingMutation) ResetField(name string) error {
	switch name {
	case booking.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case booking.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case booking.FieldReference:
		m.ResetReference()
		return nil
	case booking.FieldBookingNumber:
		m.ResetBookingNumber()
		return nil
	case booking.FieldVat:
		m.ResetVat()
		return nil
	case booking.FieldSmsFee:
		m.ResetSmsFee()
		return nil
	case booking.FieldAmount:
		m.ResetAmount()
		return nil
	case booking.FieldRefundAmount:
		m.ResetRefundAmount()
		return nil
	case booking.FieldPaidAt:
		m.ResetPaidAt()
		return nil
	case booking.FieldRefundAt:
		m.ResetRefundAt()
		return nil
	case booking.FieldTansType:
		m.ResetTansType()
		return nil
	case booking.FieldSmsNotification:
		m.ResetSmsNotification()
		return nil
	case booking.FieldStatus:
		m.ResetStatus()
		return nil
	}
	return fmt.Errorf("unknown Booking field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *BookingMutation) AddedEdges() []string {
	edges := make([]string, 0, 6)
	if m.passengers != nil {
		edges = append(edges, booking.EdgePassengers)
	}
	if m.luggages != nil {
		edges = append(edges, booking.EdgeLuggages)
	}
	if m.contact != nil {
		edges = append(edges, booking.EdgeContact)
	}
	if m.trip != nil {
		edges = append(edges, booking.EdgeTrip)
	}
	if m.company != nil {
		edges = append(edges, booking.EdgeCompany)
	}
	if m.customer != nil {
		edges = append(edges, booking.EdgeCustomer)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *BookingMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case booking.EdgePassengers:
		ids := make([]ent.Value, 0, len(m.passengers))
		for id := range m.passengers {
			ids = append(ids, id)
		}
		return ids
	case booking.EdgeLuggages:
		ids := make([]ent.Value, 0, len(m.luggages))
		for id := range m.luggages {
			ids = append(ids, id)
		}
		return ids
	case booking.EdgeContact:
		if id := m.contact; id != nil {
			return []ent.Value{*id}
		}
	case booking.EdgeTrip:
		if id := m.trip; id != nil {
			return []ent.Value{*id}
		}
	case booking.EdgeCompany:
		if id := m.company; id != nil {
			return []ent.Value{*id}
		}
	case booking.EdgeCustomer:
		if id := m.customer; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *BookingMutation) RemovedEdges() []string {
	edges := make([]string, 0, 6)
	if m.removedpassengers != nil {
		edges = append(edges, booking.EdgePassengers)
	}
	if m.removedluggages != nil {
		edges = append(edges, booking.EdgeLuggages)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *BookingMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case booking.EdgePassengers:
		ids := make([]ent.Value, 0, len(m.removedpassengers))
		for id := range m.removedpassengers {
			ids = append(ids, id)
		}
		return ids
	case booking.EdgeLuggages:
		ids := make([]ent.Value, 0, len(m.removedluggages))
		for id := range m.removedluggages {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *BookingMutation) ClearedEdges() []string {
	edges := make([]string, 0, 6)
	if m.clearedpassengers {
		edges = append(edges, booking.EdgePassengers)
	}
	if m.clearedluggages {
		edges = append(edges, booking.EdgeLuggages)
	}
	if m.clearedcontact {
		edges = append(edges, booking.EdgeContact)
	}
	if m.clearedtrip {
		edges = append(edges, booking.EdgeTrip)
	}
	if m.clearedcompany {
		edges = append(edges, booking.EdgeCompany)
	}
	if m.clearedcustomer {
		edges = append(edges, booking.EdgeCustomer)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *BookingMutation) EdgeCleared(name string) bool {
	switch name {
	case booking.EdgePassengers:
		return m.clearedpassengers
	case booking.EdgeLuggages:
		return m.clearedluggages
	case booking.EdgeContact:
		return m.clearedcontact
	case booking.EdgeTrip:
		return m.clearedtrip
	case booking.EdgeCompany:
		return m.clearedcompany
	case booking.EdgeCustomer:
		return m.clearedcustomer
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *BookingMutation) ClearEdge(name string) error {
	switch name {
	case booking.EdgeContact:
		m.ClearContact()
		return nil
	case booking.EdgeTrip:
		m.ClearTrip()
		return nil
	case booking.EdgeCompany:
		m.ClearCompany()
		return nil
	case booking.EdgeCustomer:
		m.ClearCustomer()
		return nil
	}
	return fmt.Errorf("unknown Booking unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *BookingMutation) ResetEdge(name string) error {
	switch name {
	case booking.EdgePassengers:
		m.ResetPassengers()
		return nil
	case booking.EdgeLuggages:
		m.ResetLuggages()
		return nil
	case booking.EdgeContact:
		m.ResetContact()
		return nil
	case booking.EdgeTrip:
		m.ResetTrip()
		return nil
	case booking.EdgeCompany:
		m.ResetCompany()
		return nil
	case booking.EdgeCustomer:
		m.ResetCustomer()
		return nil
	}
	return fmt.Errorf("unknown Booking edge %s", name)
}

// CompanyMutation represents an operation that mutates the Company nodes in the graph.
type CompanyMutation struct {
	config
	op                   Op
	typ                  string
	id                   *int
	created_at           *time.Time
	updated_at           *time.Time
	name                 *string
	phone                *string
	other_phone          *string
	email                *string
	clearedFields        map[string]struct{}
	profile              map[int]struct{}
	removedprofile       map[int]struct{}
	clearedprofile       bool
	terminals            map[int]struct{}
	removedterminals     map[int]struct{}
	clearedterminals     bool
	vehicles             map[int]struct{}
	removedvehicles      map[int]struct{}
	clearedvehicles      bool
	routes               map[int]struct{}
	removedroutes        map[int]struct{}
	clearedroutes        bool
	trips                map[int]struct{}
	removedtrips         map[int]struct{}
	clearedtrips         bool
	bookings             map[int]struct{}
	removedbookings      map[int]struct{}
	clearedbookings      bool
	incidents            map[int]struct{}
	removedincidents     map[int]struct{}
	clearedincidents     bool
	parcels              map[int]struct{}
	removedparcels       map[int]struct{}
	clearedparcels       bool
	notifications        map[int]struct{}
	removednotifications map[int]struct{}
	clearednotifications bool
	done                 bool
	oldValue             func(context.Context) (*Company, error)
	predicates           []predicate.Company
}

var _ ent.Mutation = (*CompanyMutation)(nil)

// companyOption allows management of the mutation configuration using functional options.
type companyOption func(*CompanyMutation)

// newCompanyMutation creates new mutation for the Company entity.
func newCompanyMutation(c config, op Op, opts ...companyOption) *CompanyMutation {
	m := &CompanyMutation{
		config:        c,
		op:            op,
		typ:           TypeCompany,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withCompanyID sets the ID field of the mutation.
func withCompanyID(id int) companyOption {
	return func(m *CompanyMutation) {
		var (
			err   error
			once  sync.Once
			value *Company
		)
		m.oldValue = func(ctx context.Context) (*Company, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Company.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withCompany sets the old Company of the mutation.
func withCompany(node *Company) companyOption {
	return func(m *CompanyMutation) {
		m.oldValue = func(context.Context) (*Company, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m CompanyMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m CompanyMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *CompanyMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *CompanyMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Company.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *CompanyMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *CompanyMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Company entity.
// If the Company object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CompanyMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *CompanyMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *CompanyMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *CompanyMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Company entity.
// If the Company object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CompanyMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *CompanyMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetName sets the "name" field.
func (m *CompanyMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *CompanyMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Company entity.
// If the Company object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CompanyMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *CompanyMutation) ResetName() {
	m.name = nil
}

// SetPhone sets the "phone" field.
func (m *CompanyMutation) SetPhone(s string) {
	m.phone = &s
}

// Phone returns the value of the "phone" field in the mutation.
func (m *CompanyMutation) Phone() (r string, exists bool) {
	v := m.phone
	if v == nil {
		return
	}
	return *v, true
}

// OldPhone returns the old "phone" field's value of the Company entity.
// If the Company object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CompanyMutation) OldPhone(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPhone is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPhone requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPhone: %w", err)
	}
	return oldValue.Phone, nil
}

// ResetPhone resets all changes to the "phone" field.
func (m *CompanyMutation) ResetPhone() {
	m.phone = nil
}

// SetOtherPhone sets the "other_phone" field.
func (m *CompanyMutation) SetOtherPhone(s string) {
	m.other_phone = &s
}

// OtherPhone returns the value of the "other_phone" field in the mutation.
func (m *CompanyMutation) OtherPhone() (r string, exists bool) {
	v := m.other_phone
	if v == nil {
		return
	}
	return *v, true
}

// OldOtherPhone returns the old "other_phone" field's value of the Company entity.
// If the Company object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CompanyMutation) OldOtherPhone(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOtherPhone is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOtherPhone requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOtherPhone: %w", err)
	}
	return oldValue.OtherPhone, nil
}

// ClearOtherPhone clears the value of the "other_phone" field.
func (m *CompanyMutation) ClearOtherPhone() {
	m.other_phone = nil
	m.clearedFields[company.FieldOtherPhone] = struct{}{}
}

// OtherPhoneCleared returns if the "other_phone" field was cleared in this mutation.
func (m *CompanyMutation) OtherPhoneCleared() bool {
	_, ok := m.clearedFields[company.FieldOtherPhone]
	return ok
}

// ResetOtherPhone resets all changes to the "other_phone" field.
func (m *CompanyMutation) ResetOtherPhone() {
	m.other_phone = nil
	delete(m.clearedFields, company.FieldOtherPhone)
}

// SetEmail sets the "email" field.
func (m *CompanyMutation) SetEmail(s string) {
	m.email = &s
}

// Email returns the value of the "email" field in the mutation.
func (m *CompanyMutation) Email() (r string, exists bool) {
	v := m.email
	if v == nil {
		return
	}
	return *v, true
}

// OldEmail returns the old "email" field's value of the Company entity.
// If the Company object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CompanyMutation) OldEmail(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEmail is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEmail requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEmail: %w", err)
	}
	return oldValue.Email, nil
}

// ResetEmail resets all changes to the "email" field.
func (m *CompanyMutation) ResetEmail() {
	m.email = nil
}

// AddProfileIDs adds the "profile" edge to the CompanyUser entity by ids.
func (m *CompanyMutation) AddProfileIDs(ids ...int) {
	if m.profile == nil {
		m.profile = make(map[int]struct{})
	}
	for i := range ids {
		m.profile[ids[i]] = struct{}{}
	}
}

// ClearProfile clears the "profile" edge to the CompanyUser entity.
func (m *CompanyMutation) ClearProfile() {
	m.clearedprofile = true
}

// ProfileCleared reports if the "profile" edge to the CompanyUser entity was cleared.
func (m *CompanyMutation) ProfileCleared() bool {
	return m.clearedprofile
}

// RemoveProfileIDs removes the "profile" edge to the CompanyUser entity by IDs.
func (m *CompanyMutation) RemoveProfileIDs(ids ...int) {
	if m.removedprofile == nil {
		m.removedprofile = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.profile, ids[i])
		m.removedprofile[ids[i]] = struct{}{}
	}
}

// RemovedProfile returns the removed IDs of the "profile" edge to the CompanyUser entity.
func (m *CompanyMutation) RemovedProfileIDs() (ids []int) {
	for id := range m.removedprofile {
		ids = append(ids, id)
	}
	return
}

// ProfileIDs returns the "profile" edge IDs in the mutation.
func (m *CompanyMutation) ProfileIDs() (ids []int) {
	for id := range m.profile {
		ids = append(ids, id)
	}
	return
}

// ResetProfile resets all changes to the "profile" edge.
func (m *CompanyMutation) ResetProfile() {
	m.profile = nil
	m.clearedprofile = false
	m.removedprofile = nil
}

// AddTerminalIDs adds the "terminals" edge to the Terminal entity by ids.
func (m *CompanyMutation) AddTerminalIDs(ids ...int) {
	if m.terminals == nil {
		m.terminals = make(map[int]struct{})
	}
	for i := range ids {
		m.terminals[ids[i]] = struct{}{}
	}
}

// ClearTerminals clears the "terminals" edge to the Terminal entity.
func (m *CompanyMutation) ClearTerminals() {
	m.clearedterminals = true
}

// TerminalsCleared reports if the "terminals" edge to the Terminal entity was cleared.
func (m *CompanyMutation) TerminalsCleared() bool {
	return m.clearedterminals
}

// RemoveTerminalIDs removes the "terminals" edge to the Terminal entity by IDs.
func (m *CompanyMutation) RemoveTerminalIDs(ids ...int) {
	if m.removedterminals == nil {
		m.removedterminals = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.terminals, ids[i])
		m.removedterminals[ids[i]] = struct{}{}
	}
}

// RemovedTerminals returns the removed IDs of the "terminals" edge to the Terminal entity.
func (m *CompanyMutation) RemovedTerminalsIDs() (ids []int) {
	for id := range m.removedterminals {
		ids = append(ids, id)
	}
	return
}

// TerminalsIDs returns the "terminals" edge IDs in the mutation.
func (m *CompanyMutation) TerminalsIDs() (ids []int) {
	for id := range m.terminals {
		ids = append(ids, id)
	}
	return
}

// ResetTerminals resets all changes to the "terminals" edge.
func (m *CompanyMutation) ResetTerminals() {
	m.terminals = nil
	m.clearedterminals = false
	m.removedterminals = nil
}

// AddVehicleIDs adds the "vehicles" edge to the Vehicle entity by ids.
func (m *CompanyMutation) AddVehicleIDs(ids ...int) {
	if m.vehicles == nil {
		m.vehicles = make(map[int]struct{})
	}
	for i := range ids {
		m.vehicles[ids[i]] = struct{}{}
	}
}

// ClearVehicles clears the "vehicles" edge to the Vehicle entity.
func (m *CompanyMutation) ClearVehicles() {
	m.clearedvehicles = true
}

// VehiclesCleared reports if the "vehicles" edge to the Vehicle entity was cleared.
func (m *CompanyMutation) VehiclesCleared() bool {
	return m.clearedvehicles
}

// RemoveVehicleIDs removes the "vehicles" edge to the Vehicle entity by IDs.
func (m *CompanyMutation) RemoveVehicleIDs(ids ...int) {
	if m.removedvehicles == nil {
		m.removedvehicles = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.vehicles, ids[i])
		m.removedvehicles[ids[i]] = struct{}{}
	}
}

// RemovedVehicles returns the removed IDs of the "vehicles" edge to the Vehicle entity.
func (m *CompanyMutation) RemovedVehiclesIDs() (ids []int) {
	for id := range m.removedvehicles {
		ids = append(ids, id)
	}
	return
}

// VehiclesIDs returns the "vehicles" edge IDs in the mutation.
func (m *CompanyMutation) VehiclesIDs() (ids []int) {
	for id := range m.vehicles {
		ids = append(ids, id)
	}
	return
}

// ResetVehicles resets all changes to the "vehicles" edge.
func (m *CompanyMutation) ResetVehicles() {
	m.vehicles = nil
	m.clearedvehicles = false
	m.removedvehicles = nil
}

// AddRouteIDs adds the "routes" edge to the Route entity by ids.
func (m *CompanyMutation) AddRouteIDs(ids ...int) {
	if m.routes == nil {
		m.routes = make(map[int]struct{})
	}
	for i := range ids {
		m.routes[ids[i]] = struct{}{}
	}
}

// ClearRoutes clears the "routes" edge to the Route entity.
func (m *CompanyMutation) ClearRoutes() {
	m.clearedroutes = true
}

// RoutesCleared reports if the "routes" edge to the Route entity was cleared.
func (m *CompanyMutation) RoutesCleared() bool {
	return m.clearedroutes
}

// RemoveRouteIDs removes the "routes" edge to the Route entity by IDs.
func (m *CompanyMutation) RemoveRouteIDs(ids ...int) {
	if m.removedroutes == nil {
		m.removedroutes = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.routes, ids[i])
		m.removedroutes[ids[i]] = struct{}{}
	}
}

// RemovedRoutes returns the removed IDs of the "routes" edge to the Route entity.
func (m *CompanyMutation) RemovedRoutesIDs() (ids []int) {
	for id := range m.removedroutes {
		ids = append(ids, id)
	}
	return
}

// RoutesIDs returns the "routes" edge IDs in the mutation.
func (m *CompanyMutation) RoutesIDs() (ids []int) {
	for id := range m.routes {
		ids = append(ids, id)
	}
	return
}

// ResetRoutes resets all changes to the "routes" edge.
func (m *CompanyMutation) ResetRoutes() {
	m.routes = nil
	m.clearedroutes = false
	m.removedroutes = nil
}

// AddTripIDs adds the "trips" edge to the Trip entity by ids.
func (m *CompanyMutation) AddTripIDs(ids ...int) {
	if m.trips == nil {
		m.trips = make(map[int]struct{})
	}
	for i := range ids {
		m.trips[ids[i]] = struct{}{}
	}
}

// ClearTrips clears the "trips" edge to the Trip entity.
func (m *CompanyMutation) ClearTrips() {
	m.clearedtrips = true
}

// TripsCleared reports if the "trips" edge to the Trip entity was cleared.
func (m *CompanyMutation) TripsCleared() bool {
	return m.clearedtrips
}

// RemoveTripIDs removes the "trips" edge to the Trip entity by IDs.
func (m *CompanyMutation) RemoveTripIDs(ids ...int) {
	if m.removedtrips == nil {
		m.removedtrips = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.trips, ids[i])
		m.removedtrips[ids[i]] = struct{}{}
	}
}

// RemovedTrips returns the removed IDs of the "trips" edge to the Trip entity.
func (m *CompanyMutation) RemovedTripsIDs() (ids []int) {
	for id := range m.removedtrips {
		ids = append(ids, id)
	}
	return
}

// TripsIDs returns the "trips" edge IDs in the mutation.
func (m *CompanyMutation) TripsIDs() (ids []int) {
	for id := range m.trips {
		ids = append(ids, id)
	}
	return
}

// ResetTrips resets all changes to the "trips" edge.
func (m *CompanyMutation) ResetTrips() {
	m.trips = nil
	m.clearedtrips = false
	m.removedtrips = nil
}

// AddBookingIDs adds the "bookings" edge to the Booking entity by ids.
func (m *CompanyMutation) AddBookingIDs(ids ...int) {
	if m.bookings == nil {
		m.bookings = make(map[int]struct{})
	}
	for i := range ids {
		m.bookings[ids[i]] = struct{}{}
	}
}

// ClearBookings clears the "bookings" edge to the Booking entity.
func (m *CompanyMutation) ClearBookings() {
	m.clearedbookings = true
}

// BookingsCleared reports if the "bookings" edge to the Booking entity was cleared.
func (m *CompanyMutation) BookingsCleared() bool {
	return m.clearedbookings
}

// RemoveBookingIDs removes the "bookings" edge to the Booking entity by IDs.
func (m *CompanyMutation) RemoveBookingIDs(ids ...int) {
	if m.removedbookings == nil {
		m.removedbookings = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.bookings, ids[i])
		m.removedbookings[ids[i]] = struct{}{}
	}
}

// RemovedBookings returns the removed IDs of the "bookings" edge to the Booking entity.
func (m *CompanyMutation) RemovedBookingsIDs() (ids []int) {
	for id := range m.removedbookings {
		ids = append(ids, id)
	}
	return
}

// BookingsIDs returns the "bookings" edge IDs in the mutation.
func (m *CompanyMutation) BookingsIDs() (ids []int) {
	for id := range m.bookings {
		ids = append(ids, id)
	}
	return
}

// ResetBookings resets all changes to the "bookings" edge.
func (m *CompanyMutation) ResetBookings() {
	m.bookings = nil
	m.clearedbookings = false
	m.removedbookings = nil
}

// AddIncidentIDs adds the "incidents" edge to the Incident entity by ids.
func (m *CompanyMutation) AddIncidentIDs(ids ...int) {
	if m.incidents == nil {
		m.incidents = make(map[int]struct{})
	}
	for i := range ids {
		m.incidents[ids[i]] = struct{}{}
	}
}

// ClearIncidents clears the "incidents" edge to the Incident entity.
func (m *CompanyMutation) ClearIncidents() {
	m.clearedincidents = true
}

// IncidentsCleared reports if the "incidents" edge to the Incident entity was cleared.
func (m *CompanyMutation) IncidentsCleared() bool {
	return m.clearedincidents
}

// RemoveIncidentIDs removes the "incidents" edge to the Incident entity by IDs.
func (m *CompanyMutation) RemoveIncidentIDs(ids ...int) {
	if m.removedincidents == nil {
		m.removedincidents = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.incidents, ids[i])
		m.removedincidents[ids[i]] = struct{}{}
	}
}

// RemovedIncidents returns the removed IDs of the "incidents" edge to the Incident entity.
func (m *CompanyMutation) RemovedIncidentsIDs() (ids []int) {
	for id := range m.removedincidents {
		ids = append(ids, id)
	}
	return
}

// IncidentsIDs returns the "incidents" edge IDs in the mutation.
func (m *CompanyMutation) IncidentsIDs() (ids []int) {
	for id := range m.incidents {
		ids = append(ids, id)
	}
	return
}

// ResetIncidents resets all changes to the "incidents" edge.
func (m *CompanyMutation) ResetIncidents() {
	m.incidents = nil
	m.clearedincidents = false
	m.removedincidents = nil
}

// AddParcelIDs adds the "parcels" edge to the Parcel entity by ids.
func (m *CompanyMutation) AddParcelIDs(ids ...int) {
	if m.parcels == nil {
		m.parcels = make(map[int]struct{})
	}
	for i := range ids {
		m.parcels[ids[i]] = struct{}{}
	}
}

// ClearParcels clears the "parcels" edge to the Parcel entity.
func (m *CompanyMutation) ClearParcels() {
	m.clearedparcels = true
}

// ParcelsCleared reports if the "parcels" edge to the Parcel entity was cleared.
func (m *CompanyMutation) ParcelsCleared() bool {
	return m.clearedparcels
}

// RemoveParcelIDs removes the "parcels" edge to the Parcel entity by IDs.
func (m *CompanyMutation) RemoveParcelIDs(ids ...int) {
	if m.removedparcels == nil {
		m.removedparcels = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.parcels, ids[i])
		m.removedparcels[ids[i]] = struct{}{}
	}
}

// RemovedParcels returns the removed IDs of the "parcels" edge to the Parcel entity.
func (m *CompanyMutation) RemovedParcelsIDs() (ids []int) {
	for id := range m.removedparcels {
		ids = append(ids, id)
	}
	return
}

// ParcelsIDs returns the "parcels" edge IDs in the mutation.
func (m *CompanyMutation) ParcelsIDs() (ids []int) {
	for id := range m.parcels {
		ids = append(ids, id)
	}
	return
}

// ResetParcels resets all changes to the "parcels" edge.
func (m *CompanyMutation) ResetParcels() {
	m.parcels = nil
	m.clearedparcels = false
	m.removedparcels = nil
}

// AddNotificationIDs adds the "notifications" edge to the Notification entity by ids.
func (m *CompanyMutation) AddNotificationIDs(ids ...int) {
	if m.notifications == nil {
		m.notifications = make(map[int]struct{})
	}
	for i := range ids {
		m.notifications[ids[i]] = struct{}{}
	}
}

// ClearNotifications clears the "notifications" edge to the Notification entity.
func (m *CompanyMutation) ClearNotifications() {
	m.clearednotifications = true
}

// NotificationsCleared reports if the "notifications" edge to the Notification entity was cleared.
func (m *CompanyMutation) NotificationsCleared() bool {
	return m.clearednotifications
}

// RemoveNotificationIDs removes the "notifications" edge to the Notification entity by IDs.
func (m *CompanyMutation) RemoveNotificationIDs(ids ...int) {
	if m.removednotifications == nil {
		m.removednotifications = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.notifications, ids[i])
		m.removednotifications[ids[i]] = struct{}{}
	}
}

// RemovedNotifications returns the removed IDs of the "notifications" edge to the Notification entity.
func (m *CompanyMutation) RemovedNotificationsIDs() (ids []int) {
	for id := range m.removednotifications {
		ids = append(ids, id)
	}
	return
}

// NotificationsIDs returns the "notifications" edge IDs in the mutation.
func (m *CompanyMutation) NotificationsIDs() (ids []int) {
	for id := range m.notifications {
		ids = append(ids, id)
	}
	return
}

// ResetNotifications resets all changes to the "notifications" edge.
func (m *CompanyMutation) ResetNotifications() {
	m.notifications = nil
	m.clearednotifications = false
	m.removednotifications = nil
}

// Where appends a list predicates to the CompanyMutation builder.
func (m *CompanyMutation) Where(ps ...predicate.Company) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the CompanyMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *CompanyMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Company, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *CompanyMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *CompanyMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Company).
func (m *CompanyMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *CompanyMutation) Fields() []string {
	fields := make([]string, 0, 6)
	if m.created_at != nil {
		fields = append(fields, company.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, company.FieldUpdatedAt)
	}
	if m.name != nil {
		fields = append(fields, company.FieldName)
	}
	if m.phone != nil {
		fields = append(fields, company.FieldPhone)
	}
	if m.other_phone != nil {
		fields = append(fields, company.FieldOtherPhone)
	}
	if m.email != nil {
		fields = append(fields, company.FieldEmail)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *CompanyMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case company.FieldCreatedAt:
		return m.CreatedAt()
	case company.FieldUpdatedAt:
		return m.UpdatedAt()
	case company.FieldName:
		return m.Name()
	case company.FieldPhone:
		return m.Phone()
	case company.FieldOtherPhone:
		return m.OtherPhone()
	case company.FieldEmail:
		return m.Email()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *CompanyMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case company.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case company.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case company.FieldName:
		return m.OldName(ctx)
	case company.FieldPhone:
		return m.OldPhone(ctx)
	case company.FieldOtherPhone:
		return m.OldOtherPhone(ctx)
	case company.FieldEmail:
		return m.OldEmail(ctx)
	}
	return nil, fmt.Errorf("unknown Company field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CompanyMutation) SetField(name string, value ent.Value) error {
	switch name {
	case company.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case company.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case company.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case company.FieldPhone:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPhone(v)
		return nil
	case company.FieldOtherPhone:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOtherPhone(v)
		return nil
	case company.FieldEmail:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEmail(v)
		return nil
	}
	return fmt.Errorf("unknown Company field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *CompanyMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *CompanyMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CompanyMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Company numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *CompanyMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(company.FieldOtherPhone) {
		fields = append(fields, company.FieldOtherPhone)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *CompanyMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *CompanyMutation) ClearField(name string) error {
	switch name {
	case company.FieldOtherPhone:
		m.ClearOtherPhone()
		return nil
	}
	return fmt.Errorf("unknown Company nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *CompanyMutation) ResetField(name string) error {
	switch name {
	case company.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case company.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case company.FieldName:
		m.ResetName()
		return nil
	case company.FieldPhone:
		m.ResetPhone()
		return nil
	case company.FieldOtherPhone:
		m.ResetOtherPhone()
		return nil
	case company.FieldEmail:
		m.ResetEmail()
		return nil
	}
	return fmt.Errorf("unknown Company field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *CompanyMutation) AddedEdges() []string {
	edges := make([]string, 0, 9)
	if m.profile != nil {
		edges = append(edges, company.EdgeProfile)
	}
	if m.terminals != nil {
		edges = append(edges, company.EdgeTerminals)
	}
	if m.vehicles != nil {
		edges = append(edges, company.EdgeVehicles)
	}
	if m.routes != nil {
		edges = append(edges, company.EdgeRoutes)
	}
	if m.trips != nil {
		edges = append(edges, company.EdgeTrips)
	}
	if m.bookings != nil {
		edges = append(edges, company.EdgeBookings)
	}
	if m.incidents != nil {
		edges = append(edges, company.EdgeIncidents)
	}
	if m.parcels != nil {
		edges = append(edges, company.EdgeParcels)
	}
	if m.notifications != nil {
		edges = append(edges, company.EdgeNotifications)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *CompanyMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case company.EdgeProfile:
		ids := make([]ent.Value, 0, len(m.profile))
		for id := range m.profile {
			ids = append(ids, id)
		}
		return ids
	case company.EdgeTerminals:
		ids := make([]ent.Value, 0, len(m.terminals))
		for id := range m.terminals {
			ids = append(ids, id)
		}
		return ids
	case company.EdgeVehicles:
		ids := make([]ent.Value, 0, len(m.vehicles))
		for id := range m.vehicles {
			ids = append(ids, id)
		}
		return ids
	case company.EdgeRoutes:
		ids := make([]ent.Value, 0, len(m.routes))
		for id := range m.routes {
			ids = append(ids, id)
		}
		return ids
	case company.EdgeTrips:
		ids := make([]ent.Value, 0, len(m.trips))
		for id := range m.trips {
			ids = append(ids, id)
		}
		return ids
	case company.EdgeBookings:
		ids := make([]ent.Value, 0, len(m.bookings))
		for id := range m.bookings {
			ids = append(ids, id)
		}
		return ids
	case company.EdgeIncidents:
		ids := make([]ent.Value, 0, len(m.incidents))
		for id := range m.incidents {
			ids = append(ids, id)
		}
		return ids
	case company.EdgeParcels:
		ids := make([]ent.Value, 0, len(m.parcels))
		for id := range m.parcels {
			ids = append(ids, id)
		}
		return ids
	case company.EdgeNotifications:
		ids := make([]ent.Value, 0, len(m.notifications))
		for id := range m.notifications {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *CompanyMutation) RemovedEdges() []string {
	edges := make([]string, 0, 9)
	if m.removedprofile != nil {
		edges = append(edges, company.EdgeProfile)
	}
	if m.removedterminals != nil {
		edges = append(edges, company.EdgeTerminals)
	}
	if m.removedvehicles != nil {
		edges = append(edges, company.EdgeVehicles)
	}
	if m.removedroutes != nil {
		edges = append(edges, company.EdgeRoutes)
	}
	if m.removedtrips != nil {
		edges = append(edges, company.EdgeTrips)
	}
	if m.removedbookings != nil {
		edges = append(edges, company.EdgeBookings)
	}
	if m.removedincidents != nil {
		edges = append(edges, company.EdgeIncidents)
	}
	if m.removedparcels != nil {
		edges = append(edges, company.EdgeParcels)
	}
	if m.removednotifications != nil {
		edges = append(edges, company.EdgeNotifications)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *CompanyMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case company.EdgeProfile:
		ids := make([]ent.Value, 0, len(m.removedprofile))
		for id := range m.removedprofile {
			ids = append(ids, id)
		}
		return ids
	case company.EdgeTerminals:
		ids := make([]ent.Value, 0, len(m.removedterminals))
		for id := range m.removedterminals {
			ids = append(ids, id)
		}
		return ids
	case company.EdgeVehicles:
		ids := make([]ent.Value, 0, len(m.removedvehicles))
		for id := range m.removedvehicles {
			ids = append(ids, id)
		}
		return ids
	case company.EdgeRoutes:
		ids := make([]ent.Value, 0, len(m.removedroutes))
		for id := range m.removedroutes {
			ids = append(ids, id)
		}
		return ids
	case company.EdgeTrips:
		ids := make([]ent.Value, 0, len(m.removedtrips))
		for id := range m.removedtrips {
			ids = append(ids, id)
		}
		return ids
	case company.EdgeBookings:
		ids := make([]ent.Value, 0, len(m.removedbookings))
		for id := range m.removedbookings {
			ids = append(ids, id)
		}
		return ids
	case company.EdgeIncidents:
		ids := make([]ent.Value, 0, len(m.removedincidents))
		for id := range m.removedincidents {
			ids = append(ids, id)
		}
		return ids
	case company.EdgeParcels:
		ids := make([]ent.Value, 0, len(m.removedparcels))
		for id := range m.removedparcels {
			ids = append(ids, id)
		}
		return ids
	case company.EdgeNotifications:
		ids := make([]ent.Value, 0, len(m.removednotifications))
		for id := range m.removednotifications {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *CompanyMutation) ClearedEdges() []string {
	edges := make([]string, 0, 9)
	if m.clearedprofile {
		edges = append(edges, company.EdgeProfile)
	}
	if m.clearedterminals {
		edges = append(edges, company.EdgeTerminals)
	}
	if m.clearedvehicles {
		edges = append(edges, company.EdgeVehicles)
	}
	if m.clearedroutes {
		edges = append(edges, company.EdgeRoutes)
	}
	if m.clearedtrips {
		edges = append(edges, company.EdgeTrips)
	}
	if m.clearedbookings {
		edges = append(edges, company.EdgeBookings)
	}
	if m.clearedincidents {
		edges = append(edges, company.EdgeIncidents)
	}
	if m.clearedparcels {
		edges = append(edges, company.EdgeParcels)
	}
	if m.clearednotifications {
		edges = append(edges, company.EdgeNotifications)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *CompanyMutation) EdgeCleared(name string) bool {
	switch name {
	case company.EdgeProfile:
		return m.clearedprofile
	case company.EdgeTerminals:
		return m.clearedterminals
	case company.EdgeVehicles:
		return m.clearedvehicles
	case company.EdgeRoutes:
		return m.clearedroutes
	case company.EdgeTrips:
		return m.clearedtrips
	case company.EdgeBookings:
		return m.clearedbookings
	case company.EdgeIncidents:
		return m.clearedincidents
	case company.EdgeParcels:
		return m.clearedparcels
	case company.EdgeNotifications:
		return m.clearednotifications
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *CompanyMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Company unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *CompanyMutation) ResetEdge(name string) error {
	switch name {
	case company.EdgeProfile:
		m.ResetProfile()
		return nil
	case company.EdgeTerminals:
		m.ResetTerminals()
		return nil
	case company.EdgeVehicles:
		m.ResetVehicles()
		return nil
	case company.EdgeRoutes:
		m.ResetRoutes()
		return nil
	case company.EdgeTrips:
		m.ResetTrips()
		return nil
	case company.EdgeBookings:
		m.ResetBookings()
		return nil
	case company.EdgeIncidents:
		m.ResetIncidents()
		return nil
	case company.EdgeParcels:
		m.ResetParcels()
		return nil
	case company.EdgeNotifications:
		m.ResetNotifications()
		return nil
	}
	return fmt.Errorf("unknown Company edge %s", name)
}

// CompanyUserMutation represents an operation that mutates the CompanyUser nodes in the graph.
type CompanyUserMutation struct {
	config
	op                   Op
	typ                  string
	id                   *int
	created_at           *time.Time
	updated_at           *time.Time
	last_name            *string
	other_name           *string
	phone                *string
	other_phone          *string
	role                 *companyuser.Role
	clearedFields        map[string]struct{}
	profile              *int
	clearedprofile       bool
	trips                map[int]struct{}
	removedtrips         map[int]struct{}
	clearedtrips         bool
	incidents            map[int]struct{}
	removedincidents     map[int]struct{}
	clearedincidents     bool
	parcels              map[int]struct{}
	removedparcels       map[int]struct{}
	clearedparcels       bool
	notifications        map[int]struct{}
	removednotifications map[int]struct{}
	clearednotifications bool
	company              *int
	clearedcompany       bool
	done                 bool
	oldValue             func(context.Context) (*CompanyUser, error)
	predicates           []predicate.CompanyUser
}

var _ ent.Mutation = (*CompanyUserMutation)(nil)

// companyuserOption allows management of the mutation configuration using functional options.
type companyuserOption func(*CompanyUserMutation)

// newCompanyUserMutation creates new mutation for the CompanyUser entity.
func newCompanyUserMutation(c config, op Op, opts ...companyuserOption) *CompanyUserMutation {
	m := &CompanyUserMutation{
		config:        c,
		op:            op,
		typ:           TypeCompanyUser,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withCompanyUserID sets the ID field of the mutation.
func withCompanyUserID(id int) companyuserOption {
	return func(m *CompanyUserMutation) {
		var (
			err   error
			once  sync.Once
			value *CompanyUser
		)
		m.oldValue = func(ctx context.Context) (*CompanyUser, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().CompanyUser.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withCompanyUser sets the old CompanyUser of the mutation.
func withCompanyUser(node *CompanyUser) companyuserOption {
	return func(m *CompanyUserMutation) {
		m.oldValue = func(context.Context) (*CompanyUser, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m CompanyUserMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m CompanyUserMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *CompanyUserMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *CompanyUserMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().CompanyUser.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *CompanyUserMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *CompanyUserMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the CompanyUser entity.
// If the CompanyUser object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CompanyUserMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *CompanyUserMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *CompanyUserMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *CompanyUserMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the CompanyUser entity.
// If the CompanyUser object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CompanyUserMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *CompanyUserMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetLastName sets the "last_name" field.
func (m *CompanyUserMutation) SetLastName(s string) {
	m.last_name = &s
}

// LastName returns the value of the "last_name" field in the mutation.
func (m *CompanyUserMutation) LastName() (r string, exists bool) {
	v := m.last_name
	if v == nil {
		return
	}
	return *v, true
}

// OldLastName returns the old "last_name" field's value of the CompanyUser entity.
// If the CompanyUser object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CompanyUserMutation) OldLastName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLastName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLastName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLastName: %w", err)
	}
	return oldValue.LastName, nil
}

// ClearLastName clears the value of the "last_name" field.
func (m *CompanyUserMutation) ClearLastName() {
	m.last_name = nil
	m.clearedFields[companyuser.FieldLastName] = struct{}{}
}

// LastNameCleared returns if the "last_name" field was cleared in this mutation.
func (m *CompanyUserMutation) LastNameCleared() bool {
	_, ok := m.clearedFields[companyuser.FieldLastName]
	return ok
}

// ResetLastName resets all changes to the "last_name" field.
func (m *CompanyUserMutation) ResetLastName() {
	m.last_name = nil
	delete(m.clearedFields, companyuser.FieldLastName)
}

// SetOtherName sets the "other_name" field.
func (m *CompanyUserMutation) SetOtherName(s string) {
	m.other_name = &s
}

// OtherName returns the value of the "other_name" field in the mutation.
func (m *CompanyUserMutation) OtherName() (r string, exists bool) {
	v := m.other_name
	if v == nil {
		return
	}
	return *v, true
}

// OldOtherName returns the old "other_name" field's value of the CompanyUser entity.
// If the CompanyUser object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CompanyUserMutation) OldOtherName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOtherName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOtherName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOtherName: %w", err)
	}
	return oldValue.OtherName, nil
}

// ClearOtherName clears the value of the "other_name" field.
func (m *CompanyUserMutation) ClearOtherName() {
	m.other_name = nil
	m.clearedFields[companyuser.FieldOtherName] = struct{}{}
}

// OtherNameCleared returns if the "other_name" field was cleared in this mutation.
func (m *CompanyUserMutation) OtherNameCleared() bool {
	_, ok := m.clearedFields[companyuser.FieldOtherName]
	return ok
}

// ResetOtherName resets all changes to the "other_name" field.
func (m *CompanyUserMutation) ResetOtherName() {
	m.other_name = nil
	delete(m.clearedFields, companyuser.FieldOtherName)
}

// SetPhone sets the "phone" field.
func (m *CompanyUserMutation) SetPhone(s string) {
	m.phone = &s
}

// Phone returns the value of the "phone" field in the mutation.
func (m *CompanyUserMutation) Phone() (r string, exists bool) {
	v := m.phone
	if v == nil {
		return
	}
	return *v, true
}

// OldPhone returns the old "phone" field's value of the CompanyUser entity.
// If the CompanyUser object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CompanyUserMutation) OldPhone(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPhone is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPhone requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPhone: %w", err)
	}
	return oldValue.Phone, nil
}

// ClearPhone clears the value of the "phone" field.
func (m *CompanyUserMutation) ClearPhone() {
	m.phone = nil
	m.clearedFields[companyuser.FieldPhone] = struct{}{}
}

// PhoneCleared returns if the "phone" field was cleared in this mutation.
func (m *CompanyUserMutation) PhoneCleared() bool {
	_, ok := m.clearedFields[companyuser.FieldPhone]
	return ok
}

// ResetPhone resets all changes to the "phone" field.
func (m *CompanyUserMutation) ResetPhone() {
	m.phone = nil
	delete(m.clearedFields, companyuser.FieldPhone)
}

// SetOtherPhone sets the "other_phone" field.
func (m *CompanyUserMutation) SetOtherPhone(s string) {
	m.other_phone = &s
}

// OtherPhone returns the value of the "other_phone" field in the mutation.
func (m *CompanyUserMutation) OtherPhone() (r string, exists bool) {
	v := m.other_phone
	if v == nil {
		return
	}
	return *v, true
}

// OldOtherPhone returns the old "other_phone" field's value of the CompanyUser entity.
// If the CompanyUser object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CompanyUserMutation) OldOtherPhone(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOtherPhone is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOtherPhone requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOtherPhone: %w", err)
	}
	return oldValue.OtherPhone, nil
}

// ClearOtherPhone clears the value of the "other_phone" field.
func (m *CompanyUserMutation) ClearOtherPhone() {
	m.other_phone = nil
	m.clearedFields[companyuser.FieldOtherPhone] = struct{}{}
}

// OtherPhoneCleared returns if the "other_phone" field was cleared in this mutation.
func (m *CompanyUserMutation) OtherPhoneCleared() bool {
	_, ok := m.clearedFields[companyuser.FieldOtherPhone]
	return ok
}

// ResetOtherPhone resets all changes to the "other_phone" field.
func (m *CompanyUserMutation) ResetOtherPhone() {
	m.other_phone = nil
	delete(m.clearedFields, companyuser.FieldOtherPhone)
}

// SetRole sets the "role" field.
func (m *CompanyUserMutation) SetRole(c companyuser.Role) {
	m.role = &c
}

// Role returns the value of the "role" field in the mutation.
func (m *CompanyUserMutation) Role() (r companyuser.Role, exists bool) {
	v := m.role
	if v == nil {
		return
	}
	return *v, true
}

// OldRole returns the old "role" field's value of the CompanyUser entity.
// If the CompanyUser object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CompanyUserMutation) OldRole(ctx context.Context) (v companyuser.Role, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRole is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRole requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRole: %w", err)
	}
	return oldValue.Role, nil
}

// ResetRole resets all changes to the "role" field.
func (m *CompanyUserMutation) ResetRole() {
	m.role = nil
}

// SetProfileID sets the "profile" edge to the User entity by id.
func (m *CompanyUserMutation) SetProfileID(id int) {
	m.profile = &id
}

// ClearProfile clears the "profile" edge to the User entity.
func (m *CompanyUserMutation) ClearProfile() {
	m.clearedprofile = true
}

// ProfileCleared reports if the "profile" edge to the User entity was cleared.
func (m *CompanyUserMutation) ProfileCleared() bool {
	return m.clearedprofile
}

// ProfileID returns the "profile" edge ID in the mutation.
func (m *CompanyUserMutation) ProfileID() (id int, exists bool) {
	if m.profile != nil {
		return *m.profile, true
	}
	return
}

// ProfileIDs returns the "profile" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ProfileID instead. It exists only for internal usage by the builders.
func (m *CompanyUserMutation) ProfileIDs() (ids []int) {
	if id := m.profile; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetProfile resets all changes to the "profile" edge.
func (m *CompanyUserMutation) ResetProfile() {
	m.profile = nil
	m.clearedprofile = false
}

// AddTripIDs adds the "trips" edge to the Trip entity by ids.
func (m *CompanyUserMutation) AddTripIDs(ids ...int) {
	if m.trips == nil {
		m.trips = make(map[int]struct{})
	}
	for i := range ids {
		m.trips[ids[i]] = struct{}{}
	}
}

// ClearTrips clears the "trips" edge to the Trip entity.
func (m *CompanyUserMutation) ClearTrips() {
	m.clearedtrips = true
}

// TripsCleared reports if the "trips" edge to the Trip entity was cleared.
func (m *CompanyUserMutation) TripsCleared() bool {
	return m.clearedtrips
}

// RemoveTripIDs removes the "trips" edge to the Trip entity by IDs.
func (m *CompanyUserMutation) RemoveTripIDs(ids ...int) {
	if m.removedtrips == nil {
		m.removedtrips = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.trips, ids[i])
		m.removedtrips[ids[i]] = struct{}{}
	}
}

// RemovedTrips returns the removed IDs of the "trips" edge to the Trip entity.
func (m *CompanyUserMutation) RemovedTripsIDs() (ids []int) {
	for id := range m.removedtrips {
		ids = append(ids, id)
	}
	return
}

// TripsIDs returns the "trips" edge IDs in the mutation.
func (m *CompanyUserMutation) TripsIDs() (ids []int) {
	for id := range m.trips {
		ids = append(ids, id)
	}
	return
}

// ResetTrips resets all changes to the "trips" edge.
func (m *CompanyUserMutation) ResetTrips() {
	m.trips = nil
	m.clearedtrips = false
	m.removedtrips = nil
}

// AddIncidentIDs adds the "incidents" edge to the Incident entity by ids.
func (m *CompanyUserMutation) AddIncidentIDs(ids ...int) {
	if m.incidents == nil {
		m.incidents = make(map[int]struct{})
	}
	for i := range ids {
		m.incidents[ids[i]] = struct{}{}
	}
}

// ClearIncidents clears the "incidents" edge to the Incident entity.
func (m *CompanyUserMutation) ClearIncidents() {
	m.clearedincidents = true
}

// IncidentsCleared reports if the "incidents" edge to the Incident entity was cleared.
func (m *CompanyUserMutation) IncidentsCleared() bool {
	return m.clearedincidents
}

// RemoveIncidentIDs removes the "incidents" edge to the Incident entity by IDs.
func (m *CompanyUserMutation) RemoveIncidentIDs(ids ...int) {
	if m.removedincidents == nil {
		m.removedincidents = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.incidents, ids[i])
		m.removedincidents[ids[i]] = struct{}{}
	}
}

// RemovedIncidents returns the removed IDs of the "incidents" edge to the Incident entity.
func (m *CompanyUserMutation) RemovedIncidentsIDs() (ids []int) {
	for id := range m.removedincidents {
		ids = append(ids, id)
	}
	return
}

// IncidentsIDs returns the "incidents" edge IDs in the mutation.
func (m *CompanyUserMutation) IncidentsIDs() (ids []int) {
	for id := range m.incidents {
		ids = append(ids, id)
	}
	return
}

// ResetIncidents resets all changes to the "incidents" edge.
func (m *CompanyUserMutation) ResetIncidents() {
	m.incidents = nil
	m.clearedincidents = false
	m.removedincidents = nil
}

// AddParcelIDs adds the "parcels" edge to the Parcel entity by ids.
func (m *CompanyUserMutation) AddParcelIDs(ids ...int) {
	if m.parcels == nil {
		m.parcels = make(map[int]struct{})
	}
	for i := range ids {
		m.parcels[ids[i]] = struct{}{}
	}
}

// ClearParcels clears the "parcels" edge to the Parcel entity.
func (m *CompanyUserMutation) ClearParcels() {
	m.clearedparcels = true
}

// ParcelsCleared reports if the "parcels" edge to the Parcel entity was cleared.
func (m *CompanyUserMutation) ParcelsCleared() bool {
	return m.clearedparcels
}

// RemoveParcelIDs removes the "parcels" edge to the Parcel entity by IDs.
func (m *CompanyUserMutation) RemoveParcelIDs(ids ...int) {
	if m.removedparcels == nil {
		m.removedparcels = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.parcels, ids[i])
		m.removedparcels[ids[i]] = struct{}{}
	}
}

// RemovedParcels returns the removed IDs of the "parcels" edge to the Parcel entity.
func (m *CompanyUserMutation) RemovedParcelsIDs() (ids []int) {
	for id := range m.removedparcels {
		ids = append(ids, id)
	}
	return
}

// ParcelsIDs returns the "parcels" edge IDs in the mutation.
func (m *CompanyUserMutation) ParcelsIDs() (ids []int) {
	for id := range m.parcels {
		ids = append(ids, id)
	}
	return
}

// ResetParcels resets all changes to the "parcels" edge.
func (m *CompanyUserMutation) ResetParcels() {
	m.parcels = nil
	m.clearedparcels = false
	m.removedparcels = nil
}

// AddNotificationIDs adds the "notifications" edge to the Notification entity by ids.
func (m *CompanyUserMutation) AddNotificationIDs(ids ...int) {
	if m.notifications == nil {
		m.notifications = make(map[int]struct{})
	}
	for i := range ids {
		m.notifications[ids[i]] = struct{}{}
	}
}

// ClearNotifications clears the "notifications" edge to the Notification entity.
func (m *CompanyUserMutation) ClearNotifications() {
	m.clearednotifications = true
}

// NotificationsCleared reports if the "notifications" edge to the Notification entity was cleared.
func (m *CompanyUserMutation) NotificationsCleared() bool {
	return m.clearednotifications
}

// RemoveNotificationIDs removes the "notifications" edge to the Notification entity by IDs.
func (m *CompanyUserMutation) RemoveNotificationIDs(ids ...int) {
	if m.removednotifications == nil {
		m.removednotifications = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.notifications, ids[i])
		m.removednotifications[ids[i]] = struct{}{}
	}
}

// RemovedNotifications returns the removed IDs of the "notifications" edge to the Notification entity.
func (m *CompanyUserMutation) RemovedNotificationsIDs() (ids []int) {
	for id := range m.removednotifications {
		ids = append(ids, id)
	}
	return
}

// NotificationsIDs returns the "notifications" edge IDs in the mutation.
func (m *CompanyUserMutation) NotificationsIDs() (ids []int) {
	for id := range m.notifications {
		ids = append(ids, id)
	}
	return
}

// ResetNotifications resets all changes to the "notifications" edge.
func (m *CompanyUserMutation) ResetNotifications() {
	m.notifications = nil
	m.clearednotifications = false
	m.removednotifications = nil
}

// SetCompanyID sets the "company" edge to the Company entity by id.
func (m *CompanyUserMutation) SetCompanyID(id int) {
	m.company = &id
}

// ClearCompany clears the "company" edge to the Company entity.
func (m *CompanyUserMutation) ClearCompany() {
	m.clearedcompany = true
}

// CompanyCleared reports if the "company" edge to the Company entity was cleared.
func (m *CompanyUserMutation) CompanyCleared() bool {
	return m.clearedcompany
}

// CompanyID returns the "company" edge ID in the mutation.
func (m *CompanyUserMutation) CompanyID() (id int, exists bool) {
	if m.company != nil {
		return *m.company, true
	}
	return
}

// CompanyIDs returns the "company" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// CompanyID instead. It exists only for internal usage by the builders.
func (m *CompanyUserMutation) CompanyIDs() (ids []int) {
	if id := m.company; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetCompany resets all changes to the "company" edge.
func (m *CompanyUserMutation) ResetCompany() {
	m.company = nil
	m.clearedcompany = false
}

// Where appends a list predicates to the CompanyUserMutation builder.
func (m *CompanyUserMutation) Where(ps ...predicate.CompanyUser) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the CompanyUserMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *CompanyUserMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.CompanyUser, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *CompanyUserMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *CompanyUserMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (CompanyUser).
func (m *CompanyUserMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *CompanyUserMutation) Fields() []string {
	fields := make([]string, 0, 7)
	if m.created_at != nil {
		fields = append(fields, companyuser.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, companyuser.FieldUpdatedAt)
	}
	if m.last_name != nil {
		fields = append(fields, companyuser.FieldLastName)
	}
	if m.other_name != nil {
		fields = append(fields, companyuser.FieldOtherName)
	}
	if m.phone != nil {
		fields = append(fields, companyuser.FieldPhone)
	}
	if m.other_phone != nil {
		fields = append(fields, companyuser.FieldOtherPhone)
	}
	if m.role != nil {
		fields = append(fields, companyuser.FieldRole)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *CompanyUserMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case companyuser.FieldCreatedAt:
		return m.CreatedAt()
	case companyuser.FieldUpdatedAt:
		return m.UpdatedAt()
	case companyuser.FieldLastName:
		return m.LastName()
	case companyuser.FieldOtherName:
		return m.OtherName()
	case companyuser.FieldPhone:
		return m.Phone()
	case companyuser.FieldOtherPhone:
		return m.OtherPhone()
	case companyuser.FieldRole:
		return m.Role()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *CompanyUserMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case companyuser.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case companyuser.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case companyuser.FieldLastName:
		return m.OldLastName(ctx)
	case companyuser.FieldOtherName:
		return m.OldOtherName(ctx)
	case companyuser.FieldPhone:
		return m.OldPhone(ctx)
	case companyuser.FieldOtherPhone:
		return m.OldOtherPhone(ctx)
	case companyuser.FieldRole:
		return m.OldRole(ctx)
	}
	return nil, fmt.Errorf("unknown CompanyUser field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CompanyUserMutation) SetField(name string, value ent.Value) error {
	switch name {
	case companyuser.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case companyuser.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case companyuser.FieldLastName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLastName(v)
		return nil
	case companyuser.FieldOtherName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOtherName(v)
		return nil
	case companyuser.FieldPhone:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPhone(v)
		return nil
	case companyuser.FieldOtherPhone:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOtherPhone(v)
		return nil
	case companyuser.FieldRole:
		v, ok := value.(companyuser.Role)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRole(v)
		return nil
	}
	return fmt.Errorf("unknown CompanyUser field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *CompanyUserMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *CompanyUserMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CompanyUserMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown CompanyUser numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *CompanyUserMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(companyuser.FieldLastName) {
		fields = append(fields, companyuser.FieldLastName)
	}
	if m.FieldCleared(companyuser.FieldOtherName) {
		fields = append(fields, companyuser.FieldOtherName)
	}
	if m.FieldCleared(companyuser.FieldPhone) {
		fields = append(fields, companyuser.FieldPhone)
	}
	if m.FieldCleared(companyuser.FieldOtherPhone) {
		fields = append(fields, companyuser.FieldOtherPhone)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *CompanyUserMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *CompanyUserMutation) ClearField(name string) error {
	switch name {
	case companyuser.FieldLastName:
		m.ClearLastName()
		return nil
	case companyuser.FieldOtherName:
		m.ClearOtherName()
		return nil
	case companyuser.FieldPhone:
		m.ClearPhone()
		return nil
	case companyuser.FieldOtherPhone:
		m.ClearOtherPhone()
		return nil
	}
	return fmt.Errorf("unknown CompanyUser nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *CompanyUserMutation) ResetField(name string) error {
	switch name {
	case companyuser.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case companyuser.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case companyuser.FieldLastName:
		m.ResetLastName()
		return nil
	case companyuser.FieldOtherName:
		m.ResetOtherName()
		return nil
	case companyuser.FieldPhone:
		m.ResetPhone()
		return nil
	case companyuser.FieldOtherPhone:
		m.ResetOtherPhone()
		return nil
	case companyuser.FieldRole:
		m.ResetRole()
		return nil
	}
	return fmt.Errorf("unknown CompanyUser field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *CompanyUserMutation) AddedEdges() []string {
	edges := make([]string, 0, 6)
	if m.profile != nil {
		edges = append(edges, companyuser.EdgeProfile)
	}
	if m.trips != nil {
		edges = append(edges, companyuser.EdgeTrips)
	}
	if m.incidents != nil {
		edges = append(edges, companyuser.EdgeIncidents)
	}
	if m.parcels != nil {
		edges = append(edges, companyuser.EdgeParcels)
	}
	if m.notifications != nil {
		edges = append(edges, companyuser.EdgeNotifications)
	}
	if m.company != nil {
		edges = append(edges, companyuser.EdgeCompany)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *CompanyUserMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case companyuser.EdgeProfile:
		if id := m.profile; id != nil {
			return []ent.Value{*id}
		}
	case companyuser.EdgeTrips:
		ids := make([]ent.Value, 0, len(m.trips))
		for id := range m.trips {
			ids = append(ids, id)
		}
		return ids
	case companyuser.EdgeIncidents:
		ids := make([]ent.Value, 0, len(m.incidents))
		for id := range m.incidents {
			ids = append(ids, id)
		}
		return ids
	case companyuser.EdgeParcels:
		ids := make([]ent.Value, 0, len(m.parcels))
		for id := range m.parcels {
			ids = append(ids, id)
		}
		return ids
	case companyuser.EdgeNotifications:
		ids := make([]ent.Value, 0, len(m.notifications))
		for id := range m.notifications {
			ids = append(ids, id)
		}
		return ids
	case companyuser.EdgeCompany:
		if id := m.company; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *CompanyUserMutation) RemovedEdges() []string {
	edges := make([]string, 0, 6)
	if m.removedtrips != nil {
		edges = append(edges, companyuser.EdgeTrips)
	}
	if m.removedincidents != nil {
		edges = append(edges, companyuser.EdgeIncidents)
	}
	if m.removedparcels != nil {
		edges = append(edges, companyuser.EdgeParcels)
	}
	if m.removednotifications != nil {
		edges = append(edges, companyuser.EdgeNotifications)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *CompanyUserMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case companyuser.EdgeTrips:
		ids := make([]ent.Value, 0, len(m.removedtrips))
		for id := range m.removedtrips {
			ids = append(ids, id)
		}
		return ids
	case companyuser.EdgeIncidents:
		ids := make([]ent.Value, 0, len(m.removedincidents))
		for id := range m.removedincidents {
			ids = append(ids, id)
		}
		return ids
	case companyuser.EdgeParcels:
		ids := make([]ent.Value, 0, len(m.removedparcels))
		for id := range m.removedparcels {
			ids = append(ids, id)
		}
		return ids
	case companyuser.EdgeNotifications:
		ids := make([]ent.Value, 0, len(m.removednotifications))
		for id := range m.removednotifications {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *CompanyUserMutation) ClearedEdges() []string {
	edges := make([]string, 0, 6)
	if m.clearedprofile {
		edges = append(edges, companyuser.EdgeProfile)
	}
	if m.clearedtrips {
		edges = append(edges, companyuser.EdgeTrips)
	}
	if m.clearedincidents {
		edges = append(edges, companyuser.EdgeIncidents)
	}
	if m.clearedparcels {
		edges = append(edges, companyuser.EdgeParcels)
	}
	if m.clearednotifications {
		edges = append(edges, companyuser.EdgeNotifications)
	}
	if m.clearedcompany {
		edges = append(edges, companyuser.EdgeCompany)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *CompanyUserMutation) EdgeCleared(name string) bool {
	switch name {
	case companyuser.EdgeProfile:
		return m.clearedprofile
	case companyuser.EdgeTrips:
		return m.clearedtrips
	case companyuser.EdgeIncidents:
		return m.clearedincidents
	case companyuser.EdgeParcels:
		return m.clearedparcels
	case companyuser.EdgeNotifications:
		return m.clearednotifications
	case companyuser.EdgeCompany:
		return m.clearedcompany
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *CompanyUserMutation) ClearEdge(name string) error {
	switch name {
	case companyuser.EdgeProfile:
		m.ClearProfile()
		return nil
	case companyuser.EdgeCompany:
		m.ClearCompany()
		return nil
	}
	return fmt.Errorf("unknown CompanyUser unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *CompanyUserMutation) ResetEdge(name string) error {
	switch name {
	case companyuser.EdgeProfile:
		m.ResetProfile()
		return nil
	case companyuser.EdgeTrips:
		m.ResetTrips()
		return nil
	case companyuser.EdgeIncidents:
		m.ResetIncidents()
		return nil
	case companyuser.EdgeParcels:
		m.ResetParcels()
		return nil
	case companyuser.EdgeNotifications:
		m.ResetNotifications()
		return nil
	case companyuser.EdgeCompany:
		m.ResetCompany()
		return nil
	}
	return fmt.Errorf("unknown CompanyUser edge %s", name)
}

// CustomerMutation represents an operation that mutates the Customer nodes in the graph.
type CustomerMutation struct {
	config
	op                   Op
	typ                  string
	id                   *int
	created_at           *time.Time
	updated_at           *time.Time
	last_name            *string
	other_name           *string
	phone                *string
	other_phone          *string
	clearedFields        map[string]struct{}
	profile              *int
	clearedprofile       bool
	bookings             *int
	clearedbookings      bool
	notifications        map[int]struct{}
	removednotifications map[int]struct{}
	clearednotifications bool
	done                 bool
	oldValue             func(context.Context) (*Customer, error)
	predicates           []predicate.Customer
}

var _ ent.Mutation = (*CustomerMutation)(nil)

// customerOption allows management of the mutation configuration using functional options.
type customerOption func(*CustomerMutation)

// newCustomerMutation creates new mutation for the Customer entity.
func newCustomerMutation(c config, op Op, opts ...customerOption) *CustomerMutation {
	m := &CustomerMutation{
		config:        c,
		op:            op,
		typ:           TypeCustomer,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withCustomerID sets the ID field of the mutation.
func withCustomerID(id int) customerOption {
	return func(m *CustomerMutation) {
		var (
			err   error
			once  sync.Once
			value *Customer
		)
		m.oldValue = func(ctx context.Context) (*Customer, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Customer.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withCustomer sets the old Customer of the mutation.
func withCustomer(node *Customer) customerOption {
	return func(m *CustomerMutation) {
		m.oldValue = func(context.Context) (*Customer, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m CustomerMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m CustomerMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *CustomerMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *CustomerMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Customer.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *CustomerMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *CustomerMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Customer entity.
// If the Customer object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CustomerMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *CustomerMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *CustomerMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *CustomerMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Customer entity.
// If the Customer object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CustomerMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *CustomerMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetLastName sets the "last_name" field.
func (m *CustomerMutation) SetLastName(s string) {
	m.last_name = &s
}

// LastName returns the value of the "last_name" field in the mutation.
func (m *CustomerMutation) LastName() (r string, exists bool) {
	v := m.last_name
	if v == nil {
		return
	}
	return *v, true
}

// OldLastName returns the old "last_name" field's value of the Customer entity.
// If the Customer object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CustomerMutation) OldLastName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLastName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLastName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLastName: %w", err)
	}
	return oldValue.LastName, nil
}

// ResetLastName resets all changes to the "last_name" field.
func (m *CustomerMutation) ResetLastName() {
	m.last_name = nil
}

// SetOtherName sets the "other_name" field.
func (m *CustomerMutation) SetOtherName(s string) {
	m.other_name = &s
}

// OtherName returns the value of the "other_name" field in the mutation.
func (m *CustomerMutation) OtherName() (r string, exists bool) {
	v := m.other_name
	if v == nil {
		return
	}
	return *v, true
}

// OldOtherName returns the old "other_name" field's value of the Customer entity.
// If the Customer object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CustomerMutation) OldOtherName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOtherName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOtherName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOtherName: %w", err)
	}
	return oldValue.OtherName, nil
}

// ResetOtherName resets all changes to the "other_name" field.
func (m *CustomerMutation) ResetOtherName() {
	m.other_name = nil
}

// SetPhone sets the "phone" field.
func (m *CustomerMutation) SetPhone(s string) {
	m.phone = &s
}

// Phone returns the value of the "phone" field in the mutation.
func (m *CustomerMutation) Phone() (r string, exists bool) {
	v := m.phone
	if v == nil {
		return
	}
	return *v, true
}

// OldPhone returns the old "phone" field's value of the Customer entity.
// If the Customer object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CustomerMutation) OldPhone(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPhone is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPhone requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPhone: %w", err)
	}
	return oldValue.Phone, nil
}

// ResetPhone resets all changes to the "phone" field.
func (m *CustomerMutation) ResetPhone() {
	m.phone = nil
}

// SetOtherPhone sets the "other_phone" field.
func (m *CustomerMutation) SetOtherPhone(s string) {
	m.other_phone = &s
}

// OtherPhone returns the value of the "other_phone" field in the mutation.
func (m *CustomerMutation) OtherPhone() (r string, exists bool) {
	v := m.other_phone
	if v == nil {
		return
	}
	return *v, true
}

// OldOtherPhone returns the old "other_phone" field's value of the Customer entity.
// If the Customer object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CustomerMutation) OldOtherPhone(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOtherPhone is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOtherPhone requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOtherPhone: %w", err)
	}
	return oldValue.OtherPhone, nil
}

// ClearOtherPhone clears the value of the "other_phone" field.
func (m *CustomerMutation) ClearOtherPhone() {
	m.other_phone = nil
	m.clearedFields[customer.FieldOtherPhone] = struct{}{}
}

// OtherPhoneCleared returns if the "other_phone" field was cleared in this mutation.
func (m *CustomerMutation) OtherPhoneCleared() bool {
	_, ok := m.clearedFields[customer.FieldOtherPhone]
	return ok
}

// ResetOtherPhone resets all changes to the "other_phone" field.
func (m *CustomerMutation) ResetOtherPhone() {
	m.other_phone = nil
	delete(m.clearedFields, customer.FieldOtherPhone)
}

// SetProfileID sets the "profile" edge to the User entity by id.
func (m *CustomerMutation) SetProfileID(id int) {
	m.profile = &id
}

// ClearProfile clears the "profile" edge to the User entity.
func (m *CustomerMutation) ClearProfile() {
	m.clearedprofile = true
}

// ProfileCleared reports if the "profile" edge to the User entity was cleared.
func (m *CustomerMutation) ProfileCleared() bool {
	return m.clearedprofile
}

// ProfileID returns the "profile" edge ID in the mutation.
func (m *CustomerMutation) ProfileID() (id int, exists bool) {
	if m.profile != nil {
		return *m.profile, true
	}
	return
}

// ProfileIDs returns the "profile" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ProfileID instead. It exists only for internal usage by the builders.
func (m *CustomerMutation) ProfileIDs() (ids []int) {
	if id := m.profile; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetProfile resets all changes to the "profile" edge.
func (m *CustomerMutation) ResetProfile() {
	m.profile = nil
	m.clearedprofile = false
}

// SetBookingsID sets the "bookings" edge to the Booking entity by id.
func (m *CustomerMutation) SetBookingsID(id int) {
	m.bookings = &id
}

// ClearBookings clears the "bookings" edge to the Booking entity.
func (m *CustomerMutation) ClearBookings() {
	m.clearedbookings = true
}

// BookingsCleared reports if the "bookings" edge to the Booking entity was cleared.
func (m *CustomerMutation) BookingsCleared() bool {
	return m.clearedbookings
}

// BookingsID returns the "bookings" edge ID in the mutation.
func (m *CustomerMutation) BookingsID() (id int, exists bool) {
	if m.bookings != nil {
		return *m.bookings, true
	}
	return
}

// BookingsIDs returns the "bookings" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// BookingsID instead. It exists only for internal usage by the builders.
func (m *CustomerMutation) BookingsIDs() (ids []int) {
	if id := m.bookings; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetBookings resets all changes to the "bookings" edge.
func (m *CustomerMutation) ResetBookings() {
	m.bookings = nil
	m.clearedbookings = false
}

// AddNotificationIDs adds the "notifications" edge to the Notification entity by ids.
func (m *CustomerMutation) AddNotificationIDs(ids ...int) {
	if m.notifications == nil {
		m.notifications = make(map[int]struct{})
	}
	for i := range ids {
		m.notifications[ids[i]] = struct{}{}
	}
}

// ClearNotifications clears the "notifications" edge to the Notification entity.
func (m *CustomerMutation) ClearNotifications() {
	m.clearednotifications = true
}

// NotificationsCleared reports if the "notifications" edge to the Notification entity was cleared.
func (m *CustomerMutation) NotificationsCleared() bool {
	return m.clearednotifications
}

// RemoveNotificationIDs removes the "notifications" edge to the Notification entity by IDs.
func (m *CustomerMutation) RemoveNotificationIDs(ids ...int) {
	if m.removednotifications == nil {
		m.removednotifications = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.notifications, ids[i])
		m.removednotifications[ids[i]] = struct{}{}
	}
}

// RemovedNotifications returns the removed IDs of the "notifications" edge to the Notification entity.
func (m *CustomerMutation) RemovedNotificationsIDs() (ids []int) {
	for id := range m.removednotifications {
		ids = append(ids, id)
	}
	return
}

// NotificationsIDs returns the "notifications" edge IDs in the mutation.
func (m *CustomerMutation) NotificationsIDs() (ids []int) {
	for id := range m.notifications {
		ids = append(ids, id)
	}
	return
}

// ResetNotifications resets all changes to the "notifications" edge.
func (m *CustomerMutation) ResetNotifications() {
	m.notifications = nil
	m.clearednotifications = false
	m.removednotifications = nil
}

// Where appends a list predicates to the CustomerMutation builder.
func (m *CustomerMutation) Where(ps ...predicate.Customer) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the CustomerMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *CustomerMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Customer, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *CustomerMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *CustomerMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Customer).
func (m *CustomerMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *CustomerMutation) Fields() []string {
	fields := make([]string, 0, 6)
	if m.created_at != nil {
		fields = append(fields, customer.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, customer.FieldUpdatedAt)
	}
	if m.last_name != nil {
		fields = append(fields, customer.FieldLastName)
	}
	if m.other_name != nil {
		fields = append(fields, customer.FieldOtherName)
	}
	if m.phone != nil {
		fields = append(fields, customer.FieldPhone)
	}
	if m.other_phone != nil {
		fields = append(fields, customer.FieldOtherPhone)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *CustomerMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case customer.FieldCreatedAt:
		return m.CreatedAt()
	case customer.FieldUpdatedAt:
		return m.UpdatedAt()
	case customer.FieldLastName:
		return m.LastName()
	case customer.FieldOtherName:
		return m.OtherName()
	case customer.FieldPhone:
		return m.Phone()
	case customer.FieldOtherPhone:
		return m.OtherPhone()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *CustomerMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case customer.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case customer.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case customer.FieldLastName:
		return m.OldLastName(ctx)
	case customer.FieldOtherName:
		return m.OldOtherName(ctx)
	case customer.FieldPhone:
		return m.OldPhone(ctx)
	case customer.FieldOtherPhone:
		return m.OldOtherPhone(ctx)
	}
	return nil, fmt.Errorf("unknown Customer field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CustomerMutation) SetField(name string, value ent.Value) error {
	switch name {
	case customer.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case customer.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case customer.FieldLastName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLastName(v)
		return nil
	case customer.FieldOtherName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOtherName(v)
		return nil
	case customer.FieldPhone:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPhone(v)
		return nil
	case customer.FieldOtherPhone:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOtherPhone(v)
		return nil
	}
	return fmt.Errorf("unknown Customer field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *CustomerMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *CustomerMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CustomerMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Customer numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *CustomerMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(customer.FieldOtherPhone) {
		fields = append(fields, customer.FieldOtherPhone)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *CustomerMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *CustomerMutation) ClearField(name string) error {
	switch name {
	case customer.FieldOtherPhone:
		m.ClearOtherPhone()
		return nil
	}
	return fmt.Errorf("unknown Customer nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *CustomerMutation) ResetField(name string) error {
	switch name {
	case customer.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case customer.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case customer.FieldLastName:
		m.ResetLastName()
		return nil
	case customer.FieldOtherName:
		m.ResetOtherName()
		return nil
	case customer.FieldPhone:
		m.ResetPhone()
		return nil
	case customer.FieldOtherPhone:
		m.ResetOtherPhone()
		return nil
	}
	return fmt.Errorf("unknown Customer field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *CustomerMutation) AddedEdges() []string {
	edges := make([]string, 0, 3)
	if m.profile != nil {
		edges = append(edges, customer.EdgeProfile)
	}
	if m.bookings != nil {
		edges = append(edges, customer.EdgeBookings)
	}
	if m.notifications != nil {
		edges = append(edges, customer.EdgeNotifications)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *CustomerMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case customer.EdgeProfile:
		if id := m.profile; id != nil {
			return []ent.Value{*id}
		}
	case customer.EdgeBookings:
		if id := m.bookings; id != nil {
			return []ent.Value{*id}
		}
	case customer.EdgeNotifications:
		ids := make([]ent.Value, 0, len(m.notifications))
		for id := range m.notifications {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *CustomerMutation) RemovedEdges() []string {
	edges := make([]string, 0, 3)
	if m.removednotifications != nil {
		edges = append(edges, customer.EdgeNotifications)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *CustomerMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case customer.EdgeNotifications:
		ids := make([]ent.Value, 0, len(m.removednotifications))
		for id := range m.removednotifications {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *CustomerMutation) ClearedEdges() []string {
	edges := make([]string, 0, 3)
	if m.clearedprofile {
		edges = append(edges, customer.EdgeProfile)
	}
	if m.clearedbookings {
		edges = append(edges, customer.EdgeBookings)
	}
	if m.clearednotifications {
		edges = append(edges, customer.EdgeNotifications)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *CustomerMutation) EdgeCleared(name string) bool {
	switch name {
	case customer.EdgeProfile:
		return m.clearedprofile
	case customer.EdgeBookings:
		return m.clearedbookings
	case customer.EdgeNotifications:
		return m.clearednotifications
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *CustomerMutation) ClearEdge(name string) error {
	switch name {
	case customer.EdgeProfile:
		m.ClearProfile()
		return nil
	case customer.EdgeBookings:
		m.ClearBookings()
		return nil
	}
	return fmt.Errorf("unknown Customer unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *CustomerMutation) ResetEdge(name string) error {
	switch name {
	case customer.EdgeProfile:
		m.ResetProfile()
		return nil
	case customer.EdgeBookings:
		m.ResetBookings()
		return nil
	case customer.EdgeNotifications:
		m.ResetNotifications()
		return nil
	}
	return fmt.Errorf("unknown Customer edge %s", name)
}

// CustomerContactMutation represents an operation that mutates the CustomerContact nodes in the graph.
type CustomerContactMutation struct {
	config
	op             Op
	typ            string
	id             *int
	created_at     *time.Time
	updated_at     *time.Time
	full_name      *string
	email          *string
	phone          *string
	clearedFields  map[string]struct{}
	booking        *int
	clearedbooking bool
	done           bool
	oldValue       func(context.Context) (*CustomerContact, error)
	predicates     []predicate.CustomerContact
}

var _ ent.Mutation = (*CustomerContactMutation)(nil)

// customercontactOption allows management of the mutation configuration using functional options.
type customercontactOption func(*CustomerContactMutation)

// newCustomerContactMutation creates new mutation for the CustomerContact entity.
func newCustomerContactMutation(c config, op Op, opts ...customercontactOption) *CustomerContactMutation {
	m := &CustomerContactMutation{
		config:        c,
		op:            op,
		typ:           TypeCustomerContact,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withCustomerContactID sets the ID field of the mutation.
func withCustomerContactID(id int) customercontactOption {
	return func(m *CustomerContactMutation) {
		var (
			err   error
			once  sync.Once
			value *CustomerContact
		)
		m.oldValue = func(ctx context.Context) (*CustomerContact, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().CustomerContact.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withCustomerContact sets the old CustomerContact of the mutation.
func withCustomerContact(node *CustomerContact) customercontactOption {
	return func(m *CustomerContactMutation) {
		m.oldValue = func(context.Context) (*CustomerContact, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m CustomerContactMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m CustomerContactMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *CustomerContactMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *CustomerContactMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().CustomerContact.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *CustomerContactMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *CustomerContactMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the CustomerContact entity.
// If the CustomerContact object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CustomerContactMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *CustomerContactMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *CustomerContactMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *CustomerContactMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the CustomerContact entity.
// If the CustomerContact object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CustomerContactMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *CustomerContactMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetFullName sets the "full_name" field.
func (m *CustomerContactMutation) SetFullName(s string) {
	m.full_name = &s
}

// FullName returns the value of the "full_name" field in the mutation.
func (m *CustomerContactMutation) FullName() (r string, exists bool) {
	v := m.full_name
	if v == nil {
		return
	}
	return *v, true
}

// OldFullName returns the old "full_name" field's value of the CustomerContact entity.
// If the CustomerContact object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CustomerContactMutation) OldFullName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFullName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFullName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFullName: %w", err)
	}
	return oldValue.FullName, nil
}

// ResetFullName resets all changes to the "full_name" field.
func (m *CustomerContactMutation) ResetFullName() {
	m.full_name = nil
}

// SetEmail sets the "email" field.
func (m *CustomerContactMutation) SetEmail(s string) {
	m.email = &s
}

// Email returns the value of the "email" field in the mutation.
func (m *CustomerContactMutation) Email() (r string, exists bool) {
	v := m.email
	if v == nil {
		return
	}
	return *v, true
}

// OldEmail returns the old "email" field's value of the CustomerContact entity.
// If the CustomerContact object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CustomerContactMutation) OldEmail(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEmail is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEmail requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEmail: %w", err)
	}
	return oldValue.Email, nil
}

// ResetEmail resets all changes to the "email" field.
func (m *CustomerContactMutation) ResetEmail() {
	m.email = nil
}

// SetPhone sets the "phone" field.
func (m *CustomerContactMutation) SetPhone(s string) {
	m.phone = &s
}

// Phone returns the value of the "phone" field in the mutation.
func (m *CustomerContactMutation) Phone() (r string, exists bool) {
	v := m.phone
	if v == nil {
		return
	}
	return *v, true
}

// OldPhone returns the old "phone" field's value of the CustomerContact entity.
// If the CustomerContact object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CustomerContactMutation) OldPhone(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPhone is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPhone requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPhone: %w", err)
	}
	return oldValue.Phone, nil
}

// ResetPhone resets all changes to the "phone" field.
func (m *CustomerContactMutation) ResetPhone() {
	m.phone = nil
}

// SetBookingID sets the "booking" edge to the Booking entity by id.
func (m *CustomerContactMutation) SetBookingID(id int) {
	m.booking = &id
}

// ClearBooking clears the "booking" edge to the Booking entity.
func (m *CustomerContactMutation) ClearBooking() {
	m.clearedbooking = true
}

// BookingCleared reports if the "booking" edge to the Booking entity was cleared.
func (m *CustomerContactMutation) BookingCleared() bool {
	return m.clearedbooking
}

// BookingID returns the "booking" edge ID in the mutation.
func (m *CustomerContactMutation) BookingID() (id int, exists bool) {
	if m.booking != nil {
		return *m.booking, true
	}
	return
}

// BookingIDs returns the "booking" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// BookingID instead. It exists only for internal usage by the builders.
func (m *CustomerContactMutation) BookingIDs() (ids []int) {
	if id := m.booking; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetBooking resets all changes to the "booking" edge.
func (m *CustomerContactMutation) ResetBooking() {
	m.booking = nil
	m.clearedbooking = false
}

// Where appends a list predicates to the CustomerContactMutation builder.
func (m *CustomerContactMutation) Where(ps ...predicate.CustomerContact) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the CustomerContactMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *CustomerContactMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.CustomerContact, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *CustomerContactMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *CustomerContactMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (CustomerContact).
func (m *CustomerContactMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *CustomerContactMutation) Fields() []string {
	fields := make([]string, 0, 5)
	if m.created_at != nil {
		fields = append(fields, customercontact.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, customercontact.FieldUpdatedAt)
	}
	if m.full_name != nil {
		fields = append(fields, customercontact.FieldFullName)
	}
	if m.email != nil {
		fields = append(fields, customercontact.FieldEmail)
	}
	if m.phone != nil {
		fields = append(fields, customercontact.FieldPhone)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *CustomerContactMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case customercontact.FieldCreatedAt:
		return m.CreatedAt()
	case customercontact.FieldUpdatedAt:
		return m.UpdatedAt()
	case customercontact.FieldFullName:
		return m.FullName()
	case customercontact.FieldEmail:
		return m.Email()
	case customercontact.FieldPhone:
		return m.Phone()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *CustomerContactMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case customercontact.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case customercontact.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case customercontact.FieldFullName:
		return m.OldFullName(ctx)
	case customercontact.FieldEmail:
		return m.OldEmail(ctx)
	case customercontact.FieldPhone:
		return m.OldPhone(ctx)
	}
	return nil, fmt.Errorf("unknown CustomerContact field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CustomerContactMutation) SetField(name string, value ent.Value) error {
	switch name {
	case customercontact.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case customercontact.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case customercontact.FieldFullName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFullName(v)
		return nil
	case customercontact.FieldEmail:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEmail(v)
		return nil
	case customercontact.FieldPhone:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPhone(v)
		return nil
	}
	return fmt.Errorf("unknown CustomerContact field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *CustomerContactMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *CustomerContactMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CustomerContactMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown CustomerContact numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *CustomerContactMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *CustomerContactMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *CustomerContactMutation) ClearField(name string) error {
	return fmt.Errorf("unknown CustomerContact nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *CustomerContactMutation) ResetField(name string) error {
	switch name {
	case customercontact.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case customercontact.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case customercontact.FieldFullName:
		m.ResetFullName()
		return nil
	case customercontact.FieldEmail:
		m.ResetEmail()
		return nil
	case customercontact.FieldPhone:
		m.ResetPhone()
		return nil
	}
	return fmt.Errorf("unknown CustomerContact field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *CustomerContactMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.booking != nil {
		edges = append(edges, customercontact.EdgeBooking)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *CustomerContactMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case customercontact.EdgeBooking:
		if id := m.booking; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *CustomerContactMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *CustomerContactMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *CustomerContactMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedbooking {
		edges = append(edges, customercontact.EdgeBooking)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *CustomerContactMutation) EdgeCleared(name string) bool {
	switch name {
	case customercontact.EdgeBooking:
		return m.clearedbooking
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *CustomerContactMutation) ClearEdge(name string) error {
	switch name {
	case customercontact.EdgeBooking:
		m.ClearBooking()
		return nil
	}
	return fmt.Errorf("unknown CustomerContact unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *CustomerContactMutation) ResetEdge(name string) error {
	switch name {
	case customercontact.EdgeBooking:
		m.ResetBooking()
		return nil
	}
	return fmt.Errorf("unknown CustomerContact edge %s", name)
}

// CustomerLuggageMutation represents an operation that mutates the CustomerLuggage nodes in the graph.
type CustomerLuggageMutation struct {
	config
	op             Op
	typ            string
	id             *int
	created_at     *time.Time
	updated_at     *time.Time
	baggage        *customerluggage.Baggage
	quantity       *int
	addquantity    *int
	amount         *float64
	addamount      *float64
	clearedFields  map[string]struct{}
	booking        *int
	clearedbooking bool
	done           bool
	oldValue       func(context.Context) (*CustomerLuggage, error)
	predicates     []predicate.CustomerLuggage
}

var _ ent.Mutation = (*CustomerLuggageMutation)(nil)

// customerluggageOption allows management of the mutation configuration using functional options.
type customerluggageOption func(*CustomerLuggageMutation)

// newCustomerLuggageMutation creates new mutation for the CustomerLuggage entity.
func newCustomerLuggageMutation(c config, op Op, opts ...customerluggageOption) *CustomerLuggageMutation {
	m := &CustomerLuggageMutation{
		config:        c,
		op:            op,
		typ:           TypeCustomerLuggage,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withCustomerLuggageID sets the ID field of the mutation.
func withCustomerLuggageID(id int) customerluggageOption {
	return func(m *CustomerLuggageMutation) {
		var (
			err   error
			once  sync.Once
			value *CustomerLuggage
		)
		m.oldValue = func(ctx context.Context) (*CustomerLuggage, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().CustomerLuggage.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withCustomerLuggage sets the old CustomerLuggage of the mutation.
func withCustomerLuggage(node *CustomerLuggage) customerluggageOption {
	return func(m *CustomerLuggageMutation) {
		m.oldValue = func(context.Context) (*CustomerLuggage, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m CustomerLuggageMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m CustomerLuggageMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *CustomerLuggageMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *CustomerLuggageMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().CustomerLuggage.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *CustomerLuggageMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *CustomerLuggageMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the CustomerLuggage entity.
// If the CustomerLuggage object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CustomerLuggageMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *CustomerLuggageMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *CustomerLuggageMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *CustomerLuggageMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the CustomerLuggage entity.
// If the CustomerLuggage object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CustomerLuggageMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *CustomerLuggageMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetBaggage sets the "baggage" field.
func (m *CustomerLuggageMutation) SetBaggage(c customerluggage.Baggage) {
	m.baggage = &c
}

// Baggage returns the value of the "baggage" field in the mutation.
func (m *CustomerLuggageMutation) Baggage() (r customerluggage.Baggage, exists bool) {
	v := m.baggage
	if v == nil {
		return
	}
	return *v, true
}

// OldBaggage returns the old "baggage" field's value of the CustomerLuggage entity.
// If the CustomerLuggage object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CustomerLuggageMutation) OldBaggage(ctx context.Context) (v customerluggage.Baggage, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBaggage is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBaggage requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBaggage: %w", err)
	}
	return oldValue.Baggage, nil
}

// ClearBaggage clears the value of the "baggage" field.
func (m *CustomerLuggageMutation) ClearBaggage() {
	m.baggage = nil
	m.clearedFields[customerluggage.FieldBaggage] = struct{}{}
}

// BaggageCleared returns if the "baggage" field was cleared in this mutation.
func (m *CustomerLuggageMutation) BaggageCleared() bool {
	_, ok := m.clearedFields[customerluggage.FieldBaggage]
	return ok
}

// ResetBaggage resets all changes to the "baggage" field.
func (m *CustomerLuggageMutation) ResetBaggage() {
	m.baggage = nil
	delete(m.clearedFields, customerluggage.FieldBaggage)
}

// SetQuantity sets the "quantity" field.
func (m *CustomerLuggageMutation) SetQuantity(i int) {
	m.quantity = &i
	m.addquantity = nil
}

// Quantity returns the value of the "quantity" field in the mutation.
func (m *CustomerLuggageMutation) Quantity() (r int, exists bool) {
	v := m.quantity
	if v == nil {
		return
	}
	return *v, true
}

// OldQuantity returns the old "quantity" field's value of the CustomerLuggage entity.
// If the CustomerLuggage object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CustomerLuggageMutation) OldQuantity(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldQuantity is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldQuantity requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldQuantity: %w", err)
	}
	return oldValue.Quantity, nil
}

// AddQuantity adds i to the "quantity" field.
func (m *CustomerLuggageMutation) AddQuantity(i int) {
	if m.addquantity != nil {
		*m.addquantity += i
	} else {
		m.addquantity = &i
	}
}

// AddedQuantity returns the value that was added to the "quantity" field in this mutation.
func (m *CustomerLuggageMutation) AddedQuantity() (r int, exists bool) {
	v := m.addquantity
	if v == nil {
		return
	}
	return *v, true
}

// ResetQuantity resets all changes to the "quantity" field.
func (m *CustomerLuggageMutation) ResetQuantity() {
	m.quantity = nil
	m.addquantity = nil
}

// SetAmount sets the "amount" field.
func (m *CustomerLuggageMutation) SetAmount(f float64) {
	m.amount = &f
	m.addamount = nil
}

// Amount returns the value of the "amount" field in the mutation.
func (m *CustomerLuggageMutation) Amount() (r float64, exists bool) {
	v := m.amount
	if v == nil {
		return
	}
	return *v, true
}

// OldAmount returns the old "amount" field's value of the CustomerLuggage entity.
// If the CustomerLuggage object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CustomerLuggageMutation) OldAmount(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAmount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAmount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAmount: %w", err)
	}
	return oldValue.Amount, nil
}

// AddAmount adds f to the "amount" field.
func (m *CustomerLuggageMutation) AddAmount(f float64) {
	if m.addamount != nil {
		*m.addamount += f
	} else {
		m.addamount = &f
	}
}

// AddedAmount returns the value that was added to the "amount" field in this mutation.
func (m *CustomerLuggageMutation) AddedAmount() (r float64, exists bool) {
	v := m.addamount
	if v == nil {
		return
	}
	return *v, true
}

// ResetAmount resets all changes to the "amount" field.
func (m *CustomerLuggageMutation) ResetAmount() {
	m.amount = nil
	m.addamount = nil
}

// SetBookingID sets the "booking" edge to the Booking entity by id.
func (m *CustomerLuggageMutation) SetBookingID(id int) {
	m.booking = &id
}

// ClearBooking clears the "booking" edge to the Booking entity.
func (m *CustomerLuggageMutation) ClearBooking() {
	m.clearedbooking = true
}

// BookingCleared reports if the "booking" edge to the Booking entity was cleared.
func (m *CustomerLuggageMutation) BookingCleared() bool {
	return m.clearedbooking
}

// BookingID returns the "booking" edge ID in the mutation.
func (m *CustomerLuggageMutation) BookingID() (id int, exists bool) {
	if m.booking != nil {
		return *m.booking, true
	}
	return
}

// BookingIDs returns the "booking" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// BookingID instead. It exists only for internal usage by the builders.
func (m *CustomerLuggageMutation) BookingIDs() (ids []int) {
	if id := m.booking; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetBooking resets all changes to the "booking" edge.
func (m *CustomerLuggageMutation) ResetBooking() {
	m.booking = nil
	m.clearedbooking = false
}

// Where appends a list predicates to the CustomerLuggageMutation builder.
func (m *CustomerLuggageMutation) Where(ps ...predicate.CustomerLuggage) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the CustomerLuggageMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *CustomerLuggageMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.CustomerLuggage, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *CustomerLuggageMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *CustomerLuggageMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (CustomerLuggage).
func (m *CustomerLuggageMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *CustomerLuggageMutation) Fields() []string {
	fields := make([]string, 0, 5)
	if m.created_at != nil {
		fields = append(fields, customerluggage.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, customerluggage.FieldUpdatedAt)
	}
	if m.baggage != nil {
		fields = append(fields, customerluggage.FieldBaggage)
	}
	if m.quantity != nil {
		fields = append(fields, customerluggage.FieldQuantity)
	}
	if m.amount != nil {
		fields = append(fields, customerluggage.FieldAmount)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *CustomerLuggageMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case customerluggage.FieldCreatedAt:
		return m.CreatedAt()
	case customerluggage.FieldUpdatedAt:
		return m.UpdatedAt()
	case customerluggage.FieldBaggage:
		return m.Baggage()
	case customerluggage.FieldQuantity:
		return m.Quantity()
	case customerluggage.FieldAmount:
		return m.Amount()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *CustomerLuggageMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case customerluggage.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case customerluggage.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case customerluggage.FieldBaggage:
		return m.OldBaggage(ctx)
	case customerluggage.FieldQuantity:
		return m.OldQuantity(ctx)
	case customerluggage.FieldAmount:
		return m.OldAmount(ctx)
	}
	return nil, fmt.Errorf("unknown CustomerLuggage field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CustomerLuggageMutation) SetField(name string, value ent.Value) error {
	switch name {
	case customerluggage.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case customerluggage.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case customerluggage.FieldBaggage:
		v, ok := value.(customerluggage.Baggage)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBaggage(v)
		return nil
	case customerluggage.FieldQuantity:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetQuantity(v)
		return nil
	case customerluggage.FieldAmount:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAmount(v)
		return nil
	}
	return fmt.Errorf("unknown CustomerLuggage field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *CustomerLuggageMutation) AddedFields() []string {
	var fields []string
	if m.addquantity != nil {
		fields = append(fields, customerluggage.FieldQuantity)
	}
	if m.addamount != nil {
		fields = append(fields, customerluggage.FieldAmount)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *CustomerLuggageMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case customerluggage.FieldQuantity:
		return m.AddedQuantity()
	case customerluggage.FieldAmount:
		return m.AddedAmount()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CustomerLuggageMutation) AddField(name string, value ent.Value) error {
	switch name {
	case customerluggage.FieldQuantity:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddQuantity(v)
		return nil
	case customerluggage.FieldAmount:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddAmount(v)
		return nil
	}
	return fmt.Errorf("unknown CustomerLuggage numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *CustomerLuggageMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(customerluggage.FieldBaggage) {
		fields = append(fields, customerluggage.FieldBaggage)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *CustomerLuggageMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *CustomerLuggageMutation) ClearField(name string) error {
	switch name {
	case customerluggage.FieldBaggage:
		m.ClearBaggage()
		return nil
	}
	return fmt.Errorf("unknown CustomerLuggage nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *CustomerLuggageMutation) ResetField(name string) error {
	switch name {
	case customerluggage.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case customerluggage.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case customerluggage.FieldBaggage:
		m.ResetBaggage()
		return nil
	case customerluggage.FieldQuantity:
		m.ResetQuantity()
		return nil
	case customerluggage.FieldAmount:
		m.ResetAmount()
		return nil
	}
	return fmt.Errorf("unknown CustomerLuggage field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *CustomerLuggageMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.booking != nil {
		edges = append(edges, customerluggage.EdgeBooking)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *CustomerLuggageMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case customerluggage.EdgeBooking:
		if id := m.booking; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *CustomerLuggageMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *CustomerLuggageMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *CustomerLuggageMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedbooking {
		edges = append(edges, customerluggage.EdgeBooking)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *CustomerLuggageMutation) EdgeCleared(name string) bool {
	switch name {
	case customerluggage.EdgeBooking:
		return m.clearedbooking
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *CustomerLuggageMutation) ClearEdge(name string) error {
	switch name {
	case customerluggage.EdgeBooking:
		m.ClearBooking()
		return nil
	}
	return fmt.Errorf("unknown CustomerLuggage unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *CustomerLuggageMutation) ResetEdge(name string) error {
	switch name {
	case customerluggage.EdgeBooking:
		m.ResetBooking()
		return nil
	}
	return fmt.Errorf("unknown CustomerLuggage edge %s", name)
}

// IncidentMutation represents an operation that mutates the Incident nodes in the graph.
type IncidentMutation struct {
	config
	op             Op
	typ            string
	id             *int
	created_at     *time.Time
	updated_at     *time.Time
	time           *time.Time
	location       *string
	description    *string
	_type          *string
	audio          *string
	status         *incident.Status
	clearedFields  map[string]struct{}
	images         map[int]struct{}
	removedimages  map[int]struct{}
	clearedimages  bool
	trip           *int
	clearedtrip    bool
	company        *int
	clearedcompany bool
	_driver        *int
	cleared_driver bool
	done           bool
	oldValue       func(context.Context) (*Incident, error)
	predicates     []predicate.Incident
}

var _ ent.Mutation = (*IncidentMutation)(nil)

// incidentOption allows management of the mutation configuration using functional options.
type incidentOption func(*IncidentMutation)

// newIncidentMutation creates new mutation for the Incident entity.
func newIncidentMutation(c config, op Op, opts ...incidentOption) *IncidentMutation {
	m := &IncidentMutation{
		config:        c,
		op:            op,
		typ:           TypeIncident,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withIncidentID sets the ID field of the mutation.
func withIncidentID(id int) incidentOption {
	return func(m *IncidentMutation) {
		var (
			err   error
			once  sync.Once
			value *Incident
		)
		m.oldValue = func(ctx context.Context) (*Incident, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Incident.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withIncident sets the old Incident of the mutation.
func withIncident(node *Incident) incidentOption {
	return func(m *IncidentMutation) {
		m.oldValue = func(context.Context) (*Incident, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m IncidentMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m IncidentMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *IncidentMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *IncidentMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Incident.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *IncidentMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *IncidentMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Incident entity.
// If the Incident object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *IncidentMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *IncidentMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *IncidentMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *IncidentMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Incident entity.
// If the Incident object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *IncidentMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *IncidentMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetTime sets the "time" field.
func (m *IncidentMutation) SetTime(t time.Time) {
	m.time = &t
}

// Time returns the value of the "time" field in the mutation.
func (m *IncidentMutation) Time() (r time.Time, exists bool) {
	v := m.time
	if v == nil {
		return
	}
	return *v, true
}

// OldTime returns the old "time" field's value of the Incident entity.
// If the Incident object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *IncidentMutation) OldTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTime: %w", err)
	}
	return oldValue.Time, nil
}

// ClearTime clears the value of the "time" field.
func (m *IncidentMutation) ClearTime() {
	m.time = nil
	m.clearedFields[incident.FieldTime] = struct{}{}
}

// TimeCleared returns if the "time" field was cleared in this mutation.
func (m *IncidentMutation) TimeCleared() bool {
	_, ok := m.clearedFields[incident.FieldTime]
	return ok
}

// ResetTime resets all changes to the "time" field.
func (m *IncidentMutation) ResetTime() {
	m.time = nil
	delete(m.clearedFields, incident.FieldTime)
}

// SetLocation sets the "location" field.
func (m *IncidentMutation) SetLocation(s string) {
	m.location = &s
}

// Location returns the value of the "location" field in the mutation.
func (m *IncidentMutation) Location() (r string, exists bool) {
	v := m.location
	if v == nil {
		return
	}
	return *v, true
}

// OldLocation returns the old "location" field's value of the Incident entity.
// If the Incident object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *IncidentMutation) OldLocation(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLocation is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLocation requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLocation: %w", err)
	}
	return oldValue.Location, nil
}

// ResetLocation resets all changes to the "location" field.
func (m *IncidentMutation) ResetLocation() {
	m.location = nil
}

// SetDescription sets the "description" field.
func (m *IncidentMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *IncidentMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the Incident entity.
// If the Incident object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *IncidentMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ResetDescription resets all changes to the "description" field.
func (m *IncidentMutation) ResetDescription() {
	m.description = nil
}

// SetType sets the "type" field.
func (m *IncidentMutation) SetType(s string) {
	m._type = &s
}

// GetType returns the value of the "type" field in the mutation.
func (m *IncidentMutation) GetType() (r string, exists bool) {
	v := m._type
	if v == nil {
		return
	}
	return *v, true
}

// OldType returns the old "type" field's value of the Incident entity.
// If the Incident object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *IncidentMutation) OldType(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldType: %w", err)
	}
	return oldValue.Type, nil
}

// ResetType resets all changes to the "type" field.
func (m *IncidentMutation) ResetType() {
	m._type = nil
}

// SetAudio sets the "audio" field.
func (m *IncidentMutation) SetAudio(s string) {
	m.audio = &s
}

// Audio returns the value of the "audio" field in the mutation.
func (m *IncidentMutation) Audio() (r string, exists bool) {
	v := m.audio
	if v == nil {
		return
	}
	return *v, true
}

// OldAudio returns the old "audio" field's value of the Incident entity.
// If the Incident object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *IncidentMutation) OldAudio(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAudio is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAudio requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAudio: %w", err)
	}
	return oldValue.Audio, nil
}

// ClearAudio clears the value of the "audio" field.
func (m *IncidentMutation) ClearAudio() {
	m.audio = nil
	m.clearedFields[incident.FieldAudio] = struct{}{}
}

// AudioCleared returns if the "audio" field was cleared in this mutation.
func (m *IncidentMutation) AudioCleared() bool {
	_, ok := m.clearedFields[incident.FieldAudio]
	return ok
}

// ResetAudio resets all changes to the "audio" field.
func (m *IncidentMutation) ResetAudio() {
	m.audio = nil
	delete(m.clearedFields, incident.FieldAudio)
}

// SetStatus sets the "status" field.
func (m *IncidentMutation) SetStatus(i incident.Status) {
	m.status = &i
}

// Status returns the value of the "status" field in the mutation.
func (m *IncidentMutation) Status() (r incident.Status, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the Incident entity.
// If the Incident object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *IncidentMutation) OldStatus(ctx context.Context) (v incident.Status, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ResetStatus resets all changes to the "status" field.
func (m *IncidentMutation) ResetStatus() {
	m.status = nil
}

// AddImageIDs adds the "images" edge to the IncidentImage entity by ids.
func (m *IncidentMutation) AddImageIDs(ids ...int) {
	if m.images == nil {
		m.images = make(map[int]struct{})
	}
	for i := range ids {
		m.images[ids[i]] = struct{}{}
	}
}

// ClearImages clears the "images" edge to the IncidentImage entity.
func (m *IncidentMutation) ClearImages() {
	m.clearedimages = true
}

// ImagesCleared reports if the "images" edge to the IncidentImage entity was cleared.
func (m *IncidentMutation) ImagesCleared() bool {
	return m.clearedimages
}

// RemoveImageIDs removes the "images" edge to the IncidentImage entity by IDs.
func (m *IncidentMutation) RemoveImageIDs(ids ...int) {
	if m.removedimages == nil {
		m.removedimages = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.images, ids[i])
		m.removedimages[ids[i]] = struct{}{}
	}
}

// RemovedImages returns the removed IDs of the "images" edge to the IncidentImage entity.
func (m *IncidentMutation) RemovedImagesIDs() (ids []int) {
	for id := range m.removedimages {
		ids = append(ids, id)
	}
	return
}

// ImagesIDs returns the "images" edge IDs in the mutation.
func (m *IncidentMutation) ImagesIDs() (ids []int) {
	for id := range m.images {
		ids = append(ids, id)
	}
	return
}

// ResetImages resets all changes to the "images" edge.
func (m *IncidentMutation) ResetImages() {
	m.images = nil
	m.clearedimages = false
	m.removedimages = nil
}

// SetTripID sets the "trip" edge to the Trip entity by id.
func (m *IncidentMutation) SetTripID(id int) {
	m.trip = &id
}

// ClearTrip clears the "trip" edge to the Trip entity.
func (m *IncidentMutation) ClearTrip() {
	m.clearedtrip = true
}

// TripCleared reports if the "trip" edge to the Trip entity was cleared.
func (m *IncidentMutation) TripCleared() bool {
	return m.clearedtrip
}

// TripID returns the "trip" edge ID in the mutation.
func (m *IncidentMutation) TripID() (id int, exists bool) {
	if m.trip != nil {
		return *m.trip, true
	}
	return
}

// TripIDs returns the "trip" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// TripID instead. It exists only for internal usage by the builders.
func (m *IncidentMutation) TripIDs() (ids []int) {
	if id := m.trip; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetTrip resets all changes to the "trip" edge.
func (m *IncidentMutation) ResetTrip() {
	m.trip = nil
	m.clearedtrip = false
}

// SetCompanyID sets the "company" edge to the Company entity by id.
func (m *IncidentMutation) SetCompanyID(id int) {
	m.company = &id
}

// ClearCompany clears the "company" edge to the Company entity.
func (m *IncidentMutation) ClearCompany() {
	m.clearedcompany = true
}

// CompanyCleared reports if the "company" edge to the Company entity was cleared.
func (m *IncidentMutation) CompanyCleared() bool {
	return m.clearedcompany
}

// CompanyID returns the "company" edge ID in the mutation.
func (m *IncidentMutation) CompanyID() (id int, exists bool) {
	if m.company != nil {
		return *m.company, true
	}
	return
}

// CompanyIDs returns the "company" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// CompanyID instead. It exists only for internal usage by the builders.
func (m *IncidentMutation) CompanyIDs() (ids []int) {
	if id := m.company; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetCompany resets all changes to the "company" edge.
func (m *IncidentMutation) ResetCompany() {
	m.company = nil
	m.clearedcompany = false
}

// SetDriverID sets the "driver" edge to the CompanyUser entity by id.
func (m *IncidentMutation) SetDriverID(id int) {
	m._driver = &id
}

// ClearDriver clears the "driver" edge to the CompanyUser entity.
func (m *IncidentMutation) ClearDriver() {
	m.cleared_driver = true
}

// DriverCleared reports if the "driver" edge to the CompanyUser entity was cleared.
func (m *IncidentMutation) DriverCleared() bool {
	return m.cleared_driver
}

// DriverID returns the "driver" edge ID in the mutation.
func (m *IncidentMutation) DriverID() (id int, exists bool) {
	if m._driver != nil {
		return *m._driver, true
	}
	return
}

// DriverIDs returns the "driver" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// DriverID instead. It exists only for internal usage by the builders.
func (m *IncidentMutation) DriverIDs() (ids []int) {
	if id := m._driver; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetDriver resets all changes to the "driver" edge.
func (m *IncidentMutation) ResetDriver() {
	m._driver = nil
	m.cleared_driver = false
}

// Where appends a list predicates to the IncidentMutation builder.
func (m *IncidentMutation) Where(ps ...predicate.Incident) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the IncidentMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *IncidentMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Incident, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *IncidentMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *IncidentMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Incident).
func (m *IncidentMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *IncidentMutation) Fields() []string {
	fields := make([]string, 0, 8)
	if m.created_at != nil {
		fields = append(fields, incident.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, incident.FieldUpdatedAt)
	}
	if m.time != nil {
		fields = append(fields, incident.FieldTime)
	}
	if m.location != nil {
		fields = append(fields, incident.FieldLocation)
	}
	if m.description != nil {
		fields = append(fields, incident.FieldDescription)
	}
	if m._type != nil {
		fields = append(fields, incident.FieldType)
	}
	if m.audio != nil {
		fields = append(fields, incident.FieldAudio)
	}
	if m.status != nil {
		fields = append(fields, incident.FieldStatus)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *IncidentMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case incident.FieldCreatedAt:
		return m.CreatedAt()
	case incident.FieldUpdatedAt:
		return m.UpdatedAt()
	case incident.FieldTime:
		return m.Time()
	case incident.FieldLocation:
		return m.Location()
	case incident.FieldDescription:
		return m.Description()
	case incident.FieldType:
		return m.GetType()
	case incident.FieldAudio:
		return m.Audio()
	case incident.FieldStatus:
		return m.Status()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *IncidentMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case incident.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case incident.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case incident.FieldTime:
		return m.OldTime(ctx)
	case incident.FieldLocation:
		return m.OldLocation(ctx)
	case incident.FieldDescription:
		return m.OldDescription(ctx)
	case incident.FieldType:
		return m.OldType(ctx)
	case incident.FieldAudio:
		return m.OldAudio(ctx)
	case incident.FieldStatus:
		return m.OldStatus(ctx)
	}
	return nil, fmt.Errorf("unknown Incident field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *IncidentMutation) SetField(name string, value ent.Value) error {
	switch name {
	case incident.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case incident.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case incident.FieldTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTime(v)
		return nil
	case incident.FieldLocation:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLocation(v)
		return nil
	case incident.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case incident.FieldType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetType(v)
		return nil
	case incident.FieldAudio:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAudio(v)
		return nil
	case incident.FieldStatus:
		v, ok := value.(incident.Status)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	}
	return fmt.Errorf("unknown Incident field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *IncidentMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *IncidentMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *IncidentMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Incident numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *IncidentMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(incident.FieldTime) {
		fields = append(fields, incident.FieldTime)
	}
	if m.FieldCleared(incident.FieldAudio) {
		fields = append(fields, incident.FieldAudio)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *IncidentMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *IncidentMutation) ClearField(name string) error {
	switch name {
	case incident.FieldTime:
		m.ClearTime()
		return nil
	case incident.FieldAudio:
		m.ClearAudio()
		return nil
	}
	return fmt.Errorf("unknown Incident nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *IncidentMutation) ResetField(name string) error {
	switch name {
	case incident.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case incident.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case incident.FieldTime:
		m.ResetTime()
		return nil
	case incident.FieldLocation:
		m.ResetLocation()
		return nil
	case incident.FieldDescription:
		m.ResetDescription()
		return nil
	case incident.FieldType:
		m.ResetType()
		return nil
	case incident.FieldAudio:
		m.ResetAudio()
		return nil
	case incident.FieldStatus:
		m.ResetStatus()
		return nil
	}
	return fmt.Errorf("unknown Incident field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *IncidentMutation) AddedEdges() []string {
	edges := make([]string, 0, 4)
	if m.images != nil {
		edges = append(edges, incident.EdgeImages)
	}
	if m.trip != nil {
		edges = append(edges, incident.EdgeTrip)
	}
	if m.company != nil {
		edges = append(edges, incident.EdgeCompany)
	}
	if m._driver != nil {
		edges = append(edges, incident.EdgeDriver)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *IncidentMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case incident.EdgeImages:
		ids := make([]ent.Value, 0, len(m.images))
		for id := range m.images {
			ids = append(ids, id)
		}
		return ids
	case incident.EdgeTrip:
		if id := m.trip; id != nil {
			return []ent.Value{*id}
		}
	case incident.EdgeCompany:
		if id := m.company; id != nil {
			return []ent.Value{*id}
		}
	case incident.EdgeDriver:
		if id := m._driver; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *IncidentMutation) RemovedEdges() []string {
	edges := make([]string, 0, 4)
	if m.removedimages != nil {
		edges = append(edges, incident.EdgeImages)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *IncidentMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case incident.EdgeImages:
		ids := make([]ent.Value, 0, len(m.removedimages))
		for id := range m.removedimages {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *IncidentMutation) ClearedEdges() []string {
	edges := make([]string, 0, 4)
	if m.clearedimages {
		edges = append(edges, incident.EdgeImages)
	}
	if m.clearedtrip {
		edges = append(edges, incident.EdgeTrip)
	}
	if m.clearedcompany {
		edges = append(edges, incident.EdgeCompany)
	}
	if m.cleared_driver {
		edges = append(edges, incident.EdgeDriver)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *IncidentMutation) EdgeCleared(name string) bool {
	switch name {
	case incident.EdgeImages:
		return m.clearedimages
	case incident.EdgeTrip:
		return m.clearedtrip
	case incident.EdgeCompany:
		return m.clearedcompany
	case incident.EdgeDriver:
		return m.cleared_driver
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *IncidentMutation) ClearEdge(name string) error {
	switch name {
	case incident.EdgeTrip:
		m.ClearTrip()
		return nil
	case incident.EdgeCompany:
		m.ClearCompany()
		return nil
	case incident.EdgeDriver:
		m.ClearDriver()
		return nil
	}
	return fmt.Errorf("unknown Incident unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *IncidentMutation) ResetEdge(name string) error {
	switch name {
	case incident.EdgeImages:
		m.ResetImages()
		return nil
	case incident.EdgeTrip:
		m.ResetTrip()
		return nil
	case incident.EdgeCompany:
		m.ResetCompany()
		return nil
	case incident.EdgeDriver:
		m.ResetDriver()
		return nil
	}
	return fmt.Errorf("unknown Incident edge %s", name)
}

// IncidentImageMutation represents an operation that mutates the IncidentImage nodes in the graph.
type IncidentImageMutation struct {
	config
	op              Op
	typ             string
	id              *int
	created_at      *time.Time
	updated_at      *time.Time
	image           *string
	clearedFields   map[string]struct{}
	incident        *int
	clearedincident bool
	done            bool
	oldValue        func(context.Context) (*IncidentImage, error)
	predicates      []predicate.IncidentImage
}

var _ ent.Mutation = (*IncidentImageMutation)(nil)

// incidentimageOption allows management of the mutation configuration using functional options.
type incidentimageOption func(*IncidentImageMutation)

// newIncidentImageMutation creates new mutation for the IncidentImage entity.
func newIncidentImageMutation(c config, op Op, opts ...incidentimageOption) *IncidentImageMutation {
	m := &IncidentImageMutation{
		config:        c,
		op:            op,
		typ:           TypeIncidentImage,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withIncidentImageID sets the ID field of the mutation.
func withIncidentImageID(id int) incidentimageOption {
	return func(m *IncidentImageMutation) {
		var (
			err   error
			once  sync.Once
			value *IncidentImage
		)
		m.oldValue = func(ctx context.Context) (*IncidentImage, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().IncidentImage.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withIncidentImage sets the old IncidentImage of the mutation.
func withIncidentImage(node *IncidentImage) incidentimageOption {
	return func(m *IncidentImageMutation) {
		m.oldValue = func(context.Context) (*IncidentImage, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m IncidentImageMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m IncidentImageMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *IncidentImageMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *IncidentImageMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().IncidentImage.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *IncidentImageMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *IncidentImageMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the IncidentImage entity.
// If the IncidentImage object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *IncidentImageMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *IncidentImageMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *IncidentImageMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *IncidentImageMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the IncidentImage entity.
// If the IncidentImage object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *IncidentImageMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *IncidentImageMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetImage sets the "image" field.
func (m *IncidentImageMutation) SetImage(s string) {
	m.image = &s
}

// Image returns the value of the "image" field in the mutation.
func (m *IncidentImageMutation) Image() (r string, exists bool) {
	v := m.image
	if v == nil {
		return
	}
	return *v, true
}

// OldImage returns the old "image" field's value of the IncidentImage entity.
// If the IncidentImage object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *IncidentImageMutation) OldImage(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldImage is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldImage requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldImage: %w", err)
	}
	return oldValue.Image, nil
}

// ClearImage clears the value of the "image" field.
func (m *IncidentImageMutation) ClearImage() {
	m.image = nil
	m.clearedFields[incidentimage.FieldImage] = struct{}{}
}

// ImageCleared returns if the "image" field was cleared in this mutation.
func (m *IncidentImageMutation) ImageCleared() bool {
	_, ok := m.clearedFields[incidentimage.FieldImage]
	return ok
}

// ResetImage resets all changes to the "image" field.
func (m *IncidentImageMutation) ResetImage() {
	m.image = nil
	delete(m.clearedFields, incidentimage.FieldImage)
}

// SetIncidentID sets the "incident" edge to the Incident entity by id.
func (m *IncidentImageMutation) SetIncidentID(id int) {
	m.incident = &id
}

// ClearIncident clears the "incident" edge to the Incident entity.
func (m *IncidentImageMutation) ClearIncident() {
	m.clearedincident = true
}

// IncidentCleared reports if the "incident" edge to the Incident entity was cleared.
func (m *IncidentImageMutation) IncidentCleared() bool {
	return m.clearedincident
}

// IncidentID returns the "incident" edge ID in the mutation.
func (m *IncidentImageMutation) IncidentID() (id int, exists bool) {
	if m.incident != nil {
		return *m.incident, true
	}
	return
}

// IncidentIDs returns the "incident" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// IncidentID instead. It exists only for internal usage by the builders.
func (m *IncidentImageMutation) IncidentIDs() (ids []int) {
	if id := m.incident; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetIncident resets all changes to the "incident" edge.
func (m *IncidentImageMutation) ResetIncident() {
	m.incident = nil
	m.clearedincident = false
}

// Where appends a list predicates to the IncidentImageMutation builder.
func (m *IncidentImageMutation) Where(ps ...predicate.IncidentImage) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the IncidentImageMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *IncidentImageMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.IncidentImage, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *IncidentImageMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *IncidentImageMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (IncidentImage).
func (m *IncidentImageMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *IncidentImageMutation) Fields() []string {
	fields := make([]string, 0, 3)
	if m.created_at != nil {
		fields = append(fields, incidentimage.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, incidentimage.FieldUpdatedAt)
	}
	if m.image != nil {
		fields = append(fields, incidentimage.FieldImage)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *IncidentImageMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case incidentimage.FieldCreatedAt:
		return m.CreatedAt()
	case incidentimage.FieldUpdatedAt:
		return m.UpdatedAt()
	case incidentimage.FieldImage:
		return m.Image()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *IncidentImageMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case incidentimage.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case incidentimage.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case incidentimage.FieldImage:
		return m.OldImage(ctx)
	}
	return nil, fmt.Errorf("unknown IncidentImage field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *IncidentImageMutation) SetField(name string, value ent.Value) error {
	switch name {
	case incidentimage.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case incidentimage.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case incidentimage.FieldImage:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetImage(v)
		return nil
	}
	return fmt.Errorf("unknown IncidentImage field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *IncidentImageMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *IncidentImageMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *IncidentImageMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown IncidentImage numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *IncidentImageMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(incidentimage.FieldImage) {
		fields = append(fields, incidentimage.FieldImage)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *IncidentImageMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *IncidentImageMutation) ClearField(name string) error {
	switch name {
	case incidentimage.FieldImage:
		m.ClearImage()
		return nil
	}
	return fmt.Errorf("unknown IncidentImage nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *IncidentImageMutation) ResetField(name string) error {
	switch name {
	case incidentimage.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case incidentimage.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case incidentimage.FieldImage:
		m.ResetImage()
		return nil
	}
	return fmt.Errorf("unknown IncidentImage field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *IncidentImageMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.incident != nil {
		edges = append(edges, incidentimage.EdgeIncident)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *IncidentImageMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case incidentimage.EdgeIncident:
		if id := m.incident; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *IncidentImageMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *IncidentImageMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *IncidentImageMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedincident {
		edges = append(edges, incidentimage.EdgeIncident)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *IncidentImageMutation) EdgeCleared(name string) bool {
	switch name {
	case incidentimage.EdgeIncident:
		return m.clearedincident
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *IncidentImageMutation) ClearEdge(name string) error {
	switch name {
	case incidentimage.EdgeIncident:
		m.ClearIncident()
		return nil
	}
	return fmt.Errorf("unknown IncidentImage unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *IncidentImageMutation) ResetEdge(name string) error {
	switch name {
	case incidentimage.EdgeIncident:
		m.ResetIncident()
		return nil
	}
	return fmt.Errorf("unknown IncidentImage edge %s", name)
}

// NotificationMutation represents an operation that mutates the Notification nodes in the graph.
type NotificationMutation struct {
	config
	op                     Op
	typ                    string
	id                     *int
	event                  *string
	activity               *string
	description            *string
	subject_type           *string
	subject_id             *int
	addsubject_id          *int
	creator_type           *string
	creator_id             *int
	addcreator_id          *int
	customer_read_at       *string
	bookibus_read_at       *[]*schema.NotificationRead
	appendbookibus_read_at []*schema.NotificationRead
	company_read_at        *[]*schema.NotificationRead
	appendcompany_read_at  []*schema.NotificationRead
	data                   **struct {
		Data interface{} "json:\"data\""
	}
	clearedFields        map[string]struct{}
	bookibus_user        map[int]struct{}
	removedbookibus_user map[int]struct{}
	clearedbookibus_user bool
	company_user         map[int]struct{}
	removedcompany_user  map[int]struct{}
	clearedcompany_user  bool
	customer             map[int]struct{}
	removedcustomer      map[int]struct{}
	clearedcustomer      bool
	company              *int
	clearedcompany       bool
	done                 bool
	oldValue             func(context.Context) (*Notification, error)
	predicates           []predicate.Notification
}

var _ ent.Mutation = (*NotificationMutation)(nil)

// notificationOption allows management of the mutation configuration using functional options.
type notificationOption func(*NotificationMutation)

// newNotificationMutation creates new mutation for the Notification entity.
func newNotificationMutation(c config, op Op, opts ...notificationOption) *NotificationMutation {
	m := &NotificationMutation{
		config:        c,
		op:            op,
		typ:           TypeNotification,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withNotificationID sets the ID field of the mutation.
func withNotificationID(id int) notificationOption {
	return func(m *NotificationMutation) {
		var (
			err   error
			once  sync.Once
			value *Notification
		)
		m.oldValue = func(ctx context.Context) (*Notification, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Notification.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withNotification sets the old Notification of the mutation.
func withNotification(node *Notification) notificationOption {
	return func(m *NotificationMutation) {
		m.oldValue = func(context.Context) (*Notification, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m NotificationMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m NotificationMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *NotificationMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *NotificationMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Notification.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetEvent sets the "event" field.
func (m *NotificationMutation) SetEvent(s string) {
	m.event = &s
}

// Event returns the value of the "event" field in the mutation.
func (m *NotificationMutation) Event() (r string, exists bool) {
	v := m.event
	if v == nil {
		return
	}
	return *v, true
}

// OldEvent returns the old "event" field's value of the Notification entity.
// If the Notification object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NotificationMutation) OldEvent(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEvent is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEvent requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEvent: %w", err)
	}
	return oldValue.Event, nil
}

// ResetEvent resets all changes to the "event" field.
func (m *NotificationMutation) ResetEvent() {
	m.event = nil
}

// SetActivity sets the "activity" field.
func (m *NotificationMutation) SetActivity(s string) {
	m.activity = &s
}

// Activity returns the value of the "activity" field in the mutation.
func (m *NotificationMutation) Activity() (r string, exists bool) {
	v := m.activity
	if v == nil {
		return
	}
	return *v, true
}

// OldActivity returns the old "activity" field's value of the Notification entity.
// If the Notification object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NotificationMutation) OldActivity(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldActivity is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldActivity requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldActivity: %w", err)
	}
	return oldValue.Activity, nil
}

// ResetActivity resets all changes to the "activity" field.
func (m *NotificationMutation) ResetActivity() {
	m.activity = nil
}

// SetDescription sets the "description" field.
func (m *NotificationMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *NotificationMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the Notification entity.
// If the Notification object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NotificationMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ResetDescription resets all changes to the "description" field.
func (m *NotificationMutation) ResetDescription() {
	m.description = nil
}

// SetSubjectType sets the "subject_type" field.
func (m *NotificationMutation) SetSubjectType(s string) {
	m.subject_type = &s
}

// SubjectType returns the value of the "subject_type" field in the mutation.
func (m *NotificationMutation) SubjectType() (r string, exists bool) {
	v := m.subject_type
	if v == nil {
		return
	}
	return *v, true
}

// OldSubjectType returns the old "subject_type" field's value of the Notification entity.
// If the Notification object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NotificationMutation) OldSubjectType(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSubjectType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSubjectType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSubjectType: %w", err)
	}
	return oldValue.SubjectType, nil
}

// ResetSubjectType resets all changes to the "subject_type" field.
func (m *NotificationMutation) ResetSubjectType() {
	m.subject_type = nil
}

// SetSubjectID sets the "subject_id" field.
func (m *NotificationMutation) SetSubjectID(i int) {
	m.subject_id = &i
	m.addsubject_id = nil
}

// SubjectID returns the value of the "subject_id" field in the mutation.
func (m *NotificationMutation) SubjectID() (r int, exists bool) {
	v := m.subject_id
	if v == nil {
		return
	}
	return *v, true
}

// OldSubjectID returns the old "subject_id" field's value of the Notification entity.
// If the Notification object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NotificationMutation) OldSubjectID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSubjectID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSubjectID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSubjectID: %w", err)
	}
	return oldValue.SubjectID, nil
}

// AddSubjectID adds i to the "subject_id" field.
func (m *NotificationMutation) AddSubjectID(i int) {
	if m.addsubject_id != nil {
		*m.addsubject_id += i
	} else {
		m.addsubject_id = &i
	}
}

// AddedSubjectID returns the value that was added to the "subject_id" field in this mutation.
func (m *NotificationMutation) AddedSubjectID() (r int, exists bool) {
	v := m.addsubject_id
	if v == nil {
		return
	}
	return *v, true
}

// ClearSubjectID clears the value of the "subject_id" field.
func (m *NotificationMutation) ClearSubjectID() {
	m.subject_id = nil
	m.addsubject_id = nil
	m.clearedFields[notification.FieldSubjectID] = struct{}{}
}

// SubjectIDCleared returns if the "subject_id" field was cleared in this mutation.
func (m *NotificationMutation) SubjectIDCleared() bool {
	_, ok := m.clearedFields[notification.FieldSubjectID]
	return ok
}

// ResetSubjectID resets all changes to the "subject_id" field.
func (m *NotificationMutation) ResetSubjectID() {
	m.subject_id = nil
	m.addsubject_id = nil
	delete(m.clearedFields, notification.FieldSubjectID)
}

// SetCreatorType sets the "creator_type" field.
func (m *NotificationMutation) SetCreatorType(s string) {
	m.creator_type = &s
}

// CreatorType returns the value of the "creator_type" field in the mutation.
func (m *NotificationMutation) CreatorType() (r string, exists bool) {
	v := m.creator_type
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatorType returns the old "creator_type" field's value of the Notification entity.
// If the Notification object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NotificationMutation) OldCreatorType(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatorType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatorType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatorType: %w", err)
	}
	return oldValue.CreatorType, nil
}

// ResetCreatorType resets all changes to the "creator_type" field.
func (m *NotificationMutation) ResetCreatorType() {
	m.creator_type = nil
}

// SetCreatorID sets the "creator_id" field.
func (m *NotificationMutation) SetCreatorID(i int) {
	m.creator_id = &i
	m.addcreator_id = nil
}

// CreatorID returns the value of the "creator_id" field in the mutation.
func (m *NotificationMutation) CreatorID() (r int, exists bool) {
	v := m.creator_id
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatorID returns the old "creator_id" field's value of the Notification entity.
// If the Notification object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NotificationMutation) OldCreatorID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatorID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatorID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatorID: %w", err)
	}
	return oldValue.CreatorID, nil
}

// AddCreatorID adds i to the "creator_id" field.
func (m *NotificationMutation) AddCreatorID(i int) {
	if m.addcreator_id != nil {
		*m.addcreator_id += i
	} else {
		m.addcreator_id = &i
	}
}

// AddedCreatorID returns the value that was added to the "creator_id" field in this mutation.
func (m *NotificationMutation) AddedCreatorID() (r int, exists bool) {
	v := m.addcreator_id
	if v == nil {
		return
	}
	return *v, true
}

// ClearCreatorID clears the value of the "creator_id" field.
func (m *NotificationMutation) ClearCreatorID() {
	m.creator_id = nil
	m.addcreator_id = nil
	m.clearedFields[notification.FieldCreatorID] = struct{}{}
}

// CreatorIDCleared returns if the "creator_id" field was cleared in this mutation.
func (m *NotificationMutation) CreatorIDCleared() bool {
	_, ok := m.clearedFields[notification.FieldCreatorID]
	return ok
}

// ResetCreatorID resets all changes to the "creator_id" field.
func (m *NotificationMutation) ResetCreatorID() {
	m.creator_id = nil
	m.addcreator_id = nil
	delete(m.clearedFields, notification.FieldCreatorID)
}

// SetCustomerReadAt sets the "customer_read_at" field.
func (m *NotificationMutation) SetCustomerReadAt(s string) {
	m.customer_read_at = &s
}

// CustomerReadAt returns the value of the "customer_read_at" field in the mutation.
func (m *NotificationMutation) CustomerReadAt() (r string, exists bool) {
	v := m.customer_read_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCustomerReadAt returns the old "customer_read_at" field's value of the Notification entity.
// If the Notification object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NotificationMutation) OldCustomerReadAt(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCustomerReadAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCustomerReadAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCustomerReadAt: %w", err)
	}
	return oldValue.CustomerReadAt, nil
}

// ClearCustomerReadAt clears the value of the "customer_read_at" field.
func (m *NotificationMutation) ClearCustomerReadAt() {
	m.customer_read_at = nil
	m.clearedFields[notification.FieldCustomerReadAt] = struct{}{}
}

// CustomerReadAtCleared returns if the "customer_read_at" field was cleared in this mutation.
func (m *NotificationMutation) CustomerReadAtCleared() bool {
	_, ok := m.clearedFields[notification.FieldCustomerReadAt]
	return ok
}

// ResetCustomerReadAt resets all changes to the "customer_read_at" field.
func (m *NotificationMutation) ResetCustomerReadAt() {
	m.customer_read_at = nil
	delete(m.clearedFields, notification.FieldCustomerReadAt)
}

// SetBookibusReadAt sets the "bookibus_read_at" field.
func (m *NotificationMutation) SetBookibusReadAt(sr []*schema.NotificationRead) {
	m.bookibus_read_at = &sr
	m.appendbookibus_read_at = nil
}

// BookibusReadAt returns the value of the "bookibus_read_at" field in the mutation.
func (m *NotificationMutation) BookibusReadAt() (r []*schema.NotificationRead, exists bool) {
	v := m.bookibus_read_at
	if v == nil {
		return
	}
	return *v, true
}

// OldBookibusReadAt returns the old "bookibus_read_at" field's value of the Notification entity.
// If the Notification object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NotificationMutation) OldBookibusReadAt(ctx context.Context) (v []*schema.NotificationRead, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBookibusReadAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBookibusReadAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBookibusReadAt: %w", err)
	}
	return oldValue.BookibusReadAt, nil
}

// AppendBookibusReadAt adds sr to the "bookibus_read_at" field.
func (m *NotificationMutation) AppendBookibusReadAt(sr []*schema.NotificationRead) {
	m.appendbookibus_read_at = append(m.appendbookibus_read_at, sr...)
}

// AppendedBookibusReadAt returns the list of values that were appended to the "bookibus_read_at" field in this mutation.
func (m *NotificationMutation) AppendedBookibusReadAt() ([]*schema.NotificationRead, bool) {
	if len(m.appendbookibus_read_at) == 0 {
		return nil, false
	}
	return m.appendbookibus_read_at, true
}

// ClearBookibusReadAt clears the value of the "bookibus_read_at" field.
func (m *NotificationMutation) ClearBookibusReadAt() {
	m.bookibus_read_at = nil
	m.appendbookibus_read_at = nil
	m.clearedFields[notification.FieldBookibusReadAt] = struct{}{}
}

// BookibusReadAtCleared returns if the "bookibus_read_at" field was cleared in this mutation.
func (m *NotificationMutation) BookibusReadAtCleared() bool {
	_, ok := m.clearedFields[notification.FieldBookibusReadAt]
	return ok
}

// ResetBookibusReadAt resets all changes to the "bookibus_read_at" field.
func (m *NotificationMutation) ResetBookibusReadAt() {
	m.bookibus_read_at = nil
	m.appendbookibus_read_at = nil
	delete(m.clearedFields, notification.FieldBookibusReadAt)
}

// SetCompanyReadAt sets the "company_read_at" field.
func (m *NotificationMutation) SetCompanyReadAt(sr []*schema.NotificationRead) {
	m.company_read_at = &sr
	m.appendcompany_read_at = nil
}

// CompanyReadAt returns the value of the "company_read_at" field in the mutation.
func (m *NotificationMutation) CompanyReadAt() (r []*schema.NotificationRead, exists bool) {
	v := m.company_read_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCompanyReadAt returns the old "company_read_at" field's value of the Notification entity.
// If the Notification object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NotificationMutation) OldCompanyReadAt(ctx context.Context) (v []*schema.NotificationRead, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCompanyReadAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCompanyReadAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCompanyReadAt: %w", err)
	}
	return oldValue.CompanyReadAt, nil
}

// AppendCompanyReadAt adds sr to the "company_read_at" field.
func (m *NotificationMutation) AppendCompanyReadAt(sr []*schema.NotificationRead) {
	m.appendcompany_read_at = append(m.appendcompany_read_at, sr...)
}

// AppendedCompanyReadAt returns the list of values that were appended to the "company_read_at" field in this mutation.
func (m *NotificationMutation) AppendedCompanyReadAt() ([]*schema.NotificationRead, bool) {
	if len(m.appendcompany_read_at) == 0 {
		return nil, false
	}
	return m.appendcompany_read_at, true
}

// ClearCompanyReadAt clears the value of the "company_read_at" field.
func (m *NotificationMutation) ClearCompanyReadAt() {
	m.company_read_at = nil
	m.appendcompany_read_at = nil
	m.clearedFields[notification.FieldCompanyReadAt] = struct{}{}
}

// CompanyReadAtCleared returns if the "company_read_at" field was cleared in this mutation.
func (m *NotificationMutation) CompanyReadAtCleared() bool {
	_, ok := m.clearedFields[notification.FieldCompanyReadAt]
	return ok
}

// ResetCompanyReadAt resets all changes to the "company_read_at" field.
func (m *NotificationMutation) ResetCompanyReadAt() {
	m.company_read_at = nil
	m.appendcompany_read_at = nil
	delete(m.clearedFields, notification.FieldCompanyReadAt)
}

// SetData sets the "data" field.
func (m *NotificationMutation) SetData(s *struct {
	Data interface{} "json:\"data\""
}) {
	m.data = &s
}

// Data returns the value of the "data" field in the mutation.
func (m *NotificationMutation) Data() (r *struct {
	Data interface{} "json:\"data\""
}, exists bool) {
	v := m.data
	if v == nil {
		return
	}
	return *v, true
}

// OldData returns the old "data" field's value of the Notification entity.
// If the Notification object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NotificationMutation) OldData(ctx context.Context) (v *struct {
	Data interface{} "json:\"data\""
}, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldData is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldData requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldData: %w", err)
	}
	return oldValue.Data, nil
}

// ClearData clears the value of the "data" field.
func (m *NotificationMutation) ClearData() {
	m.data = nil
	m.clearedFields[notification.FieldData] = struct{}{}
}

// DataCleared returns if the "data" field was cleared in this mutation.
func (m *NotificationMutation) DataCleared() bool {
	_, ok := m.clearedFields[notification.FieldData]
	return ok
}

// ResetData resets all changes to the "data" field.
func (m *NotificationMutation) ResetData() {
	m.data = nil
	delete(m.clearedFields, notification.FieldData)
}

// AddBookibusUserIDs adds the "bookibus_user" edge to the BookibusUser entity by ids.
func (m *NotificationMutation) AddBookibusUserIDs(ids ...int) {
	if m.bookibus_user == nil {
		m.bookibus_user = make(map[int]struct{})
	}
	for i := range ids {
		m.bookibus_user[ids[i]] = struct{}{}
	}
}

// ClearBookibusUser clears the "bookibus_user" edge to the BookibusUser entity.
func (m *NotificationMutation) ClearBookibusUser() {
	m.clearedbookibus_user = true
}

// BookibusUserCleared reports if the "bookibus_user" edge to the BookibusUser entity was cleared.
func (m *NotificationMutation) BookibusUserCleared() bool {
	return m.clearedbookibus_user
}

// RemoveBookibusUserIDs removes the "bookibus_user" edge to the BookibusUser entity by IDs.
func (m *NotificationMutation) RemoveBookibusUserIDs(ids ...int) {
	if m.removedbookibus_user == nil {
		m.removedbookibus_user = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.bookibus_user, ids[i])
		m.removedbookibus_user[ids[i]] = struct{}{}
	}
}

// RemovedBookibusUser returns the removed IDs of the "bookibus_user" edge to the BookibusUser entity.
func (m *NotificationMutation) RemovedBookibusUserIDs() (ids []int) {
	for id := range m.removedbookibus_user {
		ids = append(ids, id)
	}
	return
}

// BookibusUserIDs returns the "bookibus_user" edge IDs in the mutation.
func (m *NotificationMutation) BookibusUserIDs() (ids []int) {
	for id := range m.bookibus_user {
		ids = append(ids, id)
	}
	return
}

// ResetBookibusUser resets all changes to the "bookibus_user" edge.
func (m *NotificationMutation) ResetBookibusUser() {
	m.bookibus_user = nil
	m.clearedbookibus_user = false
	m.removedbookibus_user = nil
}

// AddCompanyUserIDs adds the "company_user" edge to the CompanyUser entity by ids.
func (m *NotificationMutation) AddCompanyUserIDs(ids ...int) {
	if m.company_user == nil {
		m.company_user = make(map[int]struct{})
	}
	for i := range ids {
		m.company_user[ids[i]] = struct{}{}
	}
}

// ClearCompanyUser clears the "company_user" edge to the CompanyUser entity.
func (m *NotificationMutation) ClearCompanyUser() {
	m.clearedcompany_user = true
}

// CompanyUserCleared reports if the "company_user" edge to the CompanyUser entity was cleared.
func (m *NotificationMutation) CompanyUserCleared() bool {
	return m.clearedcompany_user
}

// RemoveCompanyUserIDs removes the "company_user" edge to the CompanyUser entity by IDs.
func (m *NotificationMutation) RemoveCompanyUserIDs(ids ...int) {
	if m.removedcompany_user == nil {
		m.removedcompany_user = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.company_user, ids[i])
		m.removedcompany_user[ids[i]] = struct{}{}
	}
}

// RemovedCompanyUser returns the removed IDs of the "company_user" edge to the CompanyUser entity.
func (m *NotificationMutation) RemovedCompanyUserIDs() (ids []int) {
	for id := range m.removedcompany_user {
		ids = append(ids, id)
	}
	return
}

// CompanyUserIDs returns the "company_user" edge IDs in the mutation.
func (m *NotificationMutation) CompanyUserIDs() (ids []int) {
	for id := range m.company_user {
		ids = append(ids, id)
	}
	return
}

// ResetCompanyUser resets all changes to the "company_user" edge.
func (m *NotificationMutation) ResetCompanyUser() {
	m.company_user = nil
	m.clearedcompany_user = false
	m.removedcompany_user = nil
}

// AddCustomerIDs adds the "customer" edge to the Customer entity by ids.
func (m *NotificationMutation) AddCustomerIDs(ids ...int) {
	if m.customer == nil {
		m.customer = make(map[int]struct{})
	}
	for i := range ids {
		m.customer[ids[i]] = struct{}{}
	}
}

// ClearCustomer clears the "customer" edge to the Customer entity.
func (m *NotificationMutation) ClearCustomer() {
	m.clearedcustomer = true
}

// CustomerCleared reports if the "customer" edge to the Customer entity was cleared.
func (m *NotificationMutation) CustomerCleared() bool {
	return m.clearedcustomer
}

// RemoveCustomerIDs removes the "customer" edge to the Customer entity by IDs.
func (m *NotificationMutation) RemoveCustomerIDs(ids ...int) {
	if m.removedcustomer == nil {
		m.removedcustomer = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.customer, ids[i])
		m.removedcustomer[ids[i]] = struct{}{}
	}
}

// RemovedCustomer returns the removed IDs of the "customer" edge to the Customer entity.
func (m *NotificationMutation) RemovedCustomerIDs() (ids []int) {
	for id := range m.removedcustomer {
		ids = append(ids, id)
	}
	return
}

// CustomerIDs returns the "customer" edge IDs in the mutation.
func (m *NotificationMutation) CustomerIDs() (ids []int) {
	for id := range m.customer {
		ids = append(ids, id)
	}
	return
}

// ResetCustomer resets all changes to the "customer" edge.
func (m *NotificationMutation) ResetCustomer() {
	m.customer = nil
	m.clearedcustomer = false
	m.removedcustomer = nil
}

// SetCompanyID sets the "company" edge to the Company entity by id.
func (m *NotificationMutation) SetCompanyID(id int) {
	m.company = &id
}

// ClearCompany clears the "company" edge to the Company entity.
func (m *NotificationMutation) ClearCompany() {
	m.clearedcompany = true
}

// CompanyCleared reports if the "company" edge to the Company entity was cleared.
func (m *NotificationMutation) CompanyCleared() bool {
	return m.clearedcompany
}

// CompanyID returns the "company" edge ID in the mutation.
func (m *NotificationMutation) CompanyID() (id int, exists bool) {
	if m.company != nil {
		return *m.company, true
	}
	return
}

// CompanyIDs returns the "company" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// CompanyID instead. It exists only for internal usage by the builders.
func (m *NotificationMutation) CompanyIDs() (ids []int) {
	if id := m.company; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetCompany resets all changes to the "company" edge.
func (m *NotificationMutation) ResetCompany() {
	m.company = nil
	m.clearedcompany = false
}

// Where appends a list predicates to the NotificationMutation builder.
func (m *NotificationMutation) Where(ps ...predicate.Notification) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the NotificationMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *NotificationMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Notification, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *NotificationMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *NotificationMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Notification).
func (m *NotificationMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *NotificationMutation) Fields() []string {
	fields := make([]string, 0, 11)
	if m.event != nil {
		fields = append(fields, notification.FieldEvent)
	}
	if m.activity != nil {
		fields = append(fields, notification.FieldActivity)
	}
	if m.description != nil {
		fields = append(fields, notification.FieldDescription)
	}
	if m.subject_type != nil {
		fields = append(fields, notification.FieldSubjectType)
	}
	if m.subject_id != nil {
		fields = append(fields, notification.FieldSubjectID)
	}
	if m.creator_type != nil {
		fields = append(fields, notification.FieldCreatorType)
	}
	if m.creator_id != nil {
		fields = append(fields, notification.FieldCreatorID)
	}
	if m.customer_read_at != nil {
		fields = append(fields, notification.FieldCustomerReadAt)
	}
	if m.bookibus_read_at != nil {
		fields = append(fields, notification.FieldBookibusReadAt)
	}
	if m.company_read_at != nil {
		fields = append(fields, notification.FieldCompanyReadAt)
	}
	if m.data != nil {
		fields = append(fields, notification.FieldData)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *NotificationMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case notification.FieldEvent:
		return m.Event()
	case notification.FieldActivity:
		return m.Activity()
	case notification.FieldDescription:
		return m.Description()
	case notification.FieldSubjectType:
		return m.SubjectType()
	case notification.FieldSubjectID:
		return m.SubjectID()
	case notification.FieldCreatorType:
		return m.CreatorType()
	case notification.FieldCreatorID:
		return m.CreatorID()
	case notification.FieldCustomerReadAt:
		return m.CustomerReadAt()
	case notification.FieldBookibusReadAt:
		return m.BookibusReadAt()
	case notification.FieldCompanyReadAt:
		return m.CompanyReadAt()
	case notification.FieldData:
		return m.Data()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *NotificationMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case notification.FieldEvent:
		return m.OldEvent(ctx)
	case notification.FieldActivity:
		return m.OldActivity(ctx)
	case notification.FieldDescription:
		return m.OldDescription(ctx)
	case notification.FieldSubjectType:
		return m.OldSubjectType(ctx)
	case notification.FieldSubjectID:
		return m.OldSubjectID(ctx)
	case notification.FieldCreatorType:
		return m.OldCreatorType(ctx)
	case notification.FieldCreatorID:
		return m.OldCreatorID(ctx)
	case notification.FieldCustomerReadAt:
		return m.OldCustomerReadAt(ctx)
	case notification.FieldBookibusReadAt:
		return m.OldBookibusReadAt(ctx)
	case notification.FieldCompanyReadAt:
		return m.OldCompanyReadAt(ctx)
	case notification.FieldData:
		return m.OldData(ctx)
	}
	return nil, fmt.Errorf("unknown Notification field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *NotificationMutation) SetField(name string, value ent.Value) error {
	switch name {
	case notification.FieldEvent:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEvent(v)
		return nil
	case notification.FieldActivity:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetActivity(v)
		return nil
	case notification.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case notification.FieldSubjectType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSubjectType(v)
		return nil
	case notification.FieldSubjectID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSubjectID(v)
		return nil
	case notification.FieldCreatorType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatorType(v)
		return nil
	case notification.FieldCreatorID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatorID(v)
		return nil
	case notification.FieldCustomerReadAt:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCustomerReadAt(v)
		return nil
	case notification.FieldBookibusReadAt:
		v, ok := value.([]*schema.NotificationRead)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBookibusReadAt(v)
		return nil
	case notification.FieldCompanyReadAt:
		v, ok := value.([]*schema.NotificationRead)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCompanyReadAt(v)
		return nil
	case notification.FieldData:
		v, ok := value.(*struct {
			Data interface{} "json:\"data\""
		})
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetData(v)
		return nil
	}
	return fmt.Errorf("unknown Notification field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *NotificationMutation) AddedFields() []string {
	var fields []string
	if m.addsubject_id != nil {
		fields = append(fields, notification.FieldSubjectID)
	}
	if m.addcreator_id != nil {
		fields = append(fields, notification.FieldCreatorID)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *NotificationMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case notification.FieldSubjectID:
		return m.AddedSubjectID()
	case notification.FieldCreatorID:
		return m.AddedCreatorID()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *NotificationMutation) AddField(name string, value ent.Value) error {
	switch name {
	case notification.FieldSubjectID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddSubjectID(v)
		return nil
	case notification.FieldCreatorID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreatorID(v)
		return nil
	}
	return fmt.Errorf("unknown Notification numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *NotificationMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(notification.FieldSubjectID) {
		fields = append(fields, notification.FieldSubjectID)
	}
	if m.FieldCleared(notification.FieldCreatorID) {
		fields = append(fields, notification.FieldCreatorID)
	}
	if m.FieldCleared(notification.FieldCustomerReadAt) {
		fields = append(fields, notification.FieldCustomerReadAt)
	}
	if m.FieldCleared(notification.FieldBookibusReadAt) {
		fields = append(fields, notification.FieldBookibusReadAt)
	}
	if m.FieldCleared(notification.FieldCompanyReadAt) {
		fields = append(fields, notification.FieldCompanyReadAt)
	}
	if m.FieldCleared(notification.FieldData) {
		fields = append(fields, notification.FieldData)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *NotificationMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *NotificationMutation) ClearField(name string) error {
	switch name {
	case notification.FieldSubjectID:
		m.ClearSubjectID()
		return nil
	case notification.FieldCreatorID:
		m.ClearCreatorID()
		return nil
	case notification.FieldCustomerReadAt:
		m.ClearCustomerReadAt()
		return nil
	case notification.FieldBookibusReadAt:
		m.ClearBookibusReadAt()
		return nil
	case notification.FieldCompanyReadAt:
		m.ClearCompanyReadAt()
		return nil
	case notification.FieldData:
		m.ClearData()
		return nil
	}
	return fmt.Errorf("unknown Notification nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *NotificationMutation) ResetField(name string) error {
	switch name {
	case notification.FieldEvent:
		m.ResetEvent()
		return nil
	case notification.FieldActivity:
		m.ResetActivity()
		return nil
	case notification.FieldDescription:
		m.ResetDescription()
		return nil
	case notification.FieldSubjectType:
		m.ResetSubjectType()
		return nil
	case notification.FieldSubjectID:
		m.ResetSubjectID()
		return nil
	case notification.FieldCreatorType:
		m.ResetCreatorType()
		return nil
	case notification.FieldCreatorID:
		m.ResetCreatorID()
		return nil
	case notification.FieldCustomerReadAt:
		m.ResetCustomerReadAt()
		return nil
	case notification.FieldBookibusReadAt:
		m.ResetBookibusReadAt()
		return nil
	case notification.FieldCompanyReadAt:
		m.ResetCompanyReadAt()
		return nil
	case notification.FieldData:
		m.ResetData()
		return nil
	}
	return fmt.Errorf("unknown Notification field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *NotificationMutation) AddedEdges() []string {
	edges := make([]string, 0, 4)
	if m.bookibus_user != nil {
		edges = append(edges, notification.EdgeBookibusUser)
	}
	if m.company_user != nil {
		edges = append(edges, notification.EdgeCompanyUser)
	}
	if m.customer != nil {
		edges = append(edges, notification.EdgeCustomer)
	}
	if m.company != nil {
		edges = append(edges, notification.EdgeCompany)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *NotificationMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case notification.EdgeBookibusUser:
		ids := make([]ent.Value, 0, len(m.bookibus_user))
		for id := range m.bookibus_user {
			ids = append(ids, id)
		}
		return ids
	case notification.EdgeCompanyUser:
		ids := make([]ent.Value, 0, len(m.company_user))
		for id := range m.company_user {
			ids = append(ids, id)
		}
		return ids
	case notification.EdgeCustomer:
		ids := make([]ent.Value, 0, len(m.customer))
		for id := range m.customer {
			ids = append(ids, id)
		}
		return ids
	case notification.EdgeCompany:
		if id := m.company; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *NotificationMutation) RemovedEdges() []string {
	edges := make([]string, 0, 4)
	if m.removedbookibus_user != nil {
		edges = append(edges, notification.EdgeBookibusUser)
	}
	if m.removedcompany_user != nil {
		edges = append(edges, notification.EdgeCompanyUser)
	}
	if m.removedcustomer != nil {
		edges = append(edges, notification.EdgeCustomer)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *NotificationMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case notification.EdgeBookibusUser:
		ids := make([]ent.Value, 0, len(m.removedbookibus_user))
		for id := range m.removedbookibus_user {
			ids = append(ids, id)
		}
		return ids
	case notification.EdgeCompanyUser:
		ids := make([]ent.Value, 0, len(m.removedcompany_user))
		for id := range m.removedcompany_user {
			ids = append(ids, id)
		}
		return ids
	case notification.EdgeCustomer:
		ids := make([]ent.Value, 0, len(m.removedcustomer))
		for id := range m.removedcustomer {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *NotificationMutation) ClearedEdges() []string {
	edges := make([]string, 0, 4)
	if m.clearedbookibus_user {
		edges = append(edges, notification.EdgeBookibusUser)
	}
	if m.clearedcompany_user {
		edges = append(edges, notification.EdgeCompanyUser)
	}
	if m.clearedcustomer {
		edges = append(edges, notification.EdgeCustomer)
	}
	if m.clearedcompany {
		edges = append(edges, notification.EdgeCompany)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *NotificationMutation) EdgeCleared(name string) bool {
	switch name {
	case notification.EdgeBookibusUser:
		return m.clearedbookibus_user
	case notification.EdgeCompanyUser:
		return m.clearedcompany_user
	case notification.EdgeCustomer:
		return m.clearedcustomer
	case notification.EdgeCompany:
		return m.clearedcompany
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *NotificationMutation) ClearEdge(name string) error {
	switch name {
	case notification.EdgeCompany:
		m.ClearCompany()
		return nil
	}
	return fmt.Errorf("unknown Notification unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *NotificationMutation) ResetEdge(name string) error {
	switch name {
	case notification.EdgeBookibusUser:
		m.ResetBookibusUser()
		return nil
	case notification.EdgeCompanyUser:
		m.ResetCompanyUser()
		return nil
	case notification.EdgeCustomer:
		m.ResetCustomer()
		return nil
	case notification.EdgeCompany:
		m.ResetCompany()
		return nil
	}
	return fmt.Errorf("unknown Notification edge %s", name)
}

// ParcelMutation represents an operation that mutates the Parcel nodes in the graph.
type ParcelMutation struct {
	config
	op                 Op
	typ                string
	id                 *int
	created_at         *time.Time
	updated_at         *time.Time
	parcel_code        *string
	_type              *string
	sender_name        *string
	sender_phone       *string
	sender_email       *string
	recipient_name     *string
	recipient_phone    *string
	recipient_location *string
	weight             *float32
	addweight          *float32
	amount             *float64
	addamount          *float64
	paid_at            *time.Time
	tans_type          *parcel.TansType
	status             *parcel.Status
	clearedFields      map[string]struct{}
	images             map[int]struct{}
	removedimages      map[int]struct{}
	clearedimages      bool
	trip               *int
	clearedtrip        bool
	company            *int
	clearedcompany     bool
	_driver            *int
	cleared_driver     bool
	done               bool
	oldValue           func(context.Context) (*Parcel, error)
	predicates         []predicate.Parcel
}

var _ ent.Mutation = (*ParcelMutation)(nil)

// parcelOption allows management of the mutation configuration using functional options.
type parcelOption func(*ParcelMutation)

// newParcelMutation creates new mutation for the Parcel entity.
func newParcelMutation(c config, op Op, opts ...parcelOption) *ParcelMutation {
	m := &ParcelMutation{
		config:        c,
		op:            op,
		typ:           TypeParcel,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withParcelID sets the ID field of the mutation.
func withParcelID(id int) parcelOption {
	return func(m *ParcelMutation) {
		var (
			err   error
			once  sync.Once
			value *Parcel
		)
		m.oldValue = func(ctx context.Context) (*Parcel, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Parcel.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withParcel sets the old Parcel of the mutation.
func withParcel(node *Parcel) parcelOption {
	return func(m *ParcelMutation) {
		m.oldValue = func(context.Context) (*Parcel, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ParcelMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ParcelMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ParcelMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ParcelMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Parcel.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *ParcelMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *ParcelMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Parcel entity.
// If the Parcel object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ParcelMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *ParcelMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *ParcelMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *ParcelMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Parcel entity.
// If the Parcel object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ParcelMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *ParcelMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetParcelCode sets the "parcel_code" field.
func (m *ParcelMutation) SetParcelCode(s string) {
	m.parcel_code = &s
}

// ParcelCode returns the value of the "parcel_code" field in the mutation.
func (m *ParcelMutation) ParcelCode() (r string, exists bool) {
	v := m.parcel_code
	if v == nil {
		return
	}
	return *v, true
}

// OldParcelCode returns the old "parcel_code" field's value of the Parcel entity.
// If the Parcel object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ParcelMutation) OldParcelCode(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldParcelCode is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldParcelCode requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldParcelCode: %w", err)
	}
	return oldValue.ParcelCode, nil
}

// ResetParcelCode resets all changes to the "parcel_code" field.
func (m *ParcelMutation) ResetParcelCode() {
	m.parcel_code = nil
}

// SetType sets the "type" field.
func (m *ParcelMutation) SetType(s string) {
	m._type = &s
}

// GetType returns the value of the "type" field in the mutation.
func (m *ParcelMutation) GetType() (r string, exists bool) {
	v := m._type
	if v == nil {
		return
	}
	return *v, true
}

// OldType returns the old "type" field's value of the Parcel entity.
// If the Parcel object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ParcelMutation) OldType(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldType: %w", err)
	}
	return oldValue.Type, nil
}

// ResetType resets all changes to the "type" field.
func (m *ParcelMutation) ResetType() {
	m._type = nil
}

// SetSenderName sets the "sender_name" field.
func (m *ParcelMutation) SetSenderName(s string) {
	m.sender_name = &s
}

// SenderName returns the value of the "sender_name" field in the mutation.
func (m *ParcelMutation) SenderName() (r string, exists bool) {
	v := m.sender_name
	if v == nil {
		return
	}
	return *v, true
}

// OldSenderName returns the old "sender_name" field's value of the Parcel entity.
// If the Parcel object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ParcelMutation) OldSenderName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSenderName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSenderName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSenderName: %w", err)
	}
	return oldValue.SenderName, nil
}

// ResetSenderName resets all changes to the "sender_name" field.
func (m *ParcelMutation) ResetSenderName() {
	m.sender_name = nil
}

// SetSenderPhone sets the "sender_phone" field.
func (m *ParcelMutation) SetSenderPhone(s string) {
	m.sender_phone = &s
}

// SenderPhone returns the value of the "sender_phone" field in the mutation.
func (m *ParcelMutation) SenderPhone() (r string, exists bool) {
	v := m.sender_phone
	if v == nil {
		return
	}
	return *v, true
}

// OldSenderPhone returns the old "sender_phone" field's value of the Parcel entity.
// If the Parcel object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ParcelMutation) OldSenderPhone(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSenderPhone is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSenderPhone requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSenderPhone: %w", err)
	}
	return oldValue.SenderPhone, nil
}

// ResetSenderPhone resets all changes to the "sender_phone" field.
func (m *ParcelMutation) ResetSenderPhone() {
	m.sender_phone = nil
}

// SetSenderEmail sets the "sender_email" field.
func (m *ParcelMutation) SetSenderEmail(s string) {
	m.sender_email = &s
}

// SenderEmail returns the value of the "sender_email" field in the mutation.
func (m *ParcelMutation) SenderEmail() (r string, exists bool) {
	v := m.sender_email
	if v == nil {
		return
	}
	return *v, true
}

// OldSenderEmail returns the old "sender_email" field's value of the Parcel entity.
// If the Parcel object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ParcelMutation) OldSenderEmail(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSenderEmail is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSenderEmail requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSenderEmail: %w", err)
	}
	return oldValue.SenderEmail, nil
}

// ResetSenderEmail resets all changes to the "sender_email" field.
func (m *ParcelMutation) ResetSenderEmail() {
	m.sender_email = nil
}

// SetRecipientName sets the "recipient_name" field.
func (m *ParcelMutation) SetRecipientName(s string) {
	m.recipient_name = &s
}

// RecipientName returns the value of the "recipient_name" field in the mutation.
func (m *ParcelMutation) RecipientName() (r string, exists bool) {
	v := m.recipient_name
	if v == nil {
		return
	}
	return *v, true
}

// OldRecipientName returns the old "recipient_name" field's value of the Parcel entity.
// If the Parcel object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ParcelMutation) OldRecipientName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRecipientName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRecipientName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRecipientName: %w", err)
	}
	return oldValue.RecipientName, nil
}

// ResetRecipientName resets all changes to the "recipient_name" field.
func (m *ParcelMutation) ResetRecipientName() {
	m.recipient_name = nil
}

// SetRecipientPhone sets the "recipient_phone" field.
func (m *ParcelMutation) SetRecipientPhone(s string) {
	m.recipient_phone = &s
}

// RecipientPhone returns the value of the "recipient_phone" field in the mutation.
func (m *ParcelMutation) RecipientPhone() (r string, exists bool) {
	v := m.recipient_phone
	if v == nil {
		return
	}
	return *v, true
}

// OldRecipientPhone returns the old "recipient_phone" field's value of the Parcel entity.
// If the Parcel object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ParcelMutation) OldRecipientPhone(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRecipientPhone is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRecipientPhone requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRecipientPhone: %w", err)
	}
	return oldValue.RecipientPhone, nil
}

// ResetRecipientPhone resets all changes to the "recipient_phone" field.
func (m *ParcelMutation) ResetRecipientPhone() {
	m.recipient_phone = nil
}

// SetRecipientLocation sets the "recipient_location" field.
func (m *ParcelMutation) SetRecipientLocation(s string) {
	m.recipient_location = &s
}

// RecipientLocation returns the value of the "recipient_location" field in the mutation.
func (m *ParcelMutation) RecipientLocation() (r string, exists bool) {
	v := m.recipient_location
	if v == nil {
		return
	}
	return *v, true
}

// OldRecipientLocation returns the old "recipient_location" field's value of the Parcel entity.
// If the Parcel object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ParcelMutation) OldRecipientLocation(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRecipientLocation is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRecipientLocation requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRecipientLocation: %w", err)
	}
	return oldValue.RecipientLocation, nil
}

// ResetRecipientLocation resets all changes to the "recipient_location" field.
func (m *ParcelMutation) ResetRecipientLocation() {
	m.recipient_location = nil
}

// SetWeight sets the "weight" field.
func (m *ParcelMutation) SetWeight(f float32) {
	m.weight = &f
	m.addweight = nil
}

// Weight returns the value of the "weight" field in the mutation.
func (m *ParcelMutation) Weight() (r float32, exists bool) {
	v := m.weight
	if v == nil {
		return
	}
	return *v, true
}

// OldWeight returns the old "weight" field's value of the Parcel entity.
// If the Parcel object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ParcelMutation) OldWeight(ctx context.Context) (v float32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldWeight is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldWeight requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldWeight: %w", err)
	}
	return oldValue.Weight, nil
}

// AddWeight adds f to the "weight" field.
func (m *ParcelMutation) AddWeight(f float32) {
	if m.addweight != nil {
		*m.addweight += f
	} else {
		m.addweight = &f
	}
}

// AddedWeight returns the value that was added to the "weight" field in this mutation.
func (m *ParcelMutation) AddedWeight() (r float32, exists bool) {
	v := m.addweight
	if v == nil {
		return
	}
	return *v, true
}

// ClearWeight clears the value of the "weight" field.
func (m *ParcelMutation) ClearWeight() {
	m.weight = nil
	m.addweight = nil
	m.clearedFields[parcel.FieldWeight] = struct{}{}
}

// WeightCleared returns if the "weight" field was cleared in this mutation.
func (m *ParcelMutation) WeightCleared() bool {
	_, ok := m.clearedFields[parcel.FieldWeight]
	return ok
}

// ResetWeight resets all changes to the "weight" field.
func (m *ParcelMutation) ResetWeight() {
	m.weight = nil
	m.addweight = nil
	delete(m.clearedFields, parcel.FieldWeight)
}

// SetAmount sets the "amount" field.
func (m *ParcelMutation) SetAmount(f float64) {
	m.amount = &f
	m.addamount = nil
}

// Amount returns the value of the "amount" field in the mutation.
func (m *ParcelMutation) Amount() (r float64, exists bool) {
	v := m.amount
	if v == nil {
		return
	}
	return *v, true
}

// OldAmount returns the old "amount" field's value of the Parcel entity.
// If the Parcel object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ParcelMutation) OldAmount(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAmount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAmount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAmount: %w", err)
	}
	return oldValue.Amount, nil
}

// AddAmount adds f to the "amount" field.
func (m *ParcelMutation) AddAmount(f float64) {
	if m.addamount != nil {
		*m.addamount += f
	} else {
		m.addamount = &f
	}
}

// AddedAmount returns the value that was added to the "amount" field in this mutation.
func (m *ParcelMutation) AddedAmount() (r float64, exists bool) {
	v := m.addamount
	if v == nil {
		return
	}
	return *v, true
}

// ResetAmount resets all changes to the "amount" field.
func (m *ParcelMutation) ResetAmount() {
	m.amount = nil
	m.addamount = nil
}

// SetPaidAt sets the "paid_at" field.
func (m *ParcelMutation) SetPaidAt(t time.Time) {
	m.paid_at = &t
}

// PaidAt returns the value of the "paid_at" field in the mutation.
func (m *ParcelMutation) PaidAt() (r time.Time, exists bool) {
	v := m.paid_at
	if v == nil {
		return
	}
	return *v, true
}

// OldPaidAt returns the old "paid_at" field's value of the Parcel entity.
// If the Parcel object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ParcelMutation) OldPaidAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPaidAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPaidAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPaidAt: %w", err)
	}
	return oldValue.PaidAt, nil
}

// ClearPaidAt clears the value of the "paid_at" field.
func (m *ParcelMutation) ClearPaidAt() {
	m.paid_at = nil
	m.clearedFields[parcel.FieldPaidAt] = struct{}{}
}

// PaidAtCleared returns if the "paid_at" field was cleared in this mutation.
func (m *ParcelMutation) PaidAtCleared() bool {
	_, ok := m.clearedFields[parcel.FieldPaidAt]
	return ok
}

// ResetPaidAt resets all changes to the "paid_at" field.
func (m *ParcelMutation) ResetPaidAt() {
	m.paid_at = nil
	delete(m.clearedFields, parcel.FieldPaidAt)
}

// SetTansType sets the "tans_type" field.
func (m *ParcelMutation) SetTansType(pt parcel.TansType) {
	m.tans_type = &pt
}

// TansType returns the value of the "tans_type" field in the mutation.
func (m *ParcelMutation) TansType() (r parcel.TansType, exists bool) {
	v := m.tans_type
	if v == nil {
		return
	}
	return *v, true
}

// OldTansType returns the old "tans_type" field's value of the Parcel entity.
// If the Parcel object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ParcelMutation) OldTansType(ctx context.Context) (v parcel.TansType, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTansType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTansType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTansType: %w", err)
	}
	return oldValue.TansType, nil
}

// ResetTansType resets all changes to the "tans_type" field.
func (m *ParcelMutation) ResetTansType() {
	m.tans_type = nil
}

// SetStatus sets the "status" field.
func (m *ParcelMutation) SetStatus(pa parcel.Status) {
	m.status = &pa
}

// Status returns the value of the "status" field in the mutation.
func (m *ParcelMutation) Status() (r parcel.Status, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the Parcel entity.
// If the Parcel object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ParcelMutation) OldStatus(ctx context.Context) (v parcel.Status, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ResetStatus resets all changes to the "status" field.
func (m *ParcelMutation) ResetStatus() {
	m.status = nil
}

// AddImageIDs adds the "images" edge to the ParcelImage entity by ids.
func (m *ParcelMutation) AddImageIDs(ids ...int) {
	if m.images == nil {
		m.images = make(map[int]struct{})
	}
	for i := range ids {
		m.images[ids[i]] = struct{}{}
	}
}

// ClearImages clears the "images" edge to the ParcelImage entity.
func (m *ParcelMutation) ClearImages() {
	m.clearedimages = true
}

// ImagesCleared reports if the "images" edge to the ParcelImage entity was cleared.
func (m *ParcelMutation) ImagesCleared() bool {
	return m.clearedimages
}

// RemoveImageIDs removes the "images" edge to the ParcelImage entity by IDs.
func (m *ParcelMutation) RemoveImageIDs(ids ...int) {
	if m.removedimages == nil {
		m.removedimages = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.images, ids[i])
		m.removedimages[ids[i]] = struct{}{}
	}
}

// RemovedImages returns the removed IDs of the "images" edge to the ParcelImage entity.
func (m *ParcelMutation) RemovedImagesIDs() (ids []int) {
	for id := range m.removedimages {
		ids = append(ids, id)
	}
	return
}

// ImagesIDs returns the "images" edge IDs in the mutation.
func (m *ParcelMutation) ImagesIDs() (ids []int) {
	for id := range m.images {
		ids = append(ids, id)
	}
	return
}

// ResetImages resets all changes to the "images" edge.
func (m *ParcelMutation) ResetImages() {
	m.images = nil
	m.clearedimages = false
	m.removedimages = nil
}

// SetTripID sets the "trip" edge to the Trip entity by id.
func (m *ParcelMutation) SetTripID(id int) {
	m.trip = &id
}

// ClearTrip clears the "trip" edge to the Trip entity.
func (m *ParcelMutation) ClearTrip() {
	m.clearedtrip = true
}

// TripCleared reports if the "trip" edge to the Trip entity was cleared.
func (m *ParcelMutation) TripCleared() bool {
	return m.clearedtrip
}

// TripID returns the "trip" edge ID in the mutation.
func (m *ParcelMutation) TripID() (id int, exists bool) {
	if m.trip != nil {
		return *m.trip, true
	}
	return
}

// TripIDs returns the "trip" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// TripID instead. It exists only for internal usage by the builders.
func (m *ParcelMutation) TripIDs() (ids []int) {
	if id := m.trip; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetTrip resets all changes to the "trip" edge.
func (m *ParcelMutation) ResetTrip() {
	m.trip = nil
	m.clearedtrip = false
}

// SetCompanyID sets the "company" edge to the Company entity by id.
func (m *ParcelMutation) SetCompanyID(id int) {
	m.company = &id
}

// ClearCompany clears the "company" edge to the Company entity.
func (m *ParcelMutation) ClearCompany() {
	m.clearedcompany = true
}

// CompanyCleared reports if the "company" edge to the Company entity was cleared.
func (m *ParcelMutation) CompanyCleared() bool {
	return m.clearedcompany
}

// CompanyID returns the "company" edge ID in the mutation.
func (m *ParcelMutation) CompanyID() (id int, exists bool) {
	if m.company != nil {
		return *m.company, true
	}
	return
}

// CompanyIDs returns the "company" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// CompanyID instead. It exists only for internal usage by the builders.
func (m *ParcelMutation) CompanyIDs() (ids []int) {
	if id := m.company; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetCompany resets all changes to the "company" edge.
func (m *ParcelMutation) ResetCompany() {
	m.company = nil
	m.clearedcompany = false
}

// SetDriverID sets the "driver" edge to the CompanyUser entity by id.
func (m *ParcelMutation) SetDriverID(id int) {
	m._driver = &id
}

// ClearDriver clears the "driver" edge to the CompanyUser entity.
func (m *ParcelMutation) ClearDriver() {
	m.cleared_driver = true
}

// DriverCleared reports if the "driver" edge to the CompanyUser entity was cleared.
func (m *ParcelMutation) DriverCleared() bool {
	return m.cleared_driver
}

// DriverID returns the "driver" edge ID in the mutation.
func (m *ParcelMutation) DriverID() (id int, exists bool) {
	if m._driver != nil {
		return *m._driver, true
	}
	return
}

// DriverIDs returns the "driver" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// DriverID instead. It exists only for internal usage by the builders.
func (m *ParcelMutation) DriverIDs() (ids []int) {
	if id := m._driver; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetDriver resets all changes to the "driver" edge.
func (m *ParcelMutation) ResetDriver() {
	m._driver = nil
	m.cleared_driver = false
}

// Where appends a list predicates to the ParcelMutation builder.
func (m *ParcelMutation) Where(ps ...predicate.Parcel) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the ParcelMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *ParcelMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Parcel, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *ParcelMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *ParcelMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Parcel).
func (m *ParcelMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ParcelMutation) Fields() []string {
	fields := make([]string, 0, 15)
	if m.created_at != nil {
		fields = append(fields, parcel.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, parcel.FieldUpdatedAt)
	}
	if m.parcel_code != nil {
		fields = append(fields, parcel.FieldParcelCode)
	}
	if m._type != nil {
		fields = append(fields, parcel.FieldType)
	}
	if m.sender_name != nil {
		fields = append(fields, parcel.FieldSenderName)
	}
	if m.sender_phone != nil {
		fields = append(fields, parcel.FieldSenderPhone)
	}
	if m.sender_email != nil {
		fields = append(fields, parcel.FieldSenderEmail)
	}
	if m.recipient_name != nil {
		fields = append(fields, parcel.FieldRecipientName)
	}
	if m.recipient_phone != nil {
		fields = append(fields, parcel.FieldRecipientPhone)
	}
	if m.recipient_location != nil {
		fields = append(fields, parcel.FieldRecipientLocation)
	}
	if m.weight != nil {
		fields = append(fields, parcel.FieldWeight)
	}
	if m.amount != nil {
		fields = append(fields, parcel.FieldAmount)
	}
	if m.paid_at != nil {
		fields = append(fields, parcel.FieldPaidAt)
	}
	if m.tans_type != nil {
		fields = append(fields, parcel.FieldTansType)
	}
	if m.status != nil {
		fields = append(fields, parcel.FieldStatus)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ParcelMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case parcel.FieldCreatedAt:
		return m.CreatedAt()
	case parcel.FieldUpdatedAt:
		return m.UpdatedAt()
	case parcel.FieldParcelCode:
		return m.ParcelCode()
	case parcel.FieldType:
		return m.GetType()
	case parcel.FieldSenderName:
		return m.SenderName()
	case parcel.FieldSenderPhone:
		return m.SenderPhone()
	case parcel.FieldSenderEmail:
		return m.SenderEmail()
	case parcel.FieldRecipientName:
		return m.RecipientName()
	case parcel.FieldRecipientPhone:
		return m.RecipientPhone()
	case parcel.FieldRecipientLocation:
		return m.RecipientLocation()
	case parcel.FieldWeight:
		return m.Weight()
	case parcel.FieldAmount:
		return m.Amount()
	case parcel.FieldPaidAt:
		return m.PaidAt()
	case parcel.FieldTansType:
		return m.TansType()
	case parcel.FieldStatus:
		return m.Status()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ParcelMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case parcel.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case parcel.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case parcel.FieldParcelCode:
		return m.OldParcelCode(ctx)
	case parcel.FieldType:
		return m.OldType(ctx)
	case parcel.FieldSenderName:
		return m.OldSenderName(ctx)
	case parcel.FieldSenderPhone:
		return m.OldSenderPhone(ctx)
	case parcel.FieldSenderEmail:
		return m.OldSenderEmail(ctx)
	case parcel.FieldRecipientName:
		return m.OldRecipientName(ctx)
	case parcel.FieldRecipientPhone:
		return m.OldRecipientPhone(ctx)
	case parcel.FieldRecipientLocation:
		return m.OldRecipientLocation(ctx)
	case parcel.FieldWeight:
		return m.OldWeight(ctx)
	case parcel.FieldAmount:
		return m.OldAmount(ctx)
	case parcel.FieldPaidAt:
		return m.OldPaidAt(ctx)
	case parcel.FieldTansType:
		return m.OldTansType(ctx)
	case parcel.FieldStatus:
		return m.OldStatus(ctx)
	}
	return nil, fmt.Errorf("unknown Parcel field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ParcelMutation) SetField(name string, value ent.Value) error {
	switch name {
	case parcel.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case parcel.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case parcel.FieldParcelCode:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetParcelCode(v)
		return nil
	case parcel.FieldType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetType(v)
		return nil
	case parcel.FieldSenderName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSenderName(v)
		return nil
	case parcel.FieldSenderPhone:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSenderPhone(v)
		return nil
	case parcel.FieldSenderEmail:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSenderEmail(v)
		return nil
	case parcel.FieldRecipientName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRecipientName(v)
		return nil
	case parcel.FieldRecipientPhone:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRecipientPhone(v)
		return nil
	case parcel.FieldRecipientLocation:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRecipientLocation(v)
		return nil
	case parcel.FieldWeight:
		v, ok := value.(float32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetWeight(v)
		return nil
	case parcel.FieldAmount:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAmount(v)
		return nil
	case parcel.FieldPaidAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPaidAt(v)
		return nil
	case parcel.FieldTansType:
		v, ok := value.(parcel.TansType)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTansType(v)
		return nil
	case parcel.FieldStatus:
		v, ok := value.(parcel.Status)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	}
	return fmt.Errorf("unknown Parcel field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ParcelMutation) AddedFields() []string {
	var fields []string
	if m.addweight != nil {
		fields = append(fields, parcel.FieldWeight)
	}
	if m.addamount != nil {
		fields = append(fields, parcel.FieldAmount)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ParcelMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case parcel.FieldWeight:
		return m.AddedWeight()
	case parcel.FieldAmount:
		return m.AddedAmount()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ParcelMutation) AddField(name string, value ent.Value) error {
	switch name {
	case parcel.FieldWeight:
		v, ok := value.(float32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddWeight(v)
		return nil
	case parcel.FieldAmount:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddAmount(v)
		return nil
	}
	return fmt.Errorf("unknown Parcel numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ParcelMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(parcel.FieldWeight) {
		fields = append(fields, parcel.FieldWeight)
	}
	if m.FieldCleared(parcel.FieldPaidAt) {
		fields = append(fields, parcel.FieldPaidAt)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ParcelMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ParcelMutation) ClearField(name string) error {
	switch name {
	case parcel.FieldWeight:
		m.ClearWeight()
		return nil
	case parcel.FieldPaidAt:
		m.ClearPaidAt()
		return nil
	}
	return fmt.Errorf("unknown Parcel nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ParcelMutation) ResetField(name string) error {
	switch name {
	case parcel.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case parcel.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case parcel.FieldParcelCode:
		m.ResetParcelCode()
		return nil
	case parcel.FieldType:
		m.ResetType()
		return nil
	case parcel.FieldSenderName:
		m.ResetSenderName()
		return nil
	case parcel.FieldSenderPhone:
		m.ResetSenderPhone()
		return nil
	case parcel.FieldSenderEmail:
		m.ResetSenderEmail()
		return nil
	case parcel.FieldRecipientName:
		m.ResetRecipientName()
		return nil
	case parcel.FieldRecipientPhone:
		m.ResetRecipientPhone()
		return nil
	case parcel.FieldRecipientLocation:
		m.ResetRecipientLocation()
		return nil
	case parcel.FieldWeight:
		m.ResetWeight()
		return nil
	case parcel.FieldAmount:
		m.ResetAmount()
		return nil
	case parcel.FieldPaidAt:
		m.ResetPaidAt()
		return nil
	case parcel.FieldTansType:
		m.ResetTansType()
		return nil
	case parcel.FieldStatus:
		m.ResetStatus()
		return nil
	}
	return fmt.Errorf("unknown Parcel field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ParcelMutation) AddedEdges() []string {
	edges := make([]string, 0, 4)
	if m.images != nil {
		edges = append(edges, parcel.EdgeImages)
	}
	if m.trip != nil {
		edges = append(edges, parcel.EdgeTrip)
	}
	if m.company != nil {
		edges = append(edges, parcel.EdgeCompany)
	}
	if m._driver != nil {
		edges = append(edges, parcel.EdgeDriver)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ParcelMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case parcel.EdgeImages:
		ids := make([]ent.Value, 0, len(m.images))
		for id := range m.images {
			ids = append(ids, id)
		}
		return ids
	case parcel.EdgeTrip:
		if id := m.trip; id != nil {
			return []ent.Value{*id}
		}
	case parcel.EdgeCompany:
		if id := m.company; id != nil {
			return []ent.Value{*id}
		}
	case parcel.EdgeDriver:
		if id := m._driver; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ParcelMutation) RemovedEdges() []string {
	edges := make([]string, 0, 4)
	if m.removedimages != nil {
		edges = append(edges, parcel.EdgeImages)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ParcelMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case parcel.EdgeImages:
		ids := make([]ent.Value, 0, len(m.removedimages))
		for id := range m.removedimages {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ParcelMutation) ClearedEdges() []string {
	edges := make([]string, 0, 4)
	if m.clearedimages {
		edges = append(edges, parcel.EdgeImages)
	}
	if m.clearedtrip {
		edges = append(edges, parcel.EdgeTrip)
	}
	if m.clearedcompany {
		edges = append(edges, parcel.EdgeCompany)
	}
	if m.cleared_driver {
		edges = append(edges, parcel.EdgeDriver)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ParcelMutation) EdgeCleared(name string) bool {
	switch name {
	case parcel.EdgeImages:
		return m.clearedimages
	case parcel.EdgeTrip:
		return m.clearedtrip
	case parcel.EdgeCompany:
		return m.clearedcompany
	case parcel.EdgeDriver:
		return m.cleared_driver
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ParcelMutation) ClearEdge(name string) error {
	switch name {
	case parcel.EdgeTrip:
		m.ClearTrip()
		return nil
	case parcel.EdgeCompany:
		m.ClearCompany()
		return nil
	case parcel.EdgeDriver:
		m.ClearDriver()
		return nil
	}
	return fmt.Errorf("unknown Parcel unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ParcelMutation) ResetEdge(name string) error {
	switch name {
	case parcel.EdgeImages:
		m.ResetImages()
		return nil
	case parcel.EdgeTrip:
		m.ResetTrip()
		return nil
	case parcel.EdgeCompany:
		m.ResetCompany()
		return nil
	case parcel.EdgeDriver:
		m.ResetDriver()
		return nil
	}
	return fmt.Errorf("unknown Parcel edge %s", name)
}

// ParcelImageMutation represents an operation that mutates the ParcelImage nodes in the graph.
type ParcelImageMutation struct {
	config
	op            Op
	typ           string
	id            *int
	created_at    *time.Time
	updated_at    *time.Time
	image         *string
	kind          *parcelimage.Kind
	clearedFields map[string]struct{}
	parcel        *int
	clearedparcel bool
	done          bool
	oldValue      func(context.Context) (*ParcelImage, error)
	predicates    []predicate.ParcelImage
}

var _ ent.Mutation = (*ParcelImageMutation)(nil)

// parcelimageOption allows management of the mutation configuration using functional options.
type parcelimageOption func(*ParcelImageMutation)

// newParcelImageMutation creates new mutation for the ParcelImage entity.
func newParcelImageMutation(c config, op Op, opts ...parcelimageOption) *ParcelImageMutation {
	m := &ParcelImageMutation{
		config:        c,
		op:            op,
		typ:           TypeParcelImage,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withParcelImageID sets the ID field of the mutation.
func withParcelImageID(id int) parcelimageOption {
	return func(m *ParcelImageMutation) {
		var (
			err   error
			once  sync.Once
			value *ParcelImage
		)
		m.oldValue = func(ctx context.Context) (*ParcelImage, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().ParcelImage.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withParcelImage sets the old ParcelImage of the mutation.
func withParcelImage(node *ParcelImage) parcelimageOption {
	return func(m *ParcelImageMutation) {
		m.oldValue = func(context.Context) (*ParcelImage, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ParcelImageMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ParcelImageMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ParcelImageMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ParcelImageMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().ParcelImage.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *ParcelImageMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *ParcelImageMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the ParcelImage entity.
// If the ParcelImage object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ParcelImageMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *ParcelImageMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *ParcelImageMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *ParcelImageMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the ParcelImage entity.
// If the ParcelImage object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ParcelImageMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *ParcelImageMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetImage sets the "image" field.
func (m *ParcelImageMutation) SetImage(s string) {
	m.image = &s
}

// Image returns the value of the "image" field in the mutation.
func (m *ParcelImageMutation) Image() (r string, exists bool) {
	v := m.image
	if v == nil {
		return
	}
	return *v, true
}

// OldImage returns the old "image" field's value of the ParcelImage entity.
// If the ParcelImage object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ParcelImageMutation) OldImage(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldImage is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldImage requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldImage: %w", err)
	}
	return oldValue.Image, nil
}

// ClearImage clears the value of the "image" field.
func (m *ParcelImageMutation) ClearImage() {
	m.image = nil
	m.clearedFields[parcelimage.FieldImage] = struct{}{}
}

// ImageCleared returns if the "image" field was cleared in this mutation.
func (m *ParcelImageMutation) ImageCleared() bool {
	_, ok := m.clearedFields[parcelimage.FieldImage]
	return ok
}

// ResetImage resets all changes to the "image" field.
func (m *ParcelImageMutation) ResetImage() {
	m.image = nil
	delete(m.clearedFields, parcelimage.FieldImage)
}

// SetKind sets the "kind" field.
func (m *ParcelImageMutation) SetKind(pa parcelimage.Kind) {
	m.kind = &pa
}

// Kind returns the value of the "kind" field in the mutation.
func (m *ParcelImageMutation) Kind() (r parcelimage.Kind, exists bool) {
	v := m.kind
	if v == nil {
		return
	}
	return *v, true
}

// OldKind returns the old "kind" field's value of the ParcelImage entity.
// If the ParcelImage object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ParcelImageMutation) OldKind(ctx context.Context) (v parcelimage.Kind, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldKind is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldKind requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldKind: %w", err)
	}
	return oldValue.Kind, nil
}

// ResetKind resets all changes to the "kind" field.
func (m *ParcelImageMutation) ResetKind() {
	m.kind = nil
}

// SetParcelID sets the "parcel" edge to the Parcel entity by id.
func (m *ParcelImageMutation) SetParcelID(id int) {
	m.parcel = &id
}

// ClearParcel clears the "parcel" edge to the Parcel entity.
func (m *ParcelImageMutation) ClearParcel() {
	m.clearedparcel = true
}

// ParcelCleared reports if the "parcel" edge to the Parcel entity was cleared.
func (m *ParcelImageMutation) ParcelCleared() bool {
	return m.clearedparcel
}

// ParcelID returns the "parcel" edge ID in the mutation.
func (m *ParcelImageMutation) ParcelID() (id int, exists bool) {
	if m.parcel != nil {
		return *m.parcel, true
	}
	return
}

// ParcelIDs returns the "parcel" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ParcelID instead. It exists only for internal usage by the builders.
func (m *ParcelImageMutation) ParcelIDs() (ids []int) {
	if id := m.parcel; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetParcel resets all changes to the "parcel" edge.
func (m *ParcelImageMutation) ResetParcel() {
	m.parcel = nil
	m.clearedparcel = false
}

// Where appends a list predicates to the ParcelImageMutation builder.
func (m *ParcelImageMutation) Where(ps ...predicate.ParcelImage) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the ParcelImageMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *ParcelImageMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.ParcelImage, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *ParcelImageMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *ParcelImageMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (ParcelImage).
func (m *ParcelImageMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ParcelImageMutation) Fields() []string {
	fields := make([]string, 0, 4)
	if m.created_at != nil {
		fields = append(fields, parcelimage.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, parcelimage.FieldUpdatedAt)
	}
	if m.image != nil {
		fields = append(fields, parcelimage.FieldImage)
	}
	if m.kind != nil {
		fields = append(fields, parcelimage.FieldKind)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ParcelImageMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case parcelimage.FieldCreatedAt:
		return m.CreatedAt()
	case parcelimage.FieldUpdatedAt:
		return m.UpdatedAt()
	case parcelimage.FieldImage:
		return m.Image()
	case parcelimage.FieldKind:
		return m.Kind()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ParcelImageMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case parcelimage.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case parcelimage.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case parcelimage.FieldImage:
		return m.OldImage(ctx)
	case parcelimage.FieldKind:
		return m.OldKind(ctx)
	}
	return nil, fmt.Errorf("unknown ParcelImage field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ParcelImageMutation) SetField(name string, value ent.Value) error {
	switch name {
	case parcelimage.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case parcelimage.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case parcelimage.FieldImage:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetImage(v)
		return nil
	case parcelimage.FieldKind:
		v, ok := value.(parcelimage.Kind)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetKind(v)
		return nil
	}
	return fmt.Errorf("unknown ParcelImage field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ParcelImageMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ParcelImageMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ParcelImageMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown ParcelImage numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ParcelImageMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(parcelimage.FieldImage) {
		fields = append(fields, parcelimage.FieldImage)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ParcelImageMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ParcelImageMutation) ClearField(name string) error {
	switch name {
	case parcelimage.FieldImage:
		m.ClearImage()
		return nil
	}
	return fmt.Errorf("unknown ParcelImage nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ParcelImageMutation) ResetField(name string) error {
	switch name {
	case parcelimage.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case parcelimage.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case parcelimage.FieldImage:
		m.ResetImage()
		return nil
	case parcelimage.FieldKind:
		m.ResetKind()
		return nil
	}
	return fmt.Errorf("unknown ParcelImage field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ParcelImageMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.parcel != nil {
		edges = append(edges, parcelimage.EdgeParcel)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ParcelImageMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case parcelimage.EdgeParcel:
		if id := m.parcel; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ParcelImageMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ParcelImageMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ParcelImageMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedparcel {
		edges = append(edges, parcelimage.EdgeParcel)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ParcelImageMutation) EdgeCleared(name string) bool {
	switch name {
	case parcelimage.EdgeParcel:
		return m.clearedparcel
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ParcelImageMutation) ClearEdge(name string) error {
	switch name {
	case parcelimage.EdgeParcel:
		m.ClearParcel()
		return nil
	}
	return fmt.Errorf("unknown ParcelImage unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ParcelImageMutation) ResetEdge(name string) error {
	switch name {
	case parcelimage.EdgeParcel:
		m.ResetParcel()
		return nil
	}
	return fmt.Errorf("unknown ParcelImage edge %s", name)
}

// PassengerMutation represents an operation that mutates the Passenger nodes in the graph.
type PassengerMutation struct {
	config
	op             Op
	typ            string
	id             *int
	created_at     *time.Time
	updated_at     *time.Time
	full_name      *string
	amount         *float64
	addamount      *float64
	maturity       *passenger.Maturity
	gender         *passenger.Gender
	clearedFields  map[string]struct{}
	booking        *int
	clearedbooking bool
	done           bool
	oldValue       func(context.Context) (*Passenger, error)
	predicates     []predicate.Passenger
}

var _ ent.Mutation = (*PassengerMutation)(nil)

// passengerOption allows management of the mutation configuration using functional options.
type passengerOption func(*PassengerMutation)

// newPassengerMutation creates new mutation for the Passenger entity.
func newPassengerMutation(c config, op Op, opts ...passengerOption) *PassengerMutation {
	m := &PassengerMutation{
		config:        c,
		op:            op,
		typ:           TypePassenger,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withPassengerID sets the ID field of the mutation.
func withPassengerID(id int) passengerOption {
	return func(m *PassengerMutation) {
		var (
			err   error
			once  sync.Once
			value *Passenger
		)
		m.oldValue = func(ctx context.Context) (*Passenger, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Passenger.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withPassenger sets the old Passenger of the mutation.
func withPassenger(node *Passenger) passengerOption {
	return func(m *PassengerMutation) {
		m.oldValue = func(context.Context) (*Passenger, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m PassengerMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m PassengerMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *PassengerMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *PassengerMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Passenger.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *PassengerMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *PassengerMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Passenger entity.
// If the Passenger object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PassengerMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *PassengerMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *PassengerMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *PassengerMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Passenger entity.
// If the Passenger object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PassengerMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *PassengerMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetFullName sets the "full_name" field.
func (m *PassengerMutation) SetFullName(s string) {
	m.full_name = &s
}

// FullName returns the value of the "full_name" field in the mutation.
func (m *PassengerMutation) FullName() (r string, exists bool) {
	v := m.full_name
	if v == nil {
		return
	}
	return *v, true
}

// OldFullName returns the old "full_name" field's value of the Passenger entity.
// If the Passenger object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PassengerMutation) OldFullName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFullName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFullName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFullName: %w", err)
	}
	return oldValue.FullName, nil
}

// ResetFullName resets all changes to the "full_name" field.
func (m *PassengerMutation) ResetFullName() {
	m.full_name = nil
}

// SetAmount sets the "amount" field.
func (m *PassengerMutation) SetAmount(f float64) {
	m.amount = &f
	m.addamount = nil
}

// Amount returns the value of the "amount" field in the mutation.
func (m *PassengerMutation) Amount() (r float64, exists bool) {
	v := m.amount
	if v == nil {
		return
	}
	return *v, true
}

// OldAmount returns the old "amount" field's value of the Passenger entity.
// If the Passenger object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PassengerMutation) OldAmount(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAmount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAmount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAmount: %w", err)
	}
	return oldValue.Amount, nil
}

// AddAmount adds f to the "amount" field.
func (m *PassengerMutation) AddAmount(f float64) {
	if m.addamount != nil {
		*m.addamount += f
	} else {
		m.addamount = &f
	}
}

// AddedAmount returns the value that was added to the "amount" field in this mutation.
func (m *PassengerMutation) AddedAmount() (r float64, exists bool) {
	v := m.addamount
	if v == nil {
		return
	}
	return *v, true
}

// ResetAmount resets all changes to the "amount" field.
func (m *PassengerMutation) ResetAmount() {
	m.amount = nil
	m.addamount = nil
}

// SetMaturity sets the "maturity" field.
func (m *PassengerMutation) SetMaturity(pa passenger.Maturity) {
	m.maturity = &pa
}

// Maturity returns the value of the "maturity" field in the mutation.
func (m *PassengerMutation) Maturity() (r passenger.Maturity, exists bool) {
	v := m.maturity
	if v == nil {
		return
	}
	return *v, true
}

// OldMaturity returns the old "maturity" field's value of the Passenger entity.
// If the Passenger object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PassengerMutation) OldMaturity(ctx context.Context) (v passenger.Maturity, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMaturity is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMaturity requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMaturity: %w", err)
	}
	return oldValue.Maturity, nil
}

// ResetMaturity resets all changes to the "maturity" field.
func (m *PassengerMutation) ResetMaturity() {
	m.maturity = nil
}

// SetGender sets the "gender" field.
func (m *PassengerMutation) SetGender(pa passenger.Gender) {
	m.gender = &pa
}

// Gender returns the value of the "gender" field in the mutation.
func (m *PassengerMutation) Gender() (r passenger.Gender, exists bool) {
	v := m.gender
	if v == nil {
		return
	}
	return *v, true
}

// OldGender returns the old "gender" field's value of the Passenger entity.
// If the Passenger object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PassengerMutation) OldGender(ctx context.Context) (v passenger.Gender, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldGender is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldGender requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldGender: %w", err)
	}
	return oldValue.Gender, nil
}

// ClearGender clears the value of the "gender" field.
func (m *PassengerMutation) ClearGender() {
	m.gender = nil
	m.clearedFields[passenger.FieldGender] = struct{}{}
}

// GenderCleared returns if the "gender" field was cleared in this mutation.
func (m *PassengerMutation) GenderCleared() bool {
	_, ok := m.clearedFields[passenger.FieldGender]
	return ok
}

// ResetGender resets all changes to the "gender" field.
func (m *PassengerMutation) ResetGender() {
	m.gender = nil
	delete(m.clearedFields, passenger.FieldGender)
}

// SetBookingID sets the "booking" edge to the Booking entity by id.
func (m *PassengerMutation) SetBookingID(id int) {
	m.booking = &id
}

// ClearBooking clears the "booking" edge to the Booking entity.
func (m *PassengerMutation) ClearBooking() {
	m.clearedbooking = true
}

// BookingCleared reports if the "booking" edge to the Booking entity was cleared.
func (m *PassengerMutation) BookingCleared() bool {
	return m.clearedbooking
}

// BookingID returns the "booking" edge ID in the mutation.
func (m *PassengerMutation) BookingID() (id int, exists bool) {
	if m.booking != nil {
		return *m.booking, true
	}
	return
}

// BookingIDs returns the "booking" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// BookingID instead. It exists only for internal usage by the builders.
func (m *PassengerMutation) BookingIDs() (ids []int) {
	if id := m.booking; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetBooking resets all changes to the "booking" edge.
func (m *PassengerMutation) ResetBooking() {
	m.booking = nil
	m.clearedbooking = false
}

// Where appends a list predicates to the PassengerMutation builder.
func (m *PassengerMutation) Where(ps ...predicate.Passenger) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the PassengerMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *PassengerMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Passenger, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *PassengerMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *PassengerMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Passenger).
func (m *PassengerMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *PassengerMutation) Fields() []string {
	fields := make([]string, 0, 6)
	if m.created_at != nil {
		fields = append(fields, passenger.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, passenger.FieldUpdatedAt)
	}
	if m.full_name != nil {
		fields = append(fields, passenger.FieldFullName)
	}
	if m.amount != nil {
		fields = append(fields, passenger.FieldAmount)
	}
	if m.maturity != nil {
		fields = append(fields, passenger.FieldMaturity)
	}
	if m.gender != nil {
		fields = append(fields, passenger.FieldGender)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *PassengerMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case passenger.FieldCreatedAt:
		return m.CreatedAt()
	case passenger.FieldUpdatedAt:
		return m.UpdatedAt()
	case passenger.FieldFullName:
		return m.FullName()
	case passenger.FieldAmount:
		return m.Amount()
	case passenger.FieldMaturity:
		return m.Maturity()
	case passenger.FieldGender:
		return m.Gender()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *PassengerMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case passenger.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case passenger.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case passenger.FieldFullName:
		return m.OldFullName(ctx)
	case passenger.FieldAmount:
		return m.OldAmount(ctx)
	case passenger.FieldMaturity:
		return m.OldMaturity(ctx)
	case passenger.FieldGender:
		return m.OldGender(ctx)
	}
	return nil, fmt.Errorf("unknown Passenger field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PassengerMutation) SetField(name string, value ent.Value) error {
	switch name {
	case passenger.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case passenger.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case passenger.FieldFullName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFullName(v)
		return nil
	case passenger.FieldAmount:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAmount(v)
		return nil
	case passenger.FieldMaturity:
		v, ok := value.(passenger.Maturity)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMaturity(v)
		return nil
	case passenger.FieldGender:
		v, ok := value.(passenger.Gender)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetGender(v)
		return nil
	}
	return fmt.Errorf("unknown Passenger field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *PassengerMutation) AddedFields() []string {
	var fields []string
	if m.addamount != nil {
		fields = append(fields, passenger.FieldAmount)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *PassengerMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case passenger.FieldAmount:
		return m.AddedAmount()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PassengerMutation) AddField(name string, value ent.Value) error {
	switch name {
	case passenger.FieldAmount:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddAmount(v)
		return nil
	}
	return fmt.Errorf("unknown Passenger numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *PassengerMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(passenger.FieldGender) {
		fields = append(fields, passenger.FieldGender)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *PassengerMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *PassengerMutation) ClearField(name string) error {
	switch name {
	case passenger.FieldGender:
		m.ClearGender()
		return nil
	}
	return fmt.Errorf("unknown Passenger nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *PassengerMutation) ResetField(name string) error {
	switch name {
	case passenger.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case passenger.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case passenger.FieldFullName:
		m.ResetFullName()
		return nil
	case passenger.FieldAmount:
		m.ResetAmount()
		return nil
	case passenger.FieldMaturity:
		m.ResetMaturity()
		return nil
	case passenger.FieldGender:
		m.ResetGender()
		return nil
	}
	return fmt.Errorf("unknown Passenger field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *PassengerMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.booking != nil {
		edges = append(edges, passenger.EdgeBooking)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *PassengerMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case passenger.EdgeBooking:
		if id := m.booking; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *PassengerMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *PassengerMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *PassengerMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedbooking {
		edges = append(edges, passenger.EdgeBooking)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *PassengerMutation) EdgeCleared(name string) bool {
	switch name {
	case passenger.EdgeBooking:
		return m.clearedbooking
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *PassengerMutation) ClearEdge(name string) error {
	switch name {
	case passenger.EdgeBooking:
		m.ClearBooking()
		return nil
	}
	return fmt.Errorf("unknown Passenger unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *PassengerMutation) ResetEdge(name string) error {
	switch name {
	case passenger.EdgeBooking:
		m.ResetBooking()
		return nil
	}
	return fmt.Errorf("unknown Passenger edge %s", name)
}

// RouteMutation represents an operation that mutates the Route nodes in the graph.
type RouteMutation struct {
	config
	op                Op
	typ               string
	id                *int
	created_at        *time.Time
	updated_at        *time.Time
	from_location     *string
	to_location       *string
	from_latitude     *float64
	addfrom_latitude  *float64
	from_longitude    *float64
	addfrom_longitude *float64
	to_latitude       *float64
	addto_latitude    *float64
	to_longitude      *float64
	addto_longitude   *float64
	rate              *float64
	addrate           *float64
	discount          *float32
	adddiscount       *float32
	popularity        *int
	addpopularity     *int
	clearedFields     map[string]struct{}
	company           *int
	clearedcompany    bool
	stops             map[int]struct{}
	removedstops      map[int]struct{}
	clearedstops      bool
	trips             map[int]struct{}
	removedtrips      map[int]struct{}
	clearedtrips      bool
	done              bool
	oldValue          func(context.Context) (*Route, error)
	predicates        []predicate.Route
}

var _ ent.Mutation = (*RouteMutation)(nil)

// routeOption allows management of the mutation configuration using functional options.
type routeOption func(*RouteMutation)

// newRouteMutation creates new mutation for the Route entity.
func newRouteMutation(c config, op Op, opts ...routeOption) *RouteMutation {
	m := &RouteMutation{
		config:        c,
		op:            op,
		typ:           TypeRoute,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withRouteID sets the ID field of the mutation.
func withRouteID(id int) routeOption {
	return func(m *RouteMutation) {
		var (
			err   error
			once  sync.Once
			value *Route
		)
		m.oldValue = func(ctx context.Context) (*Route, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Route.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withRoute sets the old Route of the mutation.
func withRoute(node *Route) routeOption {
	return func(m *RouteMutation) {
		m.oldValue = func(context.Context) (*Route, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m RouteMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m RouteMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *RouteMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *RouteMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Route.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *RouteMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *RouteMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Route entity.
// If the Route object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RouteMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *RouteMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *RouteMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *RouteMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Route entity.
// If the Route object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RouteMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *RouteMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetFromLocation sets the "from_location" field.
func (m *RouteMutation) SetFromLocation(s string) {
	m.from_location = &s
}

// FromLocation returns the value of the "from_location" field in the mutation.
func (m *RouteMutation) FromLocation() (r string, exists bool) {
	v := m.from_location
	if v == nil {
		return
	}
	return *v, true
}

// OldFromLocation returns the old "from_location" field's value of the Route entity.
// If the Route object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RouteMutation) OldFromLocation(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFromLocation is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFromLocation requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFromLocation: %w", err)
	}
	return oldValue.FromLocation, nil
}

// ResetFromLocation resets all changes to the "from_location" field.
func (m *RouteMutation) ResetFromLocation() {
	m.from_location = nil
}

// SetToLocation sets the "to_location" field.
func (m *RouteMutation) SetToLocation(s string) {
	m.to_location = &s
}

// ToLocation returns the value of the "to_location" field in the mutation.
func (m *RouteMutation) ToLocation() (r string, exists bool) {
	v := m.to_location
	if v == nil {
		return
	}
	return *v, true
}

// OldToLocation returns the old "to_location" field's value of the Route entity.
// If the Route object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RouteMutation) OldToLocation(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldToLocation is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldToLocation requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldToLocation: %w", err)
	}
	return oldValue.ToLocation, nil
}

// ResetToLocation resets all changes to the "to_location" field.
func (m *RouteMutation) ResetToLocation() {
	m.to_location = nil
}

// SetFromLatitude sets the "from_latitude" field.
func (m *RouteMutation) SetFromLatitude(f float64) {
	m.from_latitude = &f
	m.addfrom_latitude = nil
}

// FromLatitude returns the value of the "from_latitude" field in the mutation.
func (m *RouteMutation) FromLatitude() (r float64, exists bool) {
	v := m.from_latitude
	if v == nil {
		return
	}
	return *v, true
}

// OldFromLatitude returns the old "from_latitude" field's value of the Route entity.
// If the Route object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RouteMutation) OldFromLatitude(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFromLatitude is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFromLatitude requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFromLatitude: %w", err)
	}
	return oldValue.FromLatitude, nil
}

// AddFromLatitude adds f to the "from_latitude" field.
func (m *RouteMutation) AddFromLatitude(f float64) {
	if m.addfrom_latitude != nil {
		*m.addfrom_latitude += f
	} else {
		m.addfrom_latitude = &f
	}
}

// AddedFromLatitude returns the value that was added to the "from_latitude" field in this mutation.
func (m *RouteMutation) AddedFromLatitude() (r float64, exists bool) {
	v := m.addfrom_latitude
	if v == nil {
		return
	}
	return *v, true
}

// ClearFromLatitude clears the value of the "from_latitude" field.
func (m *RouteMutation) ClearFromLatitude() {
	m.from_latitude = nil
	m.addfrom_latitude = nil
	m.clearedFields[route.FieldFromLatitude] = struct{}{}
}

// FromLatitudeCleared returns if the "from_latitude" field was cleared in this mutation.
func (m *RouteMutation) FromLatitudeCleared() bool {
	_, ok := m.clearedFields[route.FieldFromLatitude]
	return ok
}

// ResetFromLatitude resets all changes to the "from_latitude" field.
func (m *RouteMutation) ResetFromLatitude() {
	m.from_latitude = nil
	m.addfrom_latitude = nil
	delete(m.clearedFields, route.FieldFromLatitude)
}

// SetFromLongitude sets the "from_longitude" field.
func (m *RouteMutation) SetFromLongitude(f float64) {
	m.from_longitude = &f
	m.addfrom_longitude = nil
}

// FromLongitude returns the value of the "from_longitude" field in the mutation.
func (m *RouteMutation) FromLongitude() (r float64, exists bool) {
	v := m.from_longitude
	if v == nil {
		return
	}
	return *v, true
}

// OldFromLongitude returns the old "from_longitude" field's value of the Route entity.
// If the Route object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RouteMutation) OldFromLongitude(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFromLongitude is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFromLongitude requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFromLongitude: %w", err)
	}
	return oldValue.FromLongitude, nil
}

// AddFromLongitude adds f to the "from_longitude" field.
func (m *RouteMutation) AddFromLongitude(f float64) {
	if m.addfrom_longitude != nil {
		*m.addfrom_longitude += f
	} else {
		m.addfrom_longitude = &f
	}
}

// AddedFromLongitude returns the value that was added to the "from_longitude" field in this mutation.
func (m *RouteMutation) AddedFromLongitude() (r float64, exists bool) {
	v := m.addfrom_longitude
	if v == nil {
		return
	}
	return *v, true
}

// ClearFromLongitude clears the value of the "from_longitude" field.
func (m *RouteMutation) ClearFromLongitude() {
	m.from_longitude = nil
	m.addfrom_longitude = nil
	m.clearedFields[route.FieldFromLongitude] = struct{}{}
}

// FromLongitudeCleared returns if the "from_longitude" field was cleared in this mutation.
func (m *RouteMutation) FromLongitudeCleared() bool {
	_, ok := m.clearedFields[route.FieldFromLongitude]
	return ok
}

// ResetFromLongitude resets all changes to the "from_longitude" field.
func (m *RouteMutation) ResetFromLongitude() {
	m.from_longitude = nil
	m.addfrom_longitude = nil
	delete(m.clearedFields, route.FieldFromLongitude)
}

// SetToLatitude sets the "to_latitude" field.
func (m *RouteMutation) SetToLatitude(f float64) {
	m.to_latitude = &f
	m.addto_latitude = nil
}

// ToLatitude returns the value of the "to_latitude" field in the mutation.
func (m *RouteMutation) ToLatitude() (r float64, exists bool) {
	v := m.to_latitude
	if v == nil {
		return
	}
	return *v, true
}

// OldToLatitude returns the old "to_latitude" field's value of the Route entity.
// If the Route object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RouteMutation) OldToLatitude(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldToLatitude is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldToLatitude requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldToLatitude: %w", err)
	}
	return oldValue.ToLatitude, nil
}

// AddToLatitude adds f to the "to_latitude" field.
func (m *RouteMutation) AddToLatitude(f float64) {
	if m.addto_latitude != nil {
		*m.addto_latitude += f
	} else {
		m.addto_latitude = &f
	}
}

// AddedToLatitude returns the value that was added to the "to_latitude" field in this mutation.
func (m *RouteMutation) AddedToLatitude() (r float64, exists bool) {
	v := m.addto_latitude
	if v == nil {
		return
	}
	return *v, true
}

// ClearToLatitude clears the value of the "to_latitude" field.
func (m *RouteMutation) ClearToLatitude() {
	m.to_latitude = nil
	m.addto_latitude = nil
	m.clearedFields[route.FieldToLatitude] = struct{}{}
}

// ToLatitudeCleared returns if the "to_latitude" field was cleared in this mutation.
func (m *RouteMutation) ToLatitudeCleared() bool {
	_, ok := m.clearedFields[route.FieldToLatitude]
	return ok
}

// ResetToLatitude resets all changes to the "to_latitude" field.
func (m *RouteMutation) ResetToLatitude() {
	m.to_latitude = nil
	m.addto_latitude = nil
	delete(m.clearedFields, route.FieldToLatitude)
}

// SetToLongitude sets the "to_longitude" field.
func (m *RouteMutation) SetToLongitude(f float64) {
	m.to_longitude = &f
	m.addto_longitude = nil
}

// ToLongitude returns the value of the "to_longitude" field in the mutation.
func (m *RouteMutation) ToLongitude() (r float64, exists bool) {
	v := m.to_longitude
	if v == nil {
		return
	}
	return *v, true
}

// OldToLongitude returns the old "to_longitude" field's value of the Route entity.
// If the Route object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RouteMutation) OldToLongitude(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldToLongitude is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldToLongitude requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldToLongitude: %w", err)
	}
	return oldValue.ToLongitude, nil
}

// AddToLongitude adds f to the "to_longitude" field.
func (m *RouteMutation) AddToLongitude(f float64) {
	if m.addto_longitude != nil {
		*m.addto_longitude += f
	} else {
		m.addto_longitude = &f
	}
}

// AddedToLongitude returns the value that was added to the "to_longitude" field in this mutation.
func (m *RouteMutation) AddedToLongitude() (r float64, exists bool) {
	v := m.addto_longitude
	if v == nil {
		return
	}
	return *v, true
}

// ClearToLongitude clears the value of the "to_longitude" field.
func (m *RouteMutation) ClearToLongitude() {
	m.to_longitude = nil
	m.addto_longitude = nil
	m.clearedFields[route.FieldToLongitude] = struct{}{}
}

// ToLongitudeCleared returns if the "to_longitude" field was cleared in this mutation.
func (m *RouteMutation) ToLongitudeCleared() bool {
	_, ok := m.clearedFields[route.FieldToLongitude]
	return ok
}

// ResetToLongitude resets all changes to the "to_longitude" field.
func (m *RouteMutation) ResetToLongitude() {
	m.to_longitude = nil
	m.addto_longitude = nil
	delete(m.clearedFields, route.FieldToLongitude)
}

// SetRate sets the "rate" field.
func (m *RouteMutation) SetRate(f float64) {
	m.rate = &f
	m.addrate = nil
}

// Rate returns the value of the "rate" field in the mutation.
func (m *RouteMutation) Rate() (r float64, exists bool) {
	v := m.rate
	if v == nil {
		return
	}
	return *v, true
}

// OldRate returns the old "rate" field's value of the Route entity.
// If the Route object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RouteMutation) OldRate(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRate: %w", err)
	}
	return oldValue.Rate, nil
}

// AddRate adds f to the "rate" field.
func (m *RouteMutation) AddRate(f float64) {
	if m.addrate != nil {
		*m.addrate += f
	} else {
		m.addrate = &f
	}
}

// AddedRate returns the value that was added to the "rate" field in this mutation.
func (m *RouteMutation) AddedRate() (r float64, exists bool) {
	v := m.addrate
	if v == nil {
		return
	}
	return *v, true
}

// ResetRate resets all changes to the "rate" field.
func (m *RouteMutation) ResetRate() {
	m.rate = nil
	m.addrate = nil
}

// SetDiscount sets the "discount" field.
func (m *RouteMutation) SetDiscount(f float32) {
	m.discount = &f
	m.adddiscount = nil
}

// Discount returns the value of the "discount" field in the mutation.
func (m *RouteMutation) Discount() (r float32, exists bool) {
	v := m.discount
	if v == nil {
		return
	}
	return *v, true
}

// OldDiscount returns the old "discount" field's value of the Route entity.
// If the Route object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RouteMutation) OldDiscount(ctx context.Context) (v float32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDiscount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDiscount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDiscount: %w", err)
	}
	return oldValue.Discount, nil
}

// AddDiscount adds f to the "discount" field.
func (m *RouteMutation) AddDiscount(f float32) {
	if m.adddiscount != nil {
		*m.adddiscount += f
	} else {
		m.adddiscount = &f
	}
}

// AddedDiscount returns the value that was added to the "discount" field in this mutation.
func (m *RouteMutation) AddedDiscount() (r float32, exists bool) {
	v := m.adddiscount
	if v == nil {
		return
	}
	return *v, true
}

// ResetDiscount resets all changes to the "discount" field.
func (m *RouteMutation) ResetDiscount() {
	m.discount = nil
	m.adddiscount = nil
}

// SetPopularity sets the "popularity" field.
func (m *RouteMutation) SetPopularity(i int) {
	m.popularity = &i
	m.addpopularity = nil
}

// Popularity returns the value of the "popularity" field in the mutation.
func (m *RouteMutation) Popularity() (r int, exists bool) {
	v := m.popularity
	if v == nil {
		return
	}
	return *v, true
}

// OldPopularity returns the old "popularity" field's value of the Route entity.
// If the Route object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RouteMutation) OldPopularity(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPopularity is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPopularity requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPopularity: %w", err)
	}
	return oldValue.Popularity, nil
}

// AddPopularity adds i to the "popularity" field.
func (m *RouteMutation) AddPopularity(i int) {
	if m.addpopularity != nil {
		*m.addpopularity += i
	} else {
		m.addpopularity = &i
	}
}

// AddedPopularity returns the value that was added to the "popularity" field in this mutation.
func (m *RouteMutation) AddedPopularity() (r int, exists bool) {
	v := m.addpopularity
	if v == nil {
		return
	}
	return *v, true
}

// ResetPopularity resets all changes to the "popularity" field.
func (m *RouteMutation) ResetPopularity() {
	m.popularity = nil
	m.addpopularity = nil
}

// SetCompanyID sets the "company" edge to the Company entity by id.
func (m *RouteMutation) SetCompanyID(id int) {
	m.company = &id
}

// ClearCompany clears the "company" edge to the Company entity.
func (m *RouteMutation) ClearCompany() {
	m.clearedcompany = true
}

// CompanyCleared reports if the "company" edge to the Company entity was cleared.
func (m *RouteMutation) CompanyCleared() bool {
	return m.clearedcompany
}

// CompanyID returns the "company" edge ID in the mutation.
func (m *RouteMutation) CompanyID() (id int, exists bool) {
	if m.company != nil {
		return *m.company, true
	}
	return
}

// CompanyIDs returns the "company" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// CompanyID instead. It exists only for internal usage by the builders.
func (m *RouteMutation) CompanyIDs() (ids []int) {
	if id := m.company; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetCompany resets all changes to the "company" edge.
func (m *RouteMutation) ResetCompany() {
	m.company = nil
	m.clearedcompany = false
}

// AddStopIDs adds the "stops" edge to the RouteStop entity by ids.
func (m *RouteMutation) AddStopIDs(ids ...int) {
	if m.stops == nil {
		m.stops = make(map[int]struct{})
	}
	for i := range ids {
		m.stops[ids[i]] = struct{}{}
	}
}

// ClearStops clears the "stops" edge to the RouteStop entity.
func (m *RouteMutation) ClearStops() {
	m.clearedstops = true
}

// StopsCleared reports if the "stops" edge to the RouteStop entity was cleared.
func (m *RouteMutation) StopsCleared() bool {
	return m.clearedstops
}

// RemoveStopIDs removes the "stops" edge to the RouteStop entity by IDs.
func (m *RouteMutation) RemoveStopIDs(ids ...int) {
	if m.removedstops == nil {
		m.removedstops = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.stops, ids[i])
		m.removedstops[ids[i]] = struct{}{}
	}
}

// RemovedStops returns the removed IDs of the "stops" edge to the RouteStop entity.
func (m *RouteMutation) RemovedStopsIDs() (ids []int) {
	for id := range m.removedstops {
		ids = append(ids, id)
	}
	return
}

// StopsIDs returns the "stops" edge IDs in the mutation.
func (m *RouteMutation) StopsIDs() (ids []int) {
	for id := range m.stops {
		ids = append(ids, id)
	}
	return
}

// ResetStops resets all changes to the "stops" edge.
func (m *RouteMutation) ResetStops() {
	m.stops = nil
	m.clearedstops = false
	m.removedstops = nil
}

// AddTripIDs adds the "trips" edge to the Trip entity by ids.
func (m *RouteMutation) AddTripIDs(ids ...int) {
	if m.trips == nil {
		m.trips = make(map[int]struct{})
	}
	for i := range ids {
		m.trips[ids[i]] = struct{}{}
	}
}

// ClearTrips clears the "trips" edge to the Trip entity.
func (m *RouteMutation) ClearTrips() {
	m.clearedtrips = true
}

// TripsCleared reports if the "trips" edge to the Trip entity was cleared.
func (m *RouteMutation) TripsCleared() bool {
	return m.clearedtrips
}

// RemoveTripIDs removes the "trips" edge to the Trip entity by IDs.
func (m *RouteMutation) RemoveTripIDs(ids ...int) {
	if m.removedtrips == nil {
		m.removedtrips = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.trips, ids[i])
		m.removedtrips[ids[i]] = struct{}{}
	}
}

// RemovedTrips returns the removed IDs of the "trips" edge to the Trip entity.
func (m *RouteMutation) RemovedTripsIDs() (ids []int) {
	for id := range m.removedtrips {
		ids = append(ids, id)
	}
	return
}

// TripsIDs returns the "trips" edge IDs in the mutation.
func (m *RouteMutation) TripsIDs() (ids []int) {
	for id := range m.trips {
		ids = append(ids, id)
	}
	return
}

// ResetTrips resets all changes to the "trips" edge.
func (m *RouteMutation) ResetTrips() {
	m.trips = nil
	m.clearedtrips = false
	m.removedtrips = nil
}

// Where appends a list predicates to the RouteMutation builder.
func (m *RouteMutation) Where(ps ...predicate.Route) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the RouteMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *RouteMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Route, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *RouteMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *RouteMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Route).
func (m *RouteMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *RouteMutation) Fields() []string {
	fields := make([]string, 0, 11)
	if m.created_at != nil {
		fields = append(fields, route.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, route.FieldUpdatedAt)
	}
	if m.from_location != nil {
		fields = append(fields, route.FieldFromLocation)
	}
	if m.to_location != nil {
		fields = append(fields, route.FieldToLocation)
	}
	if m.from_latitude != nil {
		fields = append(fields, route.FieldFromLatitude)
	}
	if m.from_longitude != nil {
		fields = append(fields, route.FieldFromLongitude)
	}
	if m.to_latitude != nil {
		fields = append(fields, route.FieldToLatitude)
	}
	if m.to_longitude != nil {
		fields = append(fields, route.FieldToLongitude)
	}
	if m.rate != nil {
		fields = append(fields, route.FieldRate)
	}
	if m.discount != nil {
		fields = append(fields, route.FieldDiscount)
	}
	if m.popularity != nil {
		fields = append(fields, route.FieldPopularity)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *RouteMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case route.FieldCreatedAt:
		return m.CreatedAt()
	case route.FieldUpdatedAt:
		return m.UpdatedAt()
	case route.FieldFromLocation:
		return m.FromLocation()
	case route.FieldToLocation:
		return m.ToLocation()
	case route.FieldFromLatitude:
		return m.FromLatitude()
	case route.FieldFromLongitude:
		return m.FromLongitude()
	case route.FieldToLatitude:
		return m.ToLatitude()
	case route.FieldToLongitude:
		return m.ToLongitude()
	case route.FieldRate:
		return m.Rate()
	case route.FieldDiscount:
		return m.Discount()
	case route.FieldPopularity:
		return m.Popularity()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *RouteMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case route.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case route.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case route.FieldFromLocation:
		return m.OldFromLocation(ctx)
	case route.FieldToLocation:
		return m.OldToLocation(ctx)
	case route.FieldFromLatitude:
		return m.OldFromLatitude(ctx)
	case route.FieldFromLongitude:
		return m.OldFromLongitude(ctx)
	case route.FieldToLatitude:
		return m.OldToLatitude(ctx)
	case route.FieldToLongitude:
		return m.OldToLongitude(ctx)
	case route.FieldRate:
		return m.OldRate(ctx)
	case route.FieldDiscount:
		return m.OldDiscount(ctx)
	case route.FieldPopularity:
		return m.OldPopularity(ctx)
	}
	return nil, fmt.Errorf("unknown Route field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *RouteMutation) SetField(name string, value ent.Value) error {
	switch name {
	case route.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case route.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case route.FieldFromLocation:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFromLocation(v)
		return nil
	case route.FieldToLocation:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetToLocation(v)
		return nil
	case route.FieldFromLatitude:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFromLatitude(v)
		return nil
	case route.FieldFromLongitude:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFromLongitude(v)
		return nil
	case route.FieldToLatitude:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetToLatitude(v)
		return nil
	case route.FieldToLongitude:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetToLongitude(v)
		return nil
	case route.FieldRate:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRate(v)
		return nil
	case route.FieldDiscount:
		v, ok := value.(float32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDiscount(v)
		return nil
	case route.FieldPopularity:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPopularity(v)
		return nil
	}
	return fmt.Errorf("unknown Route field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *RouteMutation) AddedFields() []string {
	var fields []string
	if m.addfrom_latitude != nil {
		fields = append(fields, route.FieldFromLatitude)
	}
	if m.addfrom_longitude != nil {
		fields = append(fields, route.FieldFromLongitude)
	}
	if m.addto_latitude != nil {
		fields = append(fields, route.FieldToLatitude)
	}
	if m.addto_longitude != nil {
		fields = append(fields, route.FieldToLongitude)
	}
	if m.addrate != nil {
		fields = append(fields, route.FieldRate)
	}
	if m.adddiscount != nil {
		fields = append(fields, route.FieldDiscount)
	}
	if m.addpopularity != nil {
		fields = append(fields, route.FieldPopularity)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *RouteMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case route.FieldFromLatitude:
		return m.AddedFromLatitude()
	case route.FieldFromLongitude:
		return m.AddedFromLongitude()
	case route.FieldToLatitude:
		return m.AddedToLatitude()
	case route.FieldToLongitude:
		return m.AddedToLongitude()
	case route.FieldRate:
		return m.AddedRate()
	case route.FieldDiscount:
		return m.AddedDiscount()
	case route.FieldPopularity:
		return m.AddedPopularity()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *RouteMutation) AddField(name string, value ent.Value) error {
	switch name {
	case route.FieldFromLatitude:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddFromLatitude(v)
		return nil
	case route.FieldFromLongitude:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddFromLongitude(v)
		return nil
	case route.FieldToLatitude:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddToLatitude(v)
		return nil
	case route.FieldToLongitude:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddToLongitude(v)
		return nil
	case route.FieldRate:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddRate(v)
		return nil
	case route.FieldDiscount:
		v, ok := value.(float32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDiscount(v)
		return nil
	case route.FieldPopularity:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddPopularity(v)
		return nil
	}
	return fmt.Errorf("unknown Route numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *RouteMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(route.FieldFromLatitude) {
		fields = append(fields, route.FieldFromLatitude)
	}
	if m.FieldCleared(route.FieldFromLongitude) {
		fields = append(fields, route.FieldFromLongitude)
	}
	if m.FieldCleared(route.FieldToLatitude) {
		fields = append(fields, route.FieldToLatitude)
	}
	if m.FieldCleared(route.FieldToLongitude) {
		fields = append(fields, route.FieldToLongitude)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *RouteMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *RouteMutation) ClearField(name string) error {
	switch name {
	case route.FieldFromLatitude:
		m.ClearFromLatitude()
		return nil
	case route.FieldFromLongitude:
		m.ClearFromLongitude()
		return nil
	case route.FieldToLatitude:
		m.ClearToLatitude()
		return nil
	case route.FieldToLongitude:
		m.ClearToLongitude()
		return nil
	}
	return fmt.Errorf("unknown Route nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *RouteMutation) ResetField(name string) error {
	switch name {
	case route.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case route.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case route.FieldFromLocation:
		m.ResetFromLocation()
		return nil
	case route.FieldToLocation:
		m.ResetToLocation()
		return nil
	case route.FieldFromLatitude:
		m.ResetFromLatitude()
		return nil
	case route.FieldFromLongitude:
		m.ResetFromLongitude()
		return nil
	case route.FieldToLatitude:
		m.ResetToLatitude()
		return nil
	case route.FieldToLongitude:
		m.ResetToLongitude()
		return nil
	case route.FieldRate:
		m.ResetRate()
		return nil
	case route.FieldDiscount:
		m.ResetDiscount()
		return nil
	case route.FieldPopularity:
		m.ResetPopularity()
		return nil
	}
	return fmt.Errorf("unknown Route field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *RouteMutation) AddedEdges() []string {
	edges := make([]string, 0, 3)
	if m.company != nil {
		edges = append(edges, route.EdgeCompany)
	}
	if m.stops != nil {
		edges = append(edges, route.EdgeStops)
	}
	if m.trips != nil {
		edges = append(edges, route.EdgeTrips)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *RouteMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case route.EdgeCompany:
		if id := m.company; id != nil {
			return []ent.Value{*id}
		}
	case route.EdgeStops:
		ids := make([]ent.Value, 0, len(m.stops))
		for id := range m.stops {
			ids = append(ids, id)
		}
		return ids
	case route.EdgeTrips:
		ids := make([]ent.Value, 0, len(m.trips))
		for id := range m.trips {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *RouteMutation) RemovedEdges() []string {
	edges := make([]string, 0, 3)
	if m.removedstops != nil {
		edges = append(edges, route.EdgeStops)
	}
	if m.removedtrips != nil {
		edges = append(edges, route.EdgeTrips)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *RouteMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case route.EdgeStops:
		ids := make([]ent.Value, 0, len(m.removedstops))
		for id := range m.removedstops {
			ids = append(ids, id)
		}
		return ids
	case route.EdgeTrips:
		ids := make([]ent.Value, 0, len(m.removedtrips))
		for id := range m.removedtrips {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *RouteMutation) ClearedEdges() []string {
	edges := make([]string, 0, 3)
	if m.clearedcompany {
		edges = append(edges, route.EdgeCompany)
	}
	if m.clearedstops {
		edges = append(edges, route.EdgeStops)
	}
	if m.clearedtrips {
		edges = append(edges, route.EdgeTrips)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *RouteMutation) EdgeCleared(name string) bool {
	switch name {
	case route.EdgeCompany:
		return m.clearedcompany
	case route.EdgeStops:
		return m.clearedstops
	case route.EdgeTrips:
		return m.clearedtrips
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *RouteMutation) ClearEdge(name string) error {
	switch name {
	case route.EdgeCompany:
		m.ClearCompany()
		return nil
	}
	return fmt.Errorf("unknown Route unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *RouteMutation) ResetEdge(name string) error {
	switch name {
	case route.EdgeCompany:
		m.ResetCompany()
		return nil
	case route.EdgeStops:
		m.ResetStops()
		return nil
	case route.EdgeTrips:
		m.ResetTrips()
		return nil
	}
	return fmt.Errorf("unknown Route edge %s", name)
}

// RouteStopMutation represents an operation that mutates the RouteStop nodes in the graph.
type RouteStopMutation struct {
	config
	op            Op
	typ           string
	id            *int
	created_at    *time.Time
	updated_at    *time.Time
	latitude      *float64
	addlatitude   *float64
	longitude     *float64
	addlongitude  *float64
	clearedFields map[string]struct{}
	route         *int
	clearedroute  bool
	done          bool
	oldValue      func(context.Context) (*RouteStop, error)
	predicates    []predicate.RouteStop
}

var _ ent.Mutation = (*RouteStopMutation)(nil)

// routestopOption allows management of the mutation configuration using functional options.
type routestopOption func(*RouteStopMutation)

// newRouteStopMutation creates new mutation for the RouteStop entity.
func newRouteStopMutation(c config, op Op, opts ...routestopOption) *RouteStopMutation {
	m := &RouteStopMutation{
		config:        c,
		op:            op,
		typ:           TypeRouteStop,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withRouteStopID sets the ID field of the mutation.
func withRouteStopID(id int) routestopOption {
	return func(m *RouteStopMutation) {
		var (
			err   error
			once  sync.Once
			value *RouteStop
		)
		m.oldValue = func(ctx context.Context) (*RouteStop, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().RouteStop.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withRouteStop sets the old RouteStop of the mutation.
func withRouteStop(node *RouteStop) routestopOption {
	return func(m *RouteStopMutation) {
		m.oldValue = func(context.Context) (*RouteStop, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m RouteStopMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m RouteStopMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *RouteStopMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *RouteStopMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().RouteStop.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *RouteStopMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *RouteStopMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the RouteStop entity.
// If the RouteStop object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RouteStopMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *RouteStopMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *RouteStopMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *RouteStopMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the RouteStop entity.
// If the RouteStop object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RouteStopMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *RouteStopMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetLatitude sets the "latitude" field.
func (m *RouteStopMutation) SetLatitude(f float64) {
	m.latitude = &f
	m.addlatitude = nil
}

// Latitude returns the value of the "latitude" field in the mutation.
func (m *RouteStopMutation) Latitude() (r float64, exists bool) {
	v := m.latitude
	if v == nil {
		return
	}
	return *v, true
}

// OldLatitude returns the old "latitude" field's value of the RouteStop entity.
// If the RouteStop object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RouteStopMutation) OldLatitude(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLatitude is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLatitude requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLatitude: %w", err)
	}
	return oldValue.Latitude, nil
}

// AddLatitude adds f to the "latitude" field.
func (m *RouteStopMutation) AddLatitude(f float64) {
	if m.addlatitude != nil {
		*m.addlatitude += f
	} else {
		m.addlatitude = &f
	}
}

// AddedLatitude returns the value that was added to the "latitude" field in this mutation.
func (m *RouteStopMutation) AddedLatitude() (r float64, exists bool) {
	v := m.addlatitude
	if v == nil {
		return
	}
	return *v, true
}

// ClearLatitude clears the value of the "latitude" field.
func (m *RouteStopMutation) ClearLatitude() {
	m.latitude = nil
	m.addlatitude = nil
	m.clearedFields[routestop.FieldLatitude] = struct{}{}
}

// LatitudeCleared returns if the "latitude" field was cleared in this mutation.
func (m *RouteStopMutation) LatitudeCleared() bool {
	_, ok := m.clearedFields[routestop.FieldLatitude]
	return ok
}

// ResetLatitude resets all changes to the "latitude" field.
func (m *RouteStopMutation) ResetLatitude() {
	m.latitude = nil
	m.addlatitude = nil
	delete(m.clearedFields, routestop.FieldLatitude)
}

// SetLongitude sets the "longitude" field.
func (m *RouteStopMutation) SetLongitude(f float64) {
	m.longitude = &f
	m.addlongitude = nil
}

// Longitude returns the value of the "longitude" field in the mutation.
func (m *RouteStopMutation) Longitude() (r float64, exists bool) {
	v := m.longitude
	if v == nil {
		return
	}
	return *v, true
}

// OldLongitude returns the old "longitude" field's value of the RouteStop entity.
// If the RouteStop object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RouteStopMutation) OldLongitude(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLongitude is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLongitude requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLongitude: %w", err)
	}
	return oldValue.Longitude, nil
}

// AddLongitude adds f to the "longitude" field.
func (m *RouteStopMutation) AddLongitude(f float64) {
	if m.addlongitude != nil {
		*m.addlongitude += f
	} else {
		m.addlongitude = &f
	}
}

// AddedLongitude returns the value that was added to the "longitude" field in this mutation.
func (m *RouteStopMutation) AddedLongitude() (r float64, exists bool) {
	v := m.addlongitude
	if v == nil {
		return
	}
	return *v, true
}

// ClearLongitude clears the value of the "longitude" field.
func (m *RouteStopMutation) ClearLongitude() {
	m.longitude = nil
	m.addlongitude = nil
	m.clearedFields[routestop.FieldLongitude] = struct{}{}
}

// LongitudeCleared returns if the "longitude" field was cleared in this mutation.
func (m *RouteStopMutation) LongitudeCleared() bool {
	_, ok := m.clearedFields[routestop.FieldLongitude]
	return ok
}

// ResetLongitude resets all changes to the "longitude" field.
func (m *RouteStopMutation) ResetLongitude() {
	m.longitude = nil
	m.addlongitude = nil
	delete(m.clearedFields, routestop.FieldLongitude)
}

// SetRouteID sets the "route" edge to the Route entity by id.
func (m *RouteStopMutation) SetRouteID(id int) {
	m.route = &id
}

// ClearRoute clears the "route" edge to the Route entity.
func (m *RouteStopMutation) ClearRoute() {
	m.clearedroute = true
}

// RouteCleared reports if the "route" edge to the Route entity was cleared.
func (m *RouteStopMutation) RouteCleared() bool {
	return m.clearedroute
}

// RouteID returns the "route" edge ID in the mutation.
func (m *RouteStopMutation) RouteID() (id int, exists bool) {
	if m.route != nil {
		return *m.route, true
	}
	return
}

// RouteIDs returns the "route" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// RouteID instead. It exists only for internal usage by the builders.
func (m *RouteStopMutation) RouteIDs() (ids []int) {
	if id := m.route; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetRoute resets all changes to the "route" edge.
func (m *RouteStopMutation) ResetRoute() {
	m.route = nil
	m.clearedroute = false
}

// Where appends a list predicates to the RouteStopMutation builder.
func (m *RouteStopMutation) Where(ps ...predicate.RouteStop) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the RouteStopMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *RouteStopMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.RouteStop, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *RouteStopMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *RouteStopMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (RouteStop).
func (m *RouteStopMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *RouteStopMutation) Fields() []string {
	fields := make([]string, 0, 4)
	if m.created_at != nil {
		fields = append(fields, routestop.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, routestop.FieldUpdatedAt)
	}
	if m.latitude != nil {
		fields = append(fields, routestop.FieldLatitude)
	}
	if m.longitude != nil {
		fields = append(fields, routestop.FieldLongitude)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *RouteStopMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case routestop.FieldCreatedAt:
		return m.CreatedAt()
	case routestop.FieldUpdatedAt:
		return m.UpdatedAt()
	case routestop.FieldLatitude:
		return m.Latitude()
	case routestop.FieldLongitude:
		return m.Longitude()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *RouteStopMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case routestop.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case routestop.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case routestop.FieldLatitude:
		return m.OldLatitude(ctx)
	case routestop.FieldLongitude:
		return m.OldLongitude(ctx)
	}
	return nil, fmt.Errorf("unknown RouteStop field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *RouteStopMutation) SetField(name string, value ent.Value) error {
	switch name {
	case routestop.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case routestop.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case routestop.FieldLatitude:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLatitude(v)
		return nil
	case routestop.FieldLongitude:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLongitude(v)
		return nil
	}
	return fmt.Errorf("unknown RouteStop field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *RouteStopMutation) AddedFields() []string {
	var fields []string
	if m.addlatitude != nil {
		fields = append(fields, routestop.FieldLatitude)
	}
	if m.addlongitude != nil {
		fields = append(fields, routestop.FieldLongitude)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *RouteStopMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case routestop.FieldLatitude:
		return m.AddedLatitude()
	case routestop.FieldLongitude:
		return m.AddedLongitude()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *RouteStopMutation) AddField(name string, value ent.Value) error {
	switch name {
	case routestop.FieldLatitude:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddLatitude(v)
		return nil
	case routestop.FieldLongitude:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddLongitude(v)
		return nil
	}
	return fmt.Errorf("unknown RouteStop numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *RouteStopMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(routestop.FieldLatitude) {
		fields = append(fields, routestop.FieldLatitude)
	}
	if m.FieldCleared(routestop.FieldLongitude) {
		fields = append(fields, routestop.FieldLongitude)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *RouteStopMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *RouteStopMutation) ClearField(name string) error {
	switch name {
	case routestop.FieldLatitude:
		m.ClearLatitude()
		return nil
	case routestop.FieldLongitude:
		m.ClearLongitude()
		return nil
	}
	return fmt.Errorf("unknown RouteStop nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *RouteStopMutation) ResetField(name string) error {
	switch name {
	case routestop.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case routestop.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case routestop.FieldLatitude:
		m.ResetLatitude()
		return nil
	case routestop.FieldLongitude:
		m.ResetLongitude()
		return nil
	}
	return fmt.Errorf("unknown RouteStop field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *RouteStopMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.route != nil {
		edges = append(edges, routestop.EdgeRoute)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *RouteStopMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case routestop.EdgeRoute:
		if id := m.route; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *RouteStopMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *RouteStopMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *RouteStopMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedroute {
		edges = append(edges, routestop.EdgeRoute)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *RouteStopMutation) EdgeCleared(name string) bool {
	switch name {
	case routestop.EdgeRoute:
		return m.clearedroute
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *RouteStopMutation) ClearEdge(name string) error {
	switch name {
	case routestop.EdgeRoute:
		m.ClearRoute()
		return nil
	}
	return fmt.Errorf("unknown RouteStop unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *RouteStopMutation) ResetEdge(name string) error {
	switch name {
	case routestop.EdgeRoute:
		m.ResetRoute()
		return nil
	}
	return fmt.Errorf("unknown RouteStop edge %s", name)
}

// TerminalMutation represents an operation that mutates the Terminal nodes in the graph.
type TerminalMutation struct {
	config
	op             Op
	typ            string
	id             *int
	created_at     *time.Time
	updated_at     *time.Time
	name           *string
	clearedFields  map[string]struct{}
	company        *int
	clearedcompany bool
	from           map[int]struct{}
	removedfrom    map[int]struct{}
	clearedfrom    bool
	to             map[int]struct{}
	removedto      map[int]struct{}
	clearedto      bool
	done           bool
	oldValue       func(context.Context) (*Terminal, error)
	predicates     []predicate.Terminal
}

var _ ent.Mutation = (*TerminalMutation)(nil)

// terminalOption allows management of the mutation configuration using functional options.
type terminalOption func(*TerminalMutation)

// newTerminalMutation creates new mutation for the Terminal entity.
func newTerminalMutation(c config, op Op, opts ...terminalOption) *TerminalMutation {
	m := &TerminalMutation{
		config:        c,
		op:            op,
		typ:           TypeTerminal,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withTerminalID sets the ID field of the mutation.
func withTerminalID(id int) terminalOption {
	return func(m *TerminalMutation) {
		var (
			err   error
			once  sync.Once
			value *Terminal
		)
		m.oldValue = func(ctx context.Context) (*Terminal, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Terminal.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withTerminal sets the old Terminal of the mutation.
func withTerminal(node *Terminal) terminalOption {
	return func(m *TerminalMutation) {
		m.oldValue = func(context.Context) (*Terminal, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m TerminalMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m TerminalMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *TerminalMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *TerminalMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Terminal.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *TerminalMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *TerminalMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Terminal entity.
// If the Terminal object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TerminalMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *TerminalMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *TerminalMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *TerminalMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Terminal entity.
// If the Terminal object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TerminalMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *TerminalMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetName sets the "name" field.
func (m *TerminalMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *TerminalMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Terminal entity.
// If the Terminal object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TerminalMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *TerminalMutation) ResetName() {
	m.name = nil
}

// SetCompanyID sets the "company" edge to the Company entity by id.
func (m *TerminalMutation) SetCompanyID(id int) {
	m.company = &id
}

// ClearCompany clears the "company" edge to the Company entity.
func (m *TerminalMutation) ClearCompany() {
	m.clearedcompany = true
}

// CompanyCleared reports if the "company" edge to the Company entity was cleared.
func (m *TerminalMutation) CompanyCleared() bool {
	return m.clearedcompany
}

// CompanyID returns the "company" edge ID in the mutation.
func (m *TerminalMutation) CompanyID() (id int, exists bool) {
	if m.company != nil {
		return *m.company, true
	}
	return
}

// CompanyIDs returns the "company" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// CompanyID instead. It exists only for internal usage by the builders.
func (m *TerminalMutation) CompanyIDs() (ids []int) {
	if id := m.company; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetCompany resets all changes to the "company" edge.
func (m *TerminalMutation) ResetCompany() {
	m.company = nil
	m.clearedcompany = false
}

// AddFromIDs adds the "from" edge to the Trip entity by ids.
func (m *TerminalMutation) AddFromIDs(ids ...int) {
	if m.from == nil {
		m.from = make(map[int]struct{})
	}
	for i := range ids {
		m.from[ids[i]] = struct{}{}
	}
}

// ClearFrom clears the "from" edge to the Trip entity.
func (m *TerminalMutation) ClearFrom() {
	m.clearedfrom = true
}

// FromCleared reports if the "from" edge to the Trip entity was cleared.
func (m *TerminalMutation) FromCleared() bool {
	return m.clearedfrom
}

// RemoveFromIDs removes the "from" edge to the Trip entity by IDs.
func (m *TerminalMutation) RemoveFromIDs(ids ...int) {
	if m.removedfrom == nil {
		m.removedfrom = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.from, ids[i])
		m.removedfrom[ids[i]] = struct{}{}
	}
}

// RemovedFrom returns the removed IDs of the "from" edge to the Trip entity.
func (m *TerminalMutation) RemovedFromIDs() (ids []int) {
	for id := range m.removedfrom {
		ids = append(ids, id)
	}
	return
}

// FromIDs returns the "from" edge IDs in the mutation.
func (m *TerminalMutation) FromIDs() (ids []int) {
	for id := range m.from {
		ids = append(ids, id)
	}
	return
}

// ResetFrom resets all changes to the "from" edge.
func (m *TerminalMutation) ResetFrom() {
	m.from = nil
	m.clearedfrom = false
	m.removedfrom = nil
}

// AddToIDs adds the "to" edge to the Trip entity by ids.
func (m *TerminalMutation) AddToIDs(ids ...int) {
	if m.to == nil {
		m.to = make(map[int]struct{})
	}
	for i := range ids {
		m.to[ids[i]] = struct{}{}
	}
}

// ClearTo clears the "to" edge to the Trip entity.
func (m *TerminalMutation) ClearTo() {
	m.clearedto = true
}

// ToCleared reports if the "to" edge to the Trip entity was cleared.
func (m *TerminalMutation) ToCleared() bool {
	return m.clearedto
}

// RemoveToIDs removes the "to" edge to the Trip entity by IDs.
func (m *TerminalMutation) RemoveToIDs(ids ...int) {
	if m.removedto == nil {
		m.removedto = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.to, ids[i])
		m.removedto[ids[i]] = struct{}{}
	}
}

// RemovedTo returns the removed IDs of the "to" edge to the Trip entity.
func (m *TerminalMutation) RemovedToIDs() (ids []int) {
	for id := range m.removedto {
		ids = append(ids, id)
	}
	return
}

// ToIDs returns the "to" edge IDs in the mutation.
func (m *TerminalMutation) ToIDs() (ids []int) {
	for id := range m.to {
		ids = append(ids, id)
	}
	return
}

// ResetTo resets all changes to the "to" edge.
func (m *TerminalMutation) ResetTo() {
	m.to = nil
	m.clearedto = false
	m.removedto = nil
}

// Where appends a list predicates to the TerminalMutation builder.
func (m *TerminalMutation) Where(ps ...predicate.Terminal) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the TerminalMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *TerminalMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Terminal, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *TerminalMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *TerminalMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Terminal).
func (m *TerminalMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *TerminalMutation) Fields() []string {
	fields := make([]string, 0, 3)
	if m.created_at != nil {
		fields = append(fields, terminal.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, terminal.FieldUpdatedAt)
	}
	if m.name != nil {
		fields = append(fields, terminal.FieldName)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *TerminalMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case terminal.FieldCreatedAt:
		return m.CreatedAt()
	case terminal.FieldUpdatedAt:
		return m.UpdatedAt()
	case terminal.FieldName:
		return m.Name()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *TerminalMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case terminal.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case terminal.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case terminal.FieldName:
		return m.OldName(ctx)
	}
	return nil, fmt.Errorf("unknown Terminal field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TerminalMutation) SetField(name string, value ent.Value) error {
	switch name {
	case terminal.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case terminal.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case terminal.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	}
	return fmt.Errorf("unknown Terminal field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *TerminalMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *TerminalMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TerminalMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Terminal numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *TerminalMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *TerminalMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *TerminalMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Terminal nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *TerminalMutation) ResetField(name string) error {
	switch name {
	case terminal.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case terminal.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case terminal.FieldName:
		m.ResetName()
		return nil
	}
	return fmt.Errorf("unknown Terminal field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *TerminalMutation) AddedEdges() []string {
	edges := make([]string, 0, 3)
	if m.company != nil {
		edges = append(edges, terminal.EdgeCompany)
	}
	if m.from != nil {
		edges = append(edges, terminal.EdgeFrom)
	}
	if m.to != nil {
		edges = append(edges, terminal.EdgeTo)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *TerminalMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case terminal.EdgeCompany:
		if id := m.company; id != nil {
			return []ent.Value{*id}
		}
	case terminal.EdgeFrom:
		ids := make([]ent.Value, 0, len(m.from))
		for id := range m.from {
			ids = append(ids, id)
		}
		return ids
	case terminal.EdgeTo:
		ids := make([]ent.Value, 0, len(m.to))
		for id := range m.to {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *TerminalMutation) RemovedEdges() []string {
	edges := make([]string, 0, 3)
	if m.removedfrom != nil {
		edges = append(edges, terminal.EdgeFrom)
	}
	if m.removedto != nil {
		edges = append(edges, terminal.EdgeTo)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *TerminalMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case terminal.EdgeFrom:
		ids := make([]ent.Value, 0, len(m.removedfrom))
		for id := range m.removedfrom {
			ids = append(ids, id)
		}
		return ids
	case terminal.EdgeTo:
		ids := make([]ent.Value, 0, len(m.removedto))
		for id := range m.removedto {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *TerminalMutation) ClearedEdges() []string {
	edges := make([]string, 0, 3)
	if m.clearedcompany {
		edges = append(edges, terminal.EdgeCompany)
	}
	if m.clearedfrom {
		edges = append(edges, terminal.EdgeFrom)
	}
	if m.clearedto {
		edges = append(edges, terminal.EdgeTo)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *TerminalMutation) EdgeCleared(name string) bool {
	switch name {
	case terminal.EdgeCompany:
		return m.clearedcompany
	case terminal.EdgeFrom:
		return m.clearedfrom
	case terminal.EdgeTo:
		return m.clearedto
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *TerminalMutation) ClearEdge(name string) error {
	switch name {
	case terminal.EdgeCompany:
		m.ClearCompany()
		return nil
	}
	return fmt.Errorf("unknown Terminal unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *TerminalMutation) ResetEdge(name string) error {
	switch name {
	case terminal.EdgeCompany:
		m.ResetCompany()
		return nil
	case terminal.EdgeFrom:
		m.ResetFrom()
		return nil
	case terminal.EdgeTo:
		m.ResetTo()
		return nil
	}
	return fmt.Errorf("unknown Terminal edge %s", name)
}

// TripMutation represents an operation that mutates the Trip nodes in the graph.
type TripMutation struct {
	config
	op                            Op
	typ                           string
	id                            *int
	created_at                    *time.Time
	updated_at                    *time.Time
	departure_date                *time.Time
	arrival_date                  *time.Time
	return_date                   *time.Time
	_type                         *trip.Type
	exterior_inspected            *bool
	interior_inspected            *bool
	engine_compartment_inspected  *bool
	brake_and_steering_inspected  *bool
	emergency_equipment_inspected *bool
	fuel_and_fluids_inspected     *bool
	scheduled                     *bool
	seat_left                     *int
	addseat_left                  *int
	status                        *trip.Status
	clearedFields                 map[string]struct{}
	company                       *int
	clearedcompany                bool
	_driver                       *int
	cleared_driver                bool
	from_terminal                 *int
	clearedfrom_terminal          bool
	to_terminal                   *int
	clearedto_terminal            bool
	vehicle                       *int
	clearedvehicle                bool
	route                         *int
	clearedroute                  bool
	bookings                      map[int]struct{}
	removedbookings               map[int]struct{}
	clearedbookings               bool
	incidents                     map[int]struct{}
	removedincidents              map[int]struct{}
	clearedincidents              bool
	parcels                       map[int]struct{}
	removedparcels                map[int]struct{}
	clearedparcels                bool
	done                          bool
	oldValue                      func(context.Context) (*Trip, error)
	predicates                    []predicate.Trip
}

var _ ent.Mutation = (*TripMutation)(nil)

// tripOption allows management of the mutation configuration using functional options.
type tripOption func(*TripMutation)

// newTripMutation creates new mutation for the Trip entity.
func newTripMutation(c config, op Op, opts ...tripOption) *TripMutation {
	m := &TripMutation{
		config:        c,
		op:            op,
		typ:           TypeTrip,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withTripID sets the ID field of the mutation.
func withTripID(id int) tripOption {
	return func(m *TripMutation) {
		var (
			err   error
			once  sync.Once
			value *Trip
		)
		m.oldValue = func(ctx context.Context) (*Trip, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Trip.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withTrip sets the old Trip of the mutation.
func withTrip(node *Trip) tripOption {
	return func(m *TripMutation) {
		m.oldValue = func(context.Context) (*Trip, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m TripMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m TripMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *TripMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *TripMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Trip.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *TripMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *TripMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Trip entity.
// If the Trip object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TripMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *TripMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *TripMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *TripMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Trip entity.
// If the Trip object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TripMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *TripMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetDepartureDate sets the "departure_date" field.
func (m *TripMutation) SetDepartureDate(t time.Time) {
	m.departure_date = &t
}

// DepartureDate returns the value of the "departure_date" field in the mutation.
func (m *TripMutation) DepartureDate() (r time.Time, exists bool) {
	v := m.departure_date
	if v == nil {
		return
	}
	return *v, true
}

// OldDepartureDate returns the old "departure_date" field's value of the Trip entity.
// If the Trip object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TripMutation) OldDepartureDate(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDepartureDate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDepartureDate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDepartureDate: %w", err)
	}
	return oldValue.DepartureDate, nil
}

// ClearDepartureDate clears the value of the "departure_date" field.
func (m *TripMutation) ClearDepartureDate() {
	m.departure_date = nil
	m.clearedFields[trip.FieldDepartureDate] = struct{}{}
}

// DepartureDateCleared returns if the "departure_date" field was cleared in this mutation.
func (m *TripMutation) DepartureDateCleared() bool {
	_, ok := m.clearedFields[trip.FieldDepartureDate]
	return ok
}

// ResetDepartureDate resets all changes to the "departure_date" field.
func (m *TripMutation) ResetDepartureDate() {
	m.departure_date = nil
	delete(m.clearedFields, trip.FieldDepartureDate)
}

// SetArrivalDate sets the "arrival_date" field.
func (m *TripMutation) SetArrivalDate(t time.Time) {
	m.arrival_date = &t
}

// ArrivalDate returns the value of the "arrival_date" field in the mutation.
func (m *TripMutation) ArrivalDate() (r time.Time, exists bool) {
	v := m.arrival_date
	if v == nil {
		return
	}
	return *v, true
}

// OldArrivalDate returns the old "arrival_date" field's value of the Trip entity.
// If the Trip object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TripMutation) OldArrivalDate(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldArrivalDate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldArrivalDate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldArrivalDate: %w", err)
	}
	return oldValue.ArrivalDate, nil
}

// ClearArrivalDate clears the value of the "arrival_date" field.
func (m *TripMutation) ClearArrivalDate() {
	m.arrival_date = nil
	m.clearedFields[trip.FieldArrivalDate] = struct{}{}
}

// ArrivalDateCleared returns if the "arrival_date" field was cleared in this mutation.
func (m *TripMutation) ArrivalDateCleared() bool {
	_, ok := m.clearedFields[trip.FieldArrivalDate]
	return ok
}

// ResetArrivalDate resets all changes to the "arrival_date" field.
func (m *TripMutation) ResetArrivalDate() {
	m.arrival_date = nil
	delete(m.clearedFields, trip.FieldArrivalDate)
}

// SetReturnDate sets the "return_date" field.
func (m *TripMutation) SetReturnDate(t time.Time) {
	m.return_date = &t
}

// ReturnDate returns the value of the "return_date" field in the mutation.
func (m *TripMutation) ReturnDate() (r time.Time, exists bool) {
	v := m.return_date
	if v == nil {
		return
	}
	return *v, true
}

// OldReturnDate returns the old "return_date" field's value of the Trip entity.
// If the Trip object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TripMutation) OldReturnDate(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldReturnDate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldReturnDate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldReturnDate: %w", err)
	}
	return oldValue.ReturnDate, nil
}

// ClearReturnDate clears the value of the "return_date" field.
func (m *TripMutation) ClearReturnDate() {
	m.return_date = nil
	m.clearedFields[trip.FieldReturnDate] = struct{}{}
}

// ReturnDateCleared returns if the "return_date" field was cleared in this mutation.
func (m *TripMutation) ReturnDateCleared() bool {
	_, ok := m.clearedFields[trip.FieldReturnDate]
	return ok
}

// ResetReturnDate resets all changes to the "return_date" field.
func (m *TripMutation) ResetReturnDate() {
	m.return_date = nil
	delete(m.clearedFields, trip.FieldReturnDate)
}

// SetType sets the "type" field.
func (m *TripMutation) SetType(t trip.Type) {
	m._type = &t
}

// GetType returns the value of the "type" field in the mutation.
func (m *TripMutation) GetType() (r trip.Type, exists bool) {
	v := m._type
	if v == nil {
		return
	}
	return *v, true
}

// OldType returns the old "type" field's value of the Trip entity.
// If the Trip object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TripMutation) OldType(ctx context.Context) (v trip.Type, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldType: %w", err)
	}
	return oldValue.Type, nil
}

// ResetType resets all changes to the "type" field.
func (m *TripMutation) ResetType() {
	m._type = nil
}

// SetExteriorInspected sets the "exterior_inspected" field.
func (m *TripMutation) SetExteriorInspected(b bool) {
	m.exterior_inspected = &b
}

// ExteriorInspected returns the value of the "exterior_inspected" field in the mutation.
func (m *TripMutation) ExteriorInspected() (r bool, exists bool) {
	v := m.exterior_inspected
	if v == nil {
		return
	}
	return *v, true
}

// OldExteriorInspected returns the old "exterior_inspected" field's value of the Trip entity.
// If the Trip object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TripMutation) OldExteriorInspected(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldExteriorInspected is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldExteriorInspected requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldExteriorInspected: %w", err)
	}
	return oldValue.ExteriorInspected, nil
}

// ResetExteriorInspected resets all changes to the "exterior_inspected" field.
func (m *TripMutation) ResetExteriorInspected() {
	m.exterior_inspected = nil
}

// SetInteriorInspected sets the "interior_inspected" field.
func (m *TripMutation) SetInteriorInspected(b bool) {
	m.interior_inspected = &b
}

// InteriorInspected returns the value of the "interior_inspected" field in the mutation.
func (m *TripMutation) InteriorInspected() (r bool, exists bool) {
	v := m.interior_inspected
	if v == nil {
		return
	}
	return *v, true
}

// OldInteriorInspected returns the old "interior_inspected" field's value of the Trip entity.
// If the Trip object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TripMutation) OldInteriorInspected(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldInteriorInspected is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldInteriorInspected requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldInteriorInspected: %w", err)
	}
	return oldValue.InteriorInspected, nil
}

// ResetInteriorInspected resets all changes to the "interior_inspected" field.
func (m *TripMutation) ResetInteriorInspected() {
	m.interior_inspected = nil
}

// SetEngineCompartmentInspected sets the "engine_compartment_inspected" field.
func (m *TripMutation) SetEngineCompartmentInspected(b bool) {
	m.engine_compartment_inspected = &b
}

// EngineCompartmentInspected returns the value of the "engine_compartment_inspected" field in the mutation.
func (m *TripMutation) EngineCompartmentInspected() (r bool, exists bool) {
	v := m.engine_compartment_inspected
	if v == nil {
		return
	}
	return *v, true
}

// OldEngineCompartmentInspected returns the old "engine_compartment_inspected" field's value of the Trip entity.
// If the Trip object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TripMutation) OldEngineCompartmentInspected(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEngineCompartmentInspected is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEngineCompartmentInspected requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEngineCompartmentInspected: %w", err)
	}
	return oldValue.EngineCompartmentInspected, nil
}

// ResetEngineCompartmentInspected resets all changes to the "engine_compartment_inspected" field.
func (m *TripMutation) ResetEngineCompartmentInspected() {
	m.engine_compartment_inspected = nil
}

// SetBrakeAndSteeringInspected sets the "brake_and_steering_inspected" field.
func (m *TripMutation) SetBrakeAndSteeringInspected(b bool) {
	m.brake_and_steering_inspected = &b
}

// BrakeAndSteeringInspected returns the value of the "brake_and_steering_inspected" field in the mutation.
func (m *TripMutation) BrakeAndSteeringInspected() (r bool, exists bool) {
	v := m.brake_and_steering_inspected
	if v == nil {
		return
	}
	return *v, true
}

// OldBrakeAndSteeringInspected returns the old "brake_and_steering_inspected" field's value of the Trip entity.
// If the Trip object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TripMutation) OldBrakeAndSteeringInspected(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBrakeAndSteeringInspected is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBrakeAndSteeringInspected requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBrakeAndSteeringInspected: %w", err)
	}
	return oldValue.BrakeAndSteeringInspected, nil
}

// ResetBrakeAndSteeringInspected resets all changes to the "brake_and_steering_inspected" field.
func (m *TripMutation) ResetBrakeAndSteeringInspected() {
	m.brake_and_steering_inspected = nil
}

// SetEmergencyEquipmentInspected sets the "emergency_equipment_inspected" field.
func (m *TripMutation) SetEmergencyEquipmentInspected(b bool) {
	m.emergency_equipment_inspected = &b
}

// EmergencyEquipmentInspected returns the value of the "emergency_equipment_inspected" field in the mutation.
func (m *TripMutation) EmergencyEquipmentInspected() (r bool, exists bool) {
	v := m.emergency_equipment_inspected
	if v == nil {
		return
	}
	return *v, true
}

// OldEmergencyEquipmentInspected returns the old "emergency_equipment_inspected" field's value of the Trip entity.
// If the Trip object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TripMutation) OldEmergencyEquipmentInspected(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEmergencyEquipmentInspected is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEmergencyEquipmentInspected requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEmergencyEquipmentInspected: %w", err)
	}
	return oldValue.EmergencyEquipmentInspected, nil
}

// ResetEmergencyEquipmentInspected resets all changes to the "emergency_equipment_inspected" field.
func (m *TripMutation) ResetEmergencyEquipmentInspected() {
	m.emergency_equipment_inspected = nil
}

// SetFuelAndFluidsInspected sets the "fuel_and_fluids_inspected" field.
func (m *TripMutation) SetFuelAndFluidsInspected(b bool) {
	m.fuel_and_fluids_inspected = &b
}

// FuelAndFluidsInspected returns the value of the "fuel_and_fluids_inspected" field in the mutation.
func (m *TripMutation) FuelAndFluidsInspected() (r bool, exists bool) {
	v := m.fuel_and_fluids_inspected
	if v == nil {
		return
	}
	return *v, true
}

// OldFuelAndFluidsInspected returns the old "fuel_and_fluids_inspected" field's value of the Trip entity.
// If the Trip object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TripMutation) OldFuelAndFluidsInspected(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFuelAndFluidsInspected is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFuelAndFluidsInspected requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFuelAndFluidsInspected: %w", err)
	}
	return oldValue.FuelAndFluidsInspected, nil
}

// ResetFuelAndFluidsInspected resets all changes to the "fuel_and_fluids_inspected" field.
func (m *TripMutation) ResetFuelAndFluidsInspected() {
	m.fuel_and_fluids_inspected = nil
}

// SetScheduled sets the "scheduled" field.
func (m *TripMutation) SetScheduled(b bool) {
	m.scheduled = &b
}

// Scheduled returns the value of the "scheduled" field in the mutation.
func (m *TripMutation) Scheduled() (r bool, exists bool) {
	v := m.scheduled
	if v == nil {
		return
	}
	return *v, true
}

// OldScheduled returns the old "scheduled" field's value of the Trip entity.
// If the Trip object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TripMutation) OldScheduled(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldScheduled is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldScheduled requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldScheduled: %w", err)
	}
	return oldValue.Scheduled, nil
}

// ResetScheduled resets all changes to the "scheduled" field.
func (m *TripMutation) ResetScheduled() {
	m.scheduled = nil
}

// SetSeatLeft sets the "seat_left" field.
func (m *TripMutation) SetSeatLeft(i int) {
	m.seat_left = &i
	m.addseat_left = nil
}

// SeatLeft returns the value of the "seat_left" field in the mutation.
func (m *TripMutation) SeatLeft() (r int, exists bool) {
	v := m.seat_left
	if v == nil {
		return
	}
	return *v, true
}

// OldSeatLeft returns the old "seat_left" field's value of the Trip entity.
// If the Trip object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TripMutation) OldSeatLeft(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSeatLeft is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSeatLeft requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSeatLeft: %w", err)
	}
	return oldValue.SeatLeft, nil
}

// AddSeatLeft adds i to the "seat_left" field.
func (m *TripMutation) AddSeatLeft(i int) {
	if m.addseat_left != nil {
		*m.addseat_left += i
	} else {
		m.addseat_left = &i
	}
}

// AddedSeatLeft returns the value that was added to the "seat_left" field in this mutation.
func (m *TripMutation) AddedSeatLeft() (r int, exists bool) {
	v := m.addseat_left
	if v == nil {
		return
	}
	return *v, true
}

// ResetSeatLeft resets all changes to the "seat_left" field.
func (m *TripMutation) ResetSeatLeft() {
	m.seat_left = nil
	m.addseat_left = nil
}

// SetStatus sets the "status" field.
func (m *TripMutation) SetStatus(t trip.Status) {
	m.status = &t
}

// Status returns the value of the "status" field in the mutation.
func (m *TripMutation) Status() (r trip.Status, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the Trip entity.
// If the Trip object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TripMutation) OldStatus(ctx context.Context) (v trip.Status, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ClearStatus clears the value of the "status" field.
func (m *TripMutation) ClearStatus() {
	m.status = nil
	m.clearedFields[trip.FieldStatus] = struct{}{}
}

// StatusCleared returns if the "status" field was cleared in this mutation.
func (m *TripMutation) StatusCleared() bool {
	_, ok := m.clearedFields[trip.FieldStatus]
	return ok
}

// ResetStatus resets all changes to the "status" field.
func (m *TripMutation) ResetStatus() {
	m.status = nil
	delete(m.clearedFields, trip.FieldStatus)
}

// SetCompanyID sets the "company" edge to the Company entity by id.
func (m *TripMutation) SetCompanyID(id int) {
	m.company = &id
}

// ClearCompany clears the "company" edge to the Company entity.
func (m *TripMutation) ClearCompany() {
	m.clearedcompany = true
}

// CompanyCleared reports if the "company" edge to the Company entity was cleared.
func (m *TripMutation) CompanyCleared() bool {
	return m.clearedcompany
}

// CompanyID returns the "company" edge ID in the mutation.
func (m *TripMutation) CompanyID() (id int, exists bool) {
	if m.company != nil {
		return *m.company, true
	}
	return
}

// CompanyIDs returns the "company" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// CompanyID instead. It exists only for internal usage by the builders.
func (m *TripMutation) CompanyIDs() (ids []int) {
	if id := m.company; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetCompany resets all changes to the "company" edge.
func (m *TripMutation) ResetCompany() {
	m.company = nil
	m.clearedcompany = false
}

// SetDriverID sets the "driver" edge to the CompanyUser entity by id.
func (m *TripMutation) SetDriverID(id int) {
	m._driver = &id
}

// ClearDriver clears the "driver" edge to the CompanyUser entity.
func (m *TripMutation) ClearDriver() {
	m.cleared_driver = true
}

// DriverCleared reports if the "driver" edge to the CompanyUser entity was cleared.
func (m *TripMutation) DriverCleared() bool {
	return m.cleared_driver
}

// DriverID returns the "driver" edge ID in the mutation.
func (m *TripMutation) DriverID() (id int, exists bool) {
	if m._driver != nil {
		return *m._driver, true
	}
	return
}

// DriverIDs returns the "driver" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// DriverID instead. It exists only for internal usage by the builders.
func (m *TripMutation) DriverIDs() (ids []int) {
	if id := m._driver; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetDriver resets all changes to the "driver" edge.
func (m *TripMutation) ResetDriver() {
	m._driver = nil
	m.cleared_driver = false
}

// SetFromTerminalID sets the "from_terminal" edge to the Terminal entity by id.
func (m *TripMutation) SetFromTerminalID(id int) {
	m.from_terminal = &id
}

// ClearFromTerminal clears the "from_terminal" edge to the Terminal entity.
func (m *TripMutation) ClearFromTerminal() {
	m.clearedfrom_terminal = true
}

// FromTerminalCleared reports if the "from_terminal" edge to the Terminal entity was cleared.
func (m *TripMutation) FromTerminalCleared() bool {
	return m.clearedfrom_terminal
}

// FromTerminalID returns the "from_terminal" edge ID in the mutation.
func (m *TripMutation) FromTerminalID() (id int, exists bool) {
	if m.from_terminal != nil {
		return *m.from_terminal, true
	}
	return
}

// FromTerminalIDs returns the "from_terminal" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// FromTerminalID instead. It exists only for internal usage by the builders.
func (m *TripMutation) FromTerminalIDs() (ids []int) {
	if id := m.from_terminal; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetFromTerminal resets all changes to the "from_terminal" edge.
func (m *TripMutation) ResetFromTerminal() {
	m.from_terminal = nil
	m.clearedfrom_terminal = false
}

// SetToTerminalID sets the "to_terminal" edge to the Terminal entity by id.
func (m *TripMutation) SetToTerminalID(id int) {
	m.to_terminal = &id
}

// ClearToTerminal clears the "to_terminal" edge to the Terminal entity.
func (m *TripMutation) ClearToTerminal() {
	m.clearedto_terminal = true
}

// ToTerminalCleared reports if the "to_terminal" edge to the Terminal entity was cleared.
func (m *TripMutation) ToTerminalCleared() bool {
	return m.clearedto_terminal
}

// ToTerminalID returns the "to_terminal" edge ID in the mutation.
func (m *TripMutation) ToTerminalID() (id int, exists bool) {
	if m.to_terminal != nil {
		return *m.to_terminal, true
	}
	return
}

// ToTerminalIDs returns the "to_terminal" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ToTerminalID instead. It exists only for internal usage by the builders.
func (m *TripMutation) ToTerminalIDs() (ids []int) {
	if id := m.to_terminal; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetToTerminal resets all changes to the "to_terminal" edge.
func (m *TripMutation) ResetToTerminal() {
	m.to_terminal = nil
	m.clearedto_terminal = false
}

// SetVehicleID sets the "vehicle" edge to the Vehicle entity by id.
func (m *TripMutation) SetVehicleID(id int) {
	m.vehicle = &id
}

// ClearVehicle clears the "vehicle" edge to the Vehicle entity.
func (m *TripMutation) ClearVehicle() {
	m.clearedvehicle = true
}

// VehicleCleared reports if the "vehicle" edge to the Vehicle entity was cleared.
func (m *TripMutation) VehicleCleared() bool {
	return m.clearedvehicle
}

// VehicleID returns the "vehicle" edge ID in the mutation.
func (m *TripMutation) VehicleID() (id int, exists bool) {
	if m.vehicle != nil {
		return *m.vehicle, true
	}
	return
}

// VehicleIDs returns the "vehicle" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// VehicleID instead. It exists only for internal usage by the builders.
func (m *TripMutation) VehicleIDs() (ids []int) {
	if id := m.vehicle; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetVehicle resets all changes to the "vehicle" edge.
func (m *TripMutation) ResetVehicle() {
	m.vehicle = nil
	m.clearedvehicle = false
}

// SetRouteID sets the "route" edge to the Route entity by id.
func (m *TripMutation) SetRouteID(id int) {
	m.route = &id
}

// ClearRoute clears the "route" edge to the Route entity.
func (m *TripMutation) ClearRoute() {
	m.clearedroute = true
}

// RouteCleared reports if the "route" edge to the Route entity was cleared.
func (m *TripMutation) RouteCleared() bool {
	return m.clearedroute
}

// RouteID returns the "route" edge ID in the mutation.
func (m *TripMutation) RouteID() (id int, exists bool) {
	if m.route != nil {
		return *m.route, true
	}
	return
}

// RouteIDs returns the "route" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// RouteID instead. It exists only for internal usage by the builders.
func (m *TripMutation) RouteIDs() (ids []int) {
	if id := m.route; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetRoute resets all changes to the "route" edge.
func (m *TripMutation) ResetRoute() {
	m.route = nil
	m.clearedroute = false
}

// AddBookingIDs adds the "bookings" edge to the Booking entity by ids.
func (m *TripMutation) AddBookingIDs(ids ...int) {
	if m.bookings == nil {
		m.bookings = make(map[int]struct{})
	}
	for i := range ids {
		m.bookings[ids[i]] = struct{}{}
	}
}

// ClearBookings clears the "bookings" edge to the Booking entity.
func (m *TripMutation) ClearBookings() {
	m.clearedbookings = true
}

// BookingsCleared reports if the "bookings" edge to the Booking entity was cleared.
func (m *TripMutation) BookingsCleared() bool {
	return m.clearedbookings
}

// RemoveBookingIDs removes the "bookings" edge to the Booking entity by IDs.
func (m *TripMutation) RemoveBookingIDs(ids ...int) {
	if m.removedbookings == nil {
		m.removedbookings = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.bookings, ids[i])
		m.removedbookings[ids[i]] = struct{}{}
	}
}

// RemovedBookings returns the removed IDs of the "bookings" edge to the Booking entity.
func (m *TripMutation) RemovedBookingsIDs() (ids []int) {
	for id := range m.removedbookings {
		ids = append(ids, id)
	}
	return
}

// BookingsIDs returns the "bookings" edge IDs in the mutation.
func (m *TripMutation) BookingsIDs() (ids []int) {
	for id := range m.bookings {
		ids = append(ids, id)
	}
	return
}

// ResetBookings resets all changes to the "bookings" edge.
func (m *TripMutation) ResetBookings() {
	m.bookings = nil
	m.clearedbookings = false
	m.removedbookings = nil
}

// AddIncidentIDs adds the "incidents" edge to the Incident entity by ids.
func (m *TripMutation) AddIncidentIDs(ids ...int) {
	if m.incidents == nil {
		m.incidents = make(map[int]struct{})
	}
	for i := range ids {
		m.incidents[ids[i]] = struct{}{}
	}
}

// ClearIncidents clears the "incidents" edge to the Incident entity.
func (m *TripMutation) ClearIncidents() {
	m.clearedincidents = true
}

// IncidentsCleared reports if the "incidents" edge to the Incident entity was cleared.
func (m *TripMutation) IncidentsCleared() bool {
	return m.clearedincidents
}

// RemoveIncidentIDs removes the "incidents" edge to the Incident entity by IDs.
func (m *TripMutation) RemoveIncidentIDs(ids ...int) {
	if m.removedincidents == nil {
		m.removedincidents = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.incidents, ids[i])
		m.removedincidents[ids[i]] = struct{}{}
	}
}

// RemovedIncidents returns the removed IDs of the "incidents" edge to the Incident entity.
func (m *TripMutation) RemovedIncidentsIDs() (ids []int) {
	for id := range m.removedincidents {
		ids = append(ids, id)
	}
	return
}

// IncidentsIDs returns the "incidents" edge IDs in the mutation.
func (m *TripMutation) IncidentsIDs() (ids []int) {
	for id := range m.incidents {
		ids = append(ids, id)
	}
	return
}

// ResetIncidents resets all changes to the "incidents" edge.
func (m *TripMutation) ResetIncidents() {
	m.incidents = nil
	m.clearedincidents = false
	m.removedincidents = nil
}

// AddParcelIDs adds the "parcels" edge to the Parcel entity by ids.
func (m *TripMutation) AddParcelIDs(ids ...int) {
	if m.parcels == nil {
		m.parcels = make(map[int]struct{})
	}
	for i := range ids {
		m.parcels[ids[i]] = struct{}{}
	}
}

// ClearParcels clears the "parcels" edge to the Parcel entity.
func (m *TripMutation) ClearParcels() {
	m.clearedparcels = true
}

// ParcelsCleared reports if the "parcels" edge to the Parcel entity was cleared.
func (m *TripMutation) ParcelsCleared() bool {
	return m.clearedparcels
}

// RemoveParcelIDs removes the "parcels" edge to the Parcel entity by IDs.
func (m *TripMutation) RemoveParcelIDs(ids ...int) {
	if m.removedparcels == nil {
		m.removedparcels = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.parcels, ids[i])
		m.removedparcels[ids[i]] = struct{}{}
	}
}

// RemovedParcels returns the removed IDs of the "parcels" edge to the Parcel entity.
func (m *TripMutation) RemovedParcelsIDs() (ids []int) {
	for id := range m.removedparcels {
		ids = append(ids, id)
	}
	return
}

// ParcelsIDs returns the "parcels" edge IDs in the mutation.
func (m *TripMutation) ParcelsIDs() (ids []int) {
	for id := range m.parcels {
		ids = append(ids, id)
	}
	return
}

// ResetParcels resets all changes to the "parcels" edge.
func (m *TripMutation) ResetParcels() {
	m.parcels = nil
	m.clearedparcels = false
	m.removedparcels = nil
}

// Where appends a list predicates to the TripMutation builder.
func (m *TripMutation) Where(ps ...predicate.Trip) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the TripMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *TripMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Trip, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *TripMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *TripMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Trip).
func (m *TripMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *TripMutation) Fields() []string {
	fields := make([]string, 0, 15)
	if m.created_at != nil {
		fields = append(fields, trip.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, trip.FieldUpdatedAt)
	}
	if m.departure_date != nil {
		fields = append(fields, trip.FieldDepartureDate)
	}
	if m.arrival_date != nil {
		fields = append(fields, trip.FieldArrivalDate)
	}
	if m.return_date != nil {
		fields = append(fields, trip.FieldReturnDate)
	}
	if m._type != nil {
		fields = append(fields, trip.FieldType)
	}
	if m.exterior_inspected != nil {
		fields = append(fields, trip.FieldExteriorInspected)
	}
	if m.interior_inspected != nil {
		fields = append(fields, trip.FieldInteriorInspected)
	}
	if m.engine_compartment_inspected != nil {
		fields = append(fields, trip.FieldEngineCompartmentInspected)
	}
	if m.brake_and_steering_inspected != nil {
		fields = append(fields, trip.FieldBrakeAndSteeringInspected)
	}
	if m.emergency_equipment_inspected != nil {
		fields = append(fields, trip.FieldEmergencyEquipmentInspected)
	}
	if m.fuel_and_fluids_inspected != nil {
		fields = append(fields, trip.FieldFuelAndFluidsInspected)
	}
	if m.scheduled != nil {
		fields = append(fields, trip.FieldScheduled)
	}
	if m.seat_left != nil {
		fields = append(fields, trip.FieldSeatLeft)
	}
	if m.status != nil {
		fields = append(fields, trip.FieldStatus)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *TripMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case trip.FieldCreatedAt:
		return m.CreatedAt()
	case trip.FieldUpdatedAt:
		return m.UpdatedAt()
	case trip.FieldDepartureDate:
		return m.DepartureDate()
	case trip.FieldArrivalDate:
		return m.ArrivalDate()
	case trip.FieldReturnDate:
		return m.ReturnDate()
	case trip.FieldType:
		return m.GetType()
	case trip.FieldExteriorInspected:
		return m.ExteriorInspected()
	case trip.FieldInteriorInspected:
		return m.InteriorInspected()
	case trip.FieldEngineCompartmentInspected:
		return m.EngineCompartmentInspected()
	case trip.FieldBrakeAndSteeringInspected:
		return m.BrakeAndSteeringInspected()
	case trip.FieldEmergencyEquipmentInspected:
		return m.EmergencyEquipmentInspected()
	case trip.FieldFuelAndFluidsInspected:
		return m.FuelAndFluidsInspected()
	case trip.FieldScheduled:
		return m.Scheduled()
	case trip.FieldSeatLeft:
		return m.SeatLeft()
	case trip.FieldStatus:
		return m.Status()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *TripMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case trip.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case trip.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case trip.FieldDepartureDate:
		return m.OldDepartureDate(ctx)
	case trip.FieldArrivalDate:
		return m.OldArrivalDate(ctx)
	case trip.FieldReturnDate:
		return m.OldReturnDate(ctx)
	case trip.FieldType:
		return m.OldType(ctx)
	case trip.FieldExteriorInspected:
		return m.OldExteriorInspected(ctx)
	case trip.FieldInteriorInspected:
		return m.OldInteriorInspected(ctx)
	case trip.FieldEngineCompartmentInspected:
		return m.OldEngineCompartmentInspected(ctx)
	case trip.FieldBrakeAndSteeringInspected:
		return m.OldBrakeAndSteeringInspected(ctx)
	case trip.FieldEmergencyEquipmentInspected:
		return m.OldEmergencyEquipmentInspected(ctx)
	case trip.FieldFuelAndFluidsInspected:
		return m.OldFuelAndFluidsInspected(ctx)
	case trip.FieldScheduled:
		return m.OldScheduled(ctx)
	case trip.FieldSeatLeft:
		return m.OldSeatLeft(ctx)
	case trip.FieldStatus:
		return m.OldStatus(ctx)
	}
	return nil, fmt.Errorf("unknown Trip field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TripMutation) SetField(name string, value ent.Value) error {
	switch name {
	case trip.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case trip.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case trip.FieldDepartureDate:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDepartureDate(v)
		return nil
	case trip.FieldArrivalDate:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetArrivalDate(v)
		return nil
	case trip.FieldReturnDate:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetReturnDate(v)
		return nil
	case trip.FieldType:
		v, ok := value.(trip.Type)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetType(v)
		return nil
	case trip.FieldExteriorInspected:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetExteriorInspected(v)
		return nil
	case trip.FieldInteriorInspected:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetInteriorInspected(v)
		return nil
	case trip.FieldEngineCompartmentInspected:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEngineCompartmentInspected(v)
		return nil
	case trip.FieldBrakeAndSteeringInspected:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBrakeAndSteeringInspected(v)
		return nil
	case trip.FieldEmergencyEquipmentInspected:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEmergencyEquipmentInspected(v)
		return nil
	case trip.FieldFuelAndFluidsInspected:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFuelAndFluidsInspected(v)
		return nil
	case trip.FieldScheduled:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetScheduled(v)
		return nil
	case trip.FieldSeatLeft:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSeatLeft(v)
		return nil
	case trip.FieldStatus:
		v, ok := value.(trip.Status)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	}
	return fmt.Errorf("unknown Trip field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *TripMutation) AddedFields() []string {
	var fields []string
	if m.addseat_left != nil {
		fields = append(fields, trip.FieldSeatLeft)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *TripMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case trip.FieldSeatLeft:
		return m.AddedSeatLeft()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TripMutation) AddField(name string, value ent.Value) error {
	switch name {
	case trip.FieldSeatLeft:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddSeatLeft(v)
		return nil
	}
	return fmt.Errorf("unknown Trip numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *TripMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(trip.FieldDepartureDate) {
		fields = append(fields, trip.FieldDepartureDate)
	}
	if m.FieldCleared(trip.FieldArrivalDate) {
		fields = append(fields, trip.FieldArrivalDate)
	}
	if m.FieldCleared(trip.FieldReturnDate) {
		fields = append(fields, trip.FieldReturnDate)
	}
	if m.FieldCleared(trip.FieldStatus) {
		fields = append(fields, trip.FieldStatus)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *TripMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *TripMutation) ClearField(name string) error {
	switch name {
	case trip.FieldDepartureDate:
		m.ClearDepartureDate()
		return nil
	case trip.FieldArrivalDate:
		m.ClearArrivalDate()
		return nil
	case trip.FieldReturnDate:
		m.ClearReturnDate()
		return nil
	case trip.FieldStatus:
		m.ClearStatus()
		return nil
	}
	return fmt.Errorf("unknown Trip nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *TripMutation) ResetField(name string) error {
	switch name {
	case trip.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case trip.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case trip.FieldDepartureDate:
		m.ResetDepartureDate()
		return nil
	case trip.FieldArrivalDate:
		m.ResetArrivalDate()
		return nil
	case trip.FieldReturnDate:
		m.ResetReturnDate()
		return nil
	case trip.FieldType:
		m.ResetType()
		return nil
	case trip.FieldExteriorInspected:
		m.ResetExteriorInspected()
		return nil
	case trip.FieldInteriorInspected:
		m.ResetInteriorInspected()
		return nil
	case trip.FieldEngineCompartmentInspected:
		m.ResetEngineCompartmentInspected()
		return nil
	case trip.FieldBrakeAndSteeringInspected:
		m.ResetBrakeAndSteeringInspected()
		return nil
	case trip.FieldEmergencyEquipmentInspected:
		m.ResetEmergencyEquipmentInspected()
		return nil
	case trip.FieldFuelAndFluidsInspected:
		m.ResetFuelAndFluidsInspected()
		return nil
	case trip.FieldScheduled:
		m.ResetScheduled()
		return nil
	case trip.FieldSeatLeft:
		m.ResetSeatLeft()
		return nil
	case trip.FieldStatus:
		m.ResetStatus()
		return nil
	}
	return fmt.Errorf("unknown Trip field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *TripMutation) AddedEdges() []string {
	edges := make([]string, 0, 9)
	if m.company != nil {
		edges = append(edges, trip.EdgeCompany)
	}
	if m._driver != nil {
		edges = append(edges, trip.EdgeDriver)
	}
	if m.from_terminal != nil {
		edges = append(edges, trip.EdgeFromTerminal)
	}
	if m.to_terminal != nil {
		edges = append(edges, trip.EdgeToTerminal)
	}
	if m.vehicle != nil {
		edges = append(edges, trip.EdgeVehicle)
	}
	if m.route != nil {
		edges = append(edges, trip.EdgeRoute)
	}
	if m.bookings != nil {
		edges = append(edges, trip.EdgeBookings)
	}
	if m.incidents != nil {
		edges = append(edges, trip.EdgeIncidents)
	}
	if m.parcels != nil {
		edges = append(edges, trip.EdgeParcels)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *TripMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case trip.EdgeCompany:
		if id := m.company; id != nil {
			return []ent.Value{*id}
		}
	case trip.EdgeDriver:
		if id := m._driver; id != nil {
			return []ent.Value{*id}
		}
	case trip.EdgeFromTerminal:
		if id := m.from_terminal; id != nil {
			return []ent.Value{*id}
		}
	case trip.EdgeToTerminal:
		if id := m.to_terminal; id != nil {
			return []ent.Value{*id}
		}
	case trip.EdgeVehicle:
		if id := m.vehicle; id != nil {
			return []ent.Value{*id}
		}
	case trip.EdgeRoute:
		if id := m.route; id != nil {
			return []ent.Value{*id}
		}
	case trip.EdgeBookings:
		ids := make([]ent.Value, 0, len(m.bookings))
		for id := range m.bookings {
			ids = append(ids, id)
		}
		return ids
	case trip.EdgeIncidents:
		ids := make([]ent.Value, 0, len(m.incidents))
		for id := range m.incidents {
			ids = append(ids, id)
		}
		return ids
	case trip.EdgeParcels:
		ids := make([]ent.Value, 0, len(m.parcels))
		for id := range m.parcels {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *TripMutation) RemovedEdges() []string {
	edges := make([]string, 0, 9)
	if m.removedbookings != nil {
		edges = append(edges, trip.EdgeBookings)
	}
	if m.removedincidents != nil {
		edges = append(edges, trip.EdgeIncidents)
	}
	if m.removedparcels != nil {
		edges = append(edges, trip.EdgeParcels)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *TripMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case trip.EdgeBookings:
		ids := make([]ent.Value, 0, len(m.removedbookings))
		for id := range m.removedbookings {
			ids = append(ids, id)
		}
		return ids
	case trip.EdgeIncidents:
		ids := make([]ent.Value, 0, len(m.removedincidents))
		for id := range m.removedincidents {
			ids = append(ids, id)
		}
		return ids
	case trip.EdgeParcels:
		ids := make([]ent.Value, 0, len(m.removedparcels))
		for id := range m.removedparcels {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *TripMutation) ClearedEdges() []string {
	edges := make([]string, 0, 9)
	if m.clearedcompany {
		edges = append(edges, trip.EdgeCompany)
	}
	if m.cleared_driver {
		edges = append(edges, trip.EdgeDriver)
	}
	if m.clearedfrom_terminal {
		edges = append(edges, trip.EdgeFromTerminal)
	}
	if m.clearedto_terminal {
		edges = append(edges, trip.EdgeToTerminal)
	}
	if m.clearedvehicle {
		edges = append(edges, trip.EdgeVehicle)
	}
	if m.clearedroute {
		edges = append(edges, trip.EdgeRoute)
	}
	if m.clearedbookings {
		edges = append(edges, trip.EdgeBookings)
	}
	if m.clearedincidents {
		edges = append(edges, trip.EdgeIncidents)
	}
	if m.clearedparcels {
		edges = append(edges, trip.EdgeParcels)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *TripMutation) EdgeCleared(name string) bool {
	switch name {
	case trip.EdgeCompany:
		return m.clearedcompany
	case trip.EdgeDriver:
		return m.cleared_driver
	case trip.EdgeFromTerminal:
		return m.clearedfrom_terminal
	case trip.EdgeToTerminal:
		return m.clearedto_terminal
	case trip.EdgeVehicle:
		return m.clearedvehicle
	case trip.EdgeRoute:
		return m.clearedroute
	case trip.EdgeBookings:
		return m.clearedbookings
	case trip.EdgeIncidents:
		return m.clearedincidents
	case trip.EdgeParcels:
		return m.clearedparcels
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *TripMutation) ClearEdge(name string) error {
	switch name {
	case trip.EdgeCompany:
		m.ClearCompany()
		return nil
	case trip.EdgeDriver:
		m.ClearDriver()
		return nil
	case trip.EdgeFromTerminal:
		m.ClearFromTerminal()
		return nil
	case trip.EdgeToTerminal:
		m.ClearToTerminal()
		return nil
	case trip.EdgeVehicle:
		m.ClearVehicle()
		return nil
	case trip.EdgeRoute:
		m.ClearRoute()
		return nil
	}
	return fmt.Errorf("unknown Trip unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *TripMutation) ResetEdge(name string) error {
	switch name {
	case trip.EdgeCompany:
		m.ResetCompany()
		return nil
	case trip.EdgeDriver:
		m.ResetDriver()
		return nil
	case trip.EdgeFromTerminal:
		m.ResetFromTerminal()
		return nil
	case trip.EdgeToTerminal:
		m.ResetToTerminal()
		return nil
	case trip.EdgeVehicle:
		m.ResetVehicle()
		return nil
	case trip.EdgeRoute:
		m.ResetRoute()
		return nil
	case trip.EdgeBookings:
		m.ResetBookings()
		return nil
	case trip.EdgeIncidents:
		m.ResetIncidents()
		return nil
	case trip.EdgeParcels:
		m.ResetParcels()
		return nil
	}
	return fmt.Errorf("unknown Trip edge %s", name)
}

// UserMutation represents an operation that mutates the User nodes in the graph.
type UserMutation struct {
	config
	op                   Op
	typ                  string
	id                   *int
	created_at           *time.Time
	updated_at           *time.Time
	username             *string
	password             *[]byte
	_type                *user.Type
	clearedFields        map[string]struct{}
	bookibus_user        *int
	clearedbookibus_user bool
	company_user         *int
	clearedcompany_user  bool
	customer             *int
	clearedcustomer      bool
	done                 bool
	oldValue             func(context.Context) (*User, error)
	predicates           []predicate.User
}

var _ ent.Mutation = (*UserMutation)(nil)

// userOption allows management of the mutation configuration using functional options.
type userOption func(*UserMutation)

// newUserMutation creates new mutation for the User entity.
func newUserMutation(c config, op Op, opts ...userOption) *UserMutation {
	m := &UserMutation{
		config:        c,
		op:            op,
		typ:           TypeUser,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withUserID sets the ID field of the mutation.
func withUserID(id int) userOption {
	return func(m *UserMutation) {
		var (
			err   error
			once  sync.Once
			value *User
		)
		m.oldValue = func(ctx context.Context) (*User, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().User.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withUser sets the old User of the mutation.
func withUser(node *User) userOption {
	return func(m *UserMutation) {
		m.oldValue = func(context.Context) (*User, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m UserMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m UserMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *UserMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *UserMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().User.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *UserMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *UserMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *UserMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *UserMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *UserMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *UserMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetUsername sets the "username" field.
func (m *UserMutation) SetUsername(s string) {
	m.username = &s
}

// Username returns the value of the "username" field in the mutation.
func (m *UserMutation) Username() (r string, exists bool) {
	v := m.username
	if v == nil {
		return
	}
	return *v, true
}

// OldUsername returns the old "username" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldUsername(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUsername is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUsername requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUsername: %w", err)
	}
	return oldValue.Username, nil
}

// ResetUsername resets all changes to the "username" field.
func (m *UserMutation) ResetUsername() {
	m.username = nil
}

// SetPassword sets the "password" field.
func (m *UserMutation) SetPassword(b []byte) {
	m.password = &b
}

// Password returns the value of the "password" field in the mutation.
func (m *UserMutation) Password() (r []byte, exists bool) {
	v := m.password
	if v == nil {
		return
	}
	return *v, true
}

// OldPassword returns the old "password" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldPassword(ctx context.Context) (v []byte, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPassword is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPassword requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPassword: %w", err)
	}
	return oldValue.Password, nil
}

// ResetPassword resets all changes to the "password" field.
func (m *UserMutation) ResetPassword() {
	m.password = nil
}

// SetType sets the "type" field.
func (m *UserMutation) SetType(u user.Type) {
	m._type = &u
}

// GetType returns the value of the "type" field in the mutation.
func (m *UserMutation) GetType() (r user.Type, exists bool) {
	v := m._type
	if v == nil {
		return
	}
	return *v, true
}

// OldType returns the old "type" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldType(ctx context.Context) (v user.Type, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldType: %w", err)
	}
	return oldValue.Type, nil
}

// ResetType resets all changes to the "type" field.
func (m *UserMutation) ResetType() {
	m._type = nil
}

// SetBookibusUserID sets the "bookibus_user" edge to the BookibusUser entity by id.
func (m *UserMutation) SetBookibusUserID(id int) {
	m.bookibus_user = &id
}

// ClearBookibusUser clears the "bookibus_user" edge to the BookibusUser entity.
func (m *UserMutation) ClearBookibusUser() {
	m.clearedbookibus_user = true
}

// BookibusUserCleared reports if the "bookibus_user" edge to the BookibusUser entity was cleared.
func (m *UserMutation) BookibusUserCleared() bool {
	return m.clearedbookibus_user
}

// BookibusUserID returns the "bookibus_user" edge ID in the mutation.
func (m *UserMutation) BookibusUserID() (id int, exists bool) {
	if m.bookibus_user != nil {
		return *m.bookibus_user, true
	}
	return
}

// BookibusUserIDs returns the "bookibus_user" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// BookibusUserID instead. It exists only for internal usage by the builders.
func (m *UserMutation) BookibusUserIDs() (ids []int) {
	if id := m.bookibus_user; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetBookibusUser resets all changes to the "bookibus_user" edge.
func (m *UserMutation) ResetBookibusUser() {
	m.bookibus_user = nil
	m.clearedbookibus_user = false
}

// SetCompanyUserID sets the "company_user" edge to the CompanyUser entity by id.
func (m *UserMutation) SetCompanyUserID(id int) {
	m.company_user = &id
}

// ClearCompanyUser clears the "company_user" edge to the CompanyUser entity.
func (m *UserMutation) ClearCompanyUser() {
	m.clearedcompany_user = true
}

// CompanyUserCleared reports if the "company_user" edge to the CompanyUser entity was cleared.
func (m *UserMutation) CompanyUserCleared() bool {
	return m.clearedcompany_user
}

// CompanyUserID returns the "company_user" edge ID in the mutation.
func (m *UserMutation) CompanyUserID() (id int, exists bool) {
	if m.company_user != nil {
		return *m.company_user, true
	}
	return
}

// CompanyUserIDs returns the "company_user" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// CompanyUserID instead. It exists only for internal usage by the builders.
func (m *UserMutation) CompanyUserIDs() (ids []int) {
	if id := m.company_user; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetCompanyUser resets all changes to the "company_user" edge.
func (m *UserMutation) ResetCompanyUser() {
	m.company_user = nil
	m.clearedcompany_user = false
}

// SetCustomerID sets the "customer" edge to the Customer entity by id.
func (m *UserMutation) SetCustomerID(id int) {
	m.customer = &id
}

// ClearCustomer clears the "customer" edge to the Customer entity.
func (m *UserMutation) ClearCustomer() {
	m.clearedcustomer = true
}

// CustomerCleared reports if the "customer" edge to the Customer entity was cleared.
func (m *UserMutation) CustomerCleared() bool {
	return m.clearedcustomer
}

// CustomerID returns the "customer" edge ID in the mutation.
func (m *UserMutation) CustomerID() (id int, exists bool) {
	if m.customer != nil {
		return *m.customer, true
	}
	return
}

// CustomerIDs returns the "customer" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// CustomerID instead. It exists only for internal usage by the builders.
func (m *UserMutation) CustomerIDs() (ids []int) {
	if id := m.customer; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetCustomer resets all changes to the "customer" edge.
func (m *UserMutation) ResetCustomer() {
	m.customer = nil
	m.clearedcustomer = false
}

// Where appends a list predicates to the UserMutation builder.
func (m *UserMutation) Where(ps ...predicate.User) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the UserMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *UserMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.User, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *UserMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *UserMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (User).
func (m *UserMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *UserMutation) Fields() []string {
	fields := make([]string, 0, 5)
	if m.created_at != nil {
		fields = append(fields, user.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, user.FieldUpdatedAt)
	}
	if m.username != nil {
		fields = append(fields, user.FieldUsername)
	}
	if m.password != nil {
		fields = append(fields, user.FieldPassword)
	}
	if m._type != nil {
		fields = append(fields, user.FieldType)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *UserMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case user.FieldCreatedAt:
		return m.CreatedAt()
	case user.FieldUpdatedAt:
		return m.UpdatedAt()
	case user.FieldUsername:
		return m.Username()
	case user.FieldPassword:
		return m.Password()
	case user.FieldType:
		return m.GetType()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *UserMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case user.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case user.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case user.FieldUsername:
		return m.OldUsername(ctx)
	case user.FieldPassword:
		return m.OldPassword(ctx)
	case user.FieldType:
		return m.OldType(ctx)
	}
	return nil, fmt.Errorf("unknown User field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserMutation) SetField(name string, value ent.Value) error {
	switch name {
	case user.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case user.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case user.FieldUsername:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUsername(v)
		return nil
	case user.FieldPassword:
		v, ok := value.([]byte)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPassword(v)
		return nil
	case user.FieldType:
		v, ok := value.(user.Type)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetType(v)
		return nil
	}
	return fmt.Errorf("unknown User field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *UserMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *UserMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown User numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *UserMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *UserMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *UserMutation) ClearField(name string) error {
	return fmt.Errorf("unknown User nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *UserMutation) ResetField(name string) error {
	switch name {
	case user.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case user.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case user.FieldUsername:
		m.ResetUsername()
		return nil
	case user.FieldPassword:
		m.ResetPassword()
		return nil
	case user.FieldType:
		m.ResetType()
		return nil
	}
	return fmt.Errorf("unknown User field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *UserMutation) AddedEdges() []string {
	edges := make([]string, 0, 3)
	if m.bookibus_user != nil {
		edges = append(edges, user.EdgeBookibusUser)
	}
	if m.company_user != nil {
		edges = append(edges, user.EdgeCompanyUser)
	}
	if m.customer != nil {
		edges = append(edges, user.EdgeCustomer)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *UserMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case user.EdgeBookibusUser:
		if id := m.bookibus_user; id != nil {
			return []ent.Value{*id}
		}
	case user.EdgeCompanyUser:
		if id := m.company_user; id != nil {
			return []ent.Value{*id}
		}
	case user.EdgeCustomer:
		if id := m.customer; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *UserMutation) RemovedEdges() []string {
	edges := make([]string, 0, 3)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *UserMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *UserMutation) ClearedEdges() []string {
	edges := make([]string, 0, 3)
	if m.clearedbookibus_user {
		edges = append(edges, user.EdgeBookibusUser)
	}
	if m.clearedcompany_user {
		edges = append(edges, user.EdgeCompanyUser)
	}
	if m.clearedcustomer {
		edges = append(edges, user.EdgeCustomer)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *UserMutation) EdgeCleared(name string) bool {
	switch name {
	case user.EdgeBookibusUser:
		return m.clearedbookibus_user
	case user.EdgeCompanyUser:
		return m.clearedcompany_user
	case user.EdgeCustomer:
		return m.clearedcustomer
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *UserMutation) ClearEdge(name string) error {
	switch name {
	case user.EdgeBookibusUser:
		m.ClearBookibusUser()
		return nil
	case user.EdgeCompanyUser:
		m.ClearCompanyUser()
		return nil
	case user.EdgeCustomer:
		m.ClearCustomer()
		return nil
	}
	return fmt.Errorf("unknown User unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *UserMutation) ResetEdge(name string) error {
	switch name {
	case user.EdgeBookibusUser:
		m.ResetBookibusUser()
		return nil
	case user.EdgeCompanyUser:
		m.ResetCompanyUser()
		return nil
	case user.EdgeCustomer:
		m.ResetCustomer()
		return nil
	}
	return fmt.Errorf("unknown User edge %s", name)
}

// VehicleMutation represents an operation that mutates the Vehicle nodes in the graph.
type VehicleMutation struct {
	config
	op                  Op
	typ                 string
	id                  *int
	created_at          *time.Time
	updated_at          *time.Time
	registration_number *string
	model               *string
	seat                *int
	addseat             *int
	clearedFields       map[string]struct{}
	company             *int
	clearedcompany      bool
	images              map[int]struct{}
	removedimages       map[int]struct{}
	clearedimages       bool
	trips               map[int]struct{}
	removedtrips        map[int]struct{}
	clearedtrips        bool
	done                bool
	oldValue            func(context.Context) (*Vehicle, error)
	predicates          []predicate.Vehicle
}

var _ ent.Mutation = (*VehicleMutation)(nil)

// vehicleOption allows management of the mutation configuration using functional options.
type vehicleOption func(*VehicleMutation)

// newVehicleMutation creates new mutation for the Vehicle entity.
func newVehicleMutation(c config, op Op, opts ...vehicleOption) *VehicleMutation {
	m := &VehicleMutation{
		config:        c,
		op:            op,
		typ:           TypeVehicle,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withVehicleID sets the ID field of the mutation.
func withVehicleID(id int) vehicleOption {
	return func(m *VehicleMutation) {
		var (
			err   error
			once  sync.Once
			value *Vehicle
		)
		m.oldValue = func(ctx context.Context) (*Vehicle, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Vehicle.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withVehicle sets the old Vehicle of the mutation.
func withVehicle(node *Vehicle) vehicleOption {
	return func(m *VehicleMutation) {
		m.oldValue = func(context.Context) (*Vehicle, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m VehicleMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m VehicleMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *VehicleMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *VehicleMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Vehicle.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *VehicleMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *VehicleMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Vehicle entity.
// If the Vehicle object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VehicleMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *VehicleMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *VehicleMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *VehicleMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Vehicle entity.
// If the Vehicle object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VehicleMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *VehicleMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetRegistrationNumber sets the "registration_number" field.
func (m *VehicleMutation) SetRegistrationNumber(s string) {
	m.registration_number = &s
}

// RegistrationNumber returns the value of the "registration_number" field in the mutation.
func (m *VehicleMutation) RegistrationNumber() (r string, exists bool) {
	v := m.registration_number
	if v == nil {
		return
	}
	return *v, true
}

// OldRegistrationNumber returns the old "registration_number" field's value of the Vehicle entity.
// If the Vehicle object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VehicleMutation) OldRegistrationNumber(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRegistrationNumber is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRegistrationNumber requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRegistrationNumber: %w", err)
	}
	return oldValue.RegistrationNumber, nil
}

// ResetRegistrationNumber resets all changes to the "registration_number" field.
func (m *VehicleMutation) ResetRegistrationNumber() {
	m.registration_number = nil
}

// SetModel sets the "model" field.
func (m *VehicleMutation) SetModel(s string) {
	m.model = &s
}

// Model returns the value of the "model" field in the mutation.
func (m *VehicleMutation) Model() (r string, exists bool) {
	v := m.model
	if v == nil {
		return
	}
	return *v, true
}

// OldModel returns the old "model" field's value of the Vehicle entity.
// If the Vehicle object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VehicleMutation) OldModel(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldModel is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldModel requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldModel: %w", err)
	}
	return oldValue.Model, nil
}

// ResetModel resets all changes to the "model" field.
func (m *VehicleMutation) ResetModel() {
	m.model = nil
}

// SetSeat sets the "seat" field.
func (m *VehicleMutation) SetSeat(i int) {
	m.seat = &i
	m.addseat = nil
}

// Seat returns the value of the "seat" field in the mutation.
func (m *VehicleMutation) Seat() (r int, exists bool) {
	v := m.seat
	if v == nil {
		return
	}
	return *v, true
}

// OldSeat returns the old "seat" field's value of the Vehicle entity.
// If the Vehicle object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VehicleMutation) OldSeat(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSeat is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSeat requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSeat: %w", err)
	}
	return oldValue.Seat, nil
}

// AddSeat adds i to the "seat" field.
func (m *VehicleMutation) AddSeat(i int) {
	if m.addseat != nil {
		*m.addseat += i
	} else {
		m.addseat = &i
	}
}

// AddedSeat returns the value that was added to the "seat" field in this mutation.
func (m *VehicleMutation) AddedSeat() (r int, exists bool) {
	v := m.addseat
	if v == nil {
		return
	}
	return *v, true
}

// ResetSeat resets all changes to the "seat" field.
func (m *VehicleMutation) ResetSeat() {
	m.seat = nil
	m.addseat = nil
}

// SetCompanyID sets the "company" edge to the Company entity by id.
func (m *VehicleMutation) SetCompanyID(id int) {
	m.company = &id
}

// ClearCompany clears the "company" edge to the Company entity.
func (m *VehicleMutation) ClearCompany() {
	m.clearedcompany = true
}

// CompanyCleared reports if the "company" edge to the Company entity was cleared.
func (m *VehicleMutation) CompanyCleared() bool {
	return m.clearedcompany
}

// CompanyID returns the "company" edge ID in the mutation.
func (m *VehicleMutation) CompanyID() (id int, exists bool) {
	if m.company != nil {
		return *m.company, true
	}
	return
}

// CompanyIDs returns the "company" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// CompanyID instead. It exists only for internal usage by the builders.
func (m *VehicleMutation) CompanyIDs() (ids []int) {
	if id := m.company; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetCompany resets all changes to the "company" edge.
func (m *VehicleMutation) ResetCompany() {
	m.company = nil
	m.clearedcompany = false
}

// AddImageIDs adds the "images" edge to the VehicleImage entity by ids.
func (m *VehicleMutation) AddImageIDs(ids ...int) {
	if m.images == nil {
		m.images = make(map[int]struct{})
	}
	for i := range ids {
		m.images[ids[i]] = struct{}{}
	}
}

// ClearImages clears the "images" edge to the VehicleImage entity.
func (m *VehicleMutation) ClearImages() {
	m.clearedimages = true
}

// ImagesCleared reports if the "images" edge to the VehicleImage entity was cleared.
func (m *VehicleMutation) ImagesCleared() bool {
	return m.clearedimages
}

// RemoveImageIDs removes the "images" edge to the VehicleImage entity by IDs.
func (m *VehicleMutation) RemoveImageIDs(ids ...int) {
	if m.removedimages == nil {
		m.removedimages = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.images, ids[i])
		m.removedimages[ids[i]] = struct{}{}
	}
}

// RemovedImages returns the removed IDs of the "images" edge to the VehicleImage entity.
func (m *VehicleMutation) RemovedImagesIDs() (ids []int) {
	for id := range m.removedimages {
		ids = append(ids, id)
	}
	return
}

// ImagesIDs returns the "images" edge IDs in the mutation.
func (m *VehicleMutation) ImagesIDs() (ids []int) {
	for id := range m.images {
		ids = append(ids, id)
	}
	return
}

// ResetImages resets all changes to the "images" edge.
func (m *VehicleMutation) ResetImages() {
	m.images = nil
	m.clearedimages = false
	m.removedimages = nil
}

// AddTripIDs adds the "trips" edge to the Trip entity by ids.
func (m *VehicleMutation) AddTripIDs(ids ...int) {
	if m.trips == nil {
		m.trips = make(map[int]struct{})
	}
	for i := range ids {
		m.trips[ids[i]] = struct{}{}
	}
}

// ClearTrips clears the "trips" edge to the Trip entity.
func (m *VehicleMutation) ClearTrips() {
	m.clearedtrips = true
}

// TripsCleared reports if the "trips" edge to the Trip entity was cleared.
func (m *VehicleMutation) TripsCleared() bool {
	return m.clearedtrips
}

// RemoveTripIDs removes the "trips" edge to the Trip entity by IDs.
func (m *VehicleMutation) RemoveTripIDs(ids ...int) {
	if m.removedtrips == nil {
		m.removedtrips = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.trips, ids[i])
		m.removedtrips[ids[i]] = struct{}{}
	}
}

// RemovedTrips returns the removed IDs of the "trips" edge to the Trip entity.
func (m *VehicleMutation) RemovedTripsIDs() (ids []int) {
	for id := range m.removedtrips {
		ids = append(ids, id)
	}
	return
}

// TripsIDs returns the "trips" edge IDs in the mutation.
func (m *VehicleMutation) TripsIDs() (ids []int) {
	for id := range m.trips {
		ids = append(ids, id)
	}
	return
}

// ResetTrips resets all changes to the "trips" edge.
func (m *VehicleMutation) ResetTrips() {
	m.trips = nil
	m.clearedtrips = false
	m.removedtrips = nil
}

// Where appends a list predicates to the VehicleMutation builder.
func (m *VehicleMutation) Where(ps ...predicate.Vehicle) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the VehicleMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *VehicleMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Vehicle, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *VehicleMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *VehicleMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Vehicle).
func (m *VehicleMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *VehicleMutation) Fields() []string {
	fields := make([]string, 0, 5)
	if m.created_at != nil {
		fields = append(fields, vehicle.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, vehicle.FieldUpdatedAt)
	}
	if m.registration_number != nil {
		fields = append(fields, vehicle.FieldRegistrationNumber)
	}
	if m.model != nil {
		fields = append(fields, vehicle.FieldModel)
	}
	if m.seat != nil {
		fields = append(fields, vehicle.FieldSeat)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *VehicleMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case vehicle.FieldCreatedAt:
		return m.CreatedAt()
	case vehicle.FieldUpdatedAt:
		return m.UpdatedAt()
	case vehicle.FieldRegistrationNumber:
		return m.RegistrationNumber()
	case vehicle.FieldModel:
		return m.Model()
	case vehicle.FieldSeat:
		return m.Seat()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *VehicleMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case vehicle.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case vehicle.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case vehicle.FieldRegistrationNumber:
		return m.OldRegistrationNumber(ctx)
	case vehicle.FieldModel:
		return m.OldModel(ctx)
	case vehicle.FieldSeat:
		return m.OldSeat(ctx)
	}
	return nil, fmt.Errorf("unknown Vehicle field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *VehicleMutation) SetField(name string, value ent.Value) error {
	switch name {
	case vehicle.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case vehicle.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case vehicle.FieldRegistrationNumber:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRegistrationNumber(v)
		return nil
	case vehicle.FieldModel:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetModel(v)
		return nil
	case vehicle.FieldSeat:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSeat(v)
		return nil
	}
	return fmt.Errorf("unknown Vehicle field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *VehicleMutation) AddedFields() []string {
	var fields []string
	if m.addseat != nil {
		fields = append(fields, vehicle.FieldSeat)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *VehicleMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case vehicle.FieldSeat:
		return m.AddedSeat()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *VehicleMutation) AddField(name string, value ent.Value) error {
	switch name {
	case vehicle.FieldSeat:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddSeat(v)
		return nil
	}
	return fmt.Errorf("unknown Vehicle numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *VehicleMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *VehicleMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *VehicleMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Vehicle nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *VehicleMutation) ResetField(name string) error {
	switch name {
	case vehicle.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case vehicle.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case vehicle.FieldRegistrationNumber:
		m.ResetRegistrationNumber()
		return nil
	case vehicle.FieldModel:
		m.ResetModel()
		return nil
	case vehicle.FieldSeat:
		m.ResetSeat()
		return nil
	}
	return fmt.Errorf("unknown Vehicle field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *VehicleMutation) AddedEdges() []string {
	edges := make([]string, 0, 3)
	if m.company != nil {
		edges = append(edges, vehicle.EdgeCompany)
	}
	if m.images != nil {
		edges = append(edges, vehicle.EdgeImages)
	}
	if m.trips != nil {
		edges = append(edges, vehicle.EdgeTrips)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *VehicleMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case vehicle.EdgeCompany:
		if id := m.company; id != nil {
			return []ent.Value{*id}
		}
	case vehicle.EdgeImages:
		ids := make([]ent.Value, 0, len(m.images))
		for id := range m.images {
			ids = append(ids, id)
		}
		return ids
	case vehicle.EdgeTrips:
		ids := make([]ent.Value, 0, len(m.trips))
		for id := range m.trips {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *VehicleMutation) RemovedEdges() []string {
	edges := make([]string, 0, 3)
	if m.removedimages != nil {
		edges = append(edges, vehicle.EdgeImages)
	}
	if m.removedtrips != nil {
		edges = append(edges, vehicle.EdgeTrips)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *VehicleMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case vehicle.EdgeImages:
		ids := make([]ent.Value, 0, len(m.removedimages))
		for id := range m.removedimages {
			ids = append(ids, id)
		}
		return ids
	case vehicle.EdgeTrips:
		ids := make([]ent.Value, 0, len(m.removedtrips))
		for id := range m.removedtrips {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *VehicleMutation) ClearedEdges() []string {
	edges := make([]string, 0, 3)
	if m.clearedcompany {
		edges = append(edges, vehicle.EdgeCompany)
	}
	if m.clearedimages {
		edges = append(edges, vehicle.EdgeImages)
	}
	if m.clearedtrips {
		edges = append(edges, vehicle.EdgeTrips)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *VehicleMutation) EdgeCleared(name string) bool {
	switch name {
	case vehicle.EdgeCompany:
		return m.clearedcompany
	case vehicle.EdgeImages:
		return m.clearedimages
	case vehicle.EdgeTrips:
		return m.clearedtrips
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *VehicleMutation) ClearEdge(name string) error {
	switch name {
	case vehicle.EdgeCompany:
		m.ClearCompany()
		return nil
	}
	return fmt.Errorf("unknown Vehicle unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *VehicleMutation) ResetEdge(name string) error {
	switch name {
	case vehicle.EdgeCompany:
		m.ResetCompany()
		return nil
	case vehicle.EdgeImages:
		m.ResetImages()
		return nil
	case vehicle.EdgeTrips:
		m.ResetTrips()
		return nil
	}
	return fmt.Errorf("unknown Vehicle edge %s", name)
}

// VehicleImageMutation represents an operation that mutates the VehicleImage nodes in the graph.
type VehicleImageMutation struct {
	config
	op             Op
	typ            string
	id             *int
	created_at     *time.Time
	updated_at     *time.Time
	image          *string
	clearedFields  map[string]struct{}
	vehicle        *int
	clearedvehicle bool
	done           bool
	oldValue       func(context.Context) (*VehicleImage, error)
	predicates     []predicate.VehicleImage
}

var _ ent.Mutation = (*VehicleImageMutation)(nil)

// vehicleimageOption allows management of the mutation configuration using functional options.
type vehicleimageOption func(*VehicleImageMutation)

// newVehicleImageMutation creates new mutation for the VehicleImage entity.
func newVehicleImageMutation(c config, op Op, opts ...vehicleimageOption) *VehicleImageMutation {
	m := &VehicleImageMutation{
		config:        c,
		op:            op,
		typ:           TypeVehicleImage,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withVehicleImageID sets the ID field of the mutation.
func withVehicleImageID(id int) vehicleimageOption {
	return func(m *VehicleImageMutation) {
		var (
			err   error
			once  sync.Once
			value *VehicleImage
		)
		m.oldValue = func(ctx context.Context) (*VehicleImage, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().VehicleImage.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withVehicleImage sets the old VehicleImage of the mutation.
func withVehicleImage(node *VehicleImage) vehicleimageOption {
	return func(m *VehicleImageMutation) {
		m.oldValue = func(context.Context) (*VehicleImage, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m VehicleImageMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m VehicleImageMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *VehicleImageMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *VehicleImageMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().VehicleImage.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *VehicleImageMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *VehicleImageMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the VehicleImage entity.
// If the VehicleImage object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VehicleImageMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *VehicleImageMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *VehicleImageMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *VehicleImageMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the VehicleImage entity.
// If the VehicleImage object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VehicleImageMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *VehicleImageMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetImage sets the "image" field.
func (m *VehicleImageMutation) SetImage(s string) {
	m.image = &s
}

// Image returns the value of the "image" field in the mutation.
func (m *VehicleImageMutation) Image() (r string, exists bool) {
	v := m.image
	if v == nil {
		return
	}
	return *v, true
}

// OldImage returns the old "image" field's value of the VehicleImage entity.
// If the VehicleImage object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VehicleImageMutation) OldImage(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldImage is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldImage requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldImage: %w", err)
	}
	return oldValue.Image, nil
}

// ResetImage resets all changes to the "image" field.
func (m *VehicleImageMutation) ResetImage() {
	m.image = nil
}

// SetVehicleID sets the "vehicle" edge to the Vehicle entity by id.
func (m *VehicleImageMutation) SetVehicleID(id int) {
	m.vehicle = &id
}

// ClearVehicle clears the "vehicle" edge to the Vehicle entity.
func (m *VehicleImageMutation) ClearVehicle() {
	m.clearedvehicle = true
}

// VehicleCleared reports if the "vehicle" edge to the Vehicle entity was cleared.
func (m *VehicleImageMutation) VehicleCleared() bool {
	return m.clearedvehicle
}

// VehicleID returns the "vehicle" edge ID in the mutation.
func (m *VehicleImageMutation) VehicleID() (id int, exists bool) {
	if m.vehicle != nil {
		return *m.vehicle, true
	}
	return
}

// VehicleIDs returns the "vehicle" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// VehicleID instead. It exists only for internal usage by the builders.
func (m *VehicleImageMutation) VehicleIDs() (ids []int) {
	if id := m.vehicle; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetVehicle resets all changes to the "vehicle" edge.
func (m *VehicleImageMutation) ResetVehicle() {
	m.vehicle = nil
	m.clearedvehicle = false
}

// Where appends a list predicates to the VehicleImageMutation builder.
func (m *VehicleImageMutation) Where(ps ...predicate.VehicleImage) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the VehicleImageMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *VehicleImageMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.VehicleImage, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *VehicleImageMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *VehicleImageMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (VehicleImage).
func (m *VehicleImageMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *VehicleImageMutation) Fields() []string {
	fields := make([]string, 0, 3)
	if m.created_at != nil {
		fields = append(fields, vehicleimage.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, vehicleimage.FieldUpdatedAt)
	}
	if m.image != nil {
		fields = append(fields, vehicleimage.FieldImage)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *VehicleImageMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case vehicleimage.FieldCreatedAt:
		return m.CreatedAt()
	case vehicleimage.FieldUpdatedAt:
		return m.UpdatedAt()
	case vehicleimage.FieldImage:
		return m.Image()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *VehicleImageMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case vehicleimage.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case vehicleimage.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case vehicleimage.FieldImage:
		return m.OldImage(ctx)
	}
	return nil, fmt.Errorf("unknown VehicleImage field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *VehicleImageMutation) SetField(name string, value ent.Value) error {
	switch name {
	case vehicleimage.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case vehicleimage.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case vehicleimage.FieldImage:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetImage(v)
		return nil
	}
	return fmt.Errorf("unknown VehicleImage field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *VehicleImageMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *VehicleImageMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *VehicleImageMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown VehicleImage numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *VehicleImageMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *VehicleImageMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *VehicleImageMutation) ClearField(name string) error {
	return fmt.Errorf("unknown VehicleImage nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *VehicleImageMutation) ResetField(name string) error {
	switch name {
	case vehicleimage.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case vehicleimage.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case vehicleimage.FieldImage:
		m.ResetImage()
		return nil
	}
	return fmt.Errorf("unknown VehicleImage field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *VehicleImageMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.vehicle != nil {
		edges = append(edges, vehicleimage.EdgeVehicle)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *VehicleImageMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case vehicleimage.EdgeVehicle:
		if id := m.vehicle; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *VehicleImageMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *VehicleImageMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *VehicleImageMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedvehicle {
		edges = append(edges, vehicleimage.EdgeVehicle)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *VehicleImageMutation) EdgeCleared(name string) bool {
	switch name {
	case vehicleimage.EdgeVehicle:
		return m.clearedvehicle
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *VehicleImageMutation) ClearEdge(name string) error {
	switch name {
	case vehicleimage.EdgeVehicle:
		m.ClearVehicle()
		return nil
	}
	return fmt.Errorf("unknown VehicleImage unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *VehicleImageMutation) ResetEdge(name string) error {
	switch name {
	case vehicleimage.EdgeVehicle:
		m.ResetVehicle()
		return nil
	}
	return fmt.Errorf("unknown VehicleImage edge %s", name)
}
